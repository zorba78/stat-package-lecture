[
["control-structure.html", "2 제어문(Control Structure)", " 2 제어문(Control Structure) Sketch 프로그램이 무엇이고 이를 만들기 위해 어떤 것들이 필요할까? 프로그램 안의 특정 구문을 주어진 조건에 맞게 실행 여부를 제어하거나 동일한 작업을 반복할 수 있을까? 프로그램을 통해 특정 목적을 위한 나만의 함수를 만들 수 있을까? Figure 2.1: Flow-control example (https://homerhanumat.github.io/r-notes/flow.html) 참고: 본 장의 내용은 데이터과학 민주화와 Beginning Computer Programming with R의 내용을 기반으로 재구성함 "],
["control-prerequisite.html", "2.1 Prerequisite", " 2.1 Prerequisite 예약어(researved words): R에서 의미(sementic)를 미리 정해 놓은 단어 통계프로그래밍언어 강의노트 참고 Table 2.1: R 예약어 종류 및 설명 R 예약어 설명 if, else, while, function, in, next, break 조건, 함수, 반복문에 사용 TRUE/FALSE 논리 상수(logical constants) NULL 정의되지 않은 값 혹은 값이 없음 표현 Inf 무한(infinity) NaN 숫자가 아님(not a number) NA 결측값(not available) NA_integer_, NA_real_, NA_complex_, NA_character_ 결측값을 처리하는 상수 … 함수가 다른 함수에 인자를 전달하도록 지원 변수(variable): 사용자가 프로그램 처리를 위해 지정한 단어 적당한 값을 저장하고 나중에 필요시 해당 값을 호출해 사용하기 위한 목적으로 사용되는 표식(label) 예약어를 변수명으로 사용할 수 없음 통계프로그래밍언어 강의노트: R 기초문법 참고 고수준 언어(high-level language): 사람이 읽고 쓰기 쉬운 형태의 명령어를 컴퓨터가 읽고 처리할 수 있도록 고안된 프로그래밍 언어 컴퓨터가 이해할 수 있는 언어 \\(\\rightarrow\\) 중앙처리장치(central processing unit, CPU)가 이해하는 언어 \\(\\rightarrow\\) 기계어(machine language) 기계어는 0과 1로 구성된 이진수(binary number)임(예: 0100101001001001001110110101101010110) 고수준 언어의 종류: C, C++, JAVA, 베이직, Perl, Python, R, … 번역기(translator): 사람이 이해할 수 있는 표현(언어)를 기계(컴퓨터)가 이해할 수 있는 언어(기계어)로 변환 인터프리터(interpreter) 컴파일러(compiler) **인터프리터*: 코드(스크립트) 한 줄을 즉석에서 읽고, 파싱(프로그램을 검사하고 구문론적 구조를 분석)하고, 해석 R, Python, MATLAB 등은 인터프리터를 번역기로 사용 인터엑티브 모드 \\(\\rightarrow\\) R 프롬프트(&gt;) 뒤에 한 줄의 명령어를 작성하면 측석해서 처리 후 다음 입력에 대해 준비(prompt)함. 안녕하세요!! 통계패키지활용 수업에서 R을 배우고 있습니다. 처음이라 실수가 많습니다. 앞으로 잘 부탁해요!! Error: &lt;text&gt;:1:6: 예기치 않은 &#39;!&#39;입니다 1: 안녕하세요! ^ print(&quot;안녕하세요!!&quot;) print(&quot;통계패키지활용 수업을 위해 R을 배우고 있습니다.&quot;) print(&quot;처음이라 실수가 많습니다.&quot;) print(&quot;앞으로 잘 부탁해요!!&quot;) [1] &quot;안녕하세요!!&quot; [1] &quot;통계패키지활용 수업을 위해 R을 배우고 있습니다.&quot; [1] &quot;처음이라 실수가 많습니다.&quot; [1] &quot;앞으로 잘 부탁해요!!&quot; 컴파일러: 완전한 프로그램을 하나의 파일에 담고 파일 안에 저장되어 있는 소스코드를 기계어로 번역 후 다음 실행할 수 있도록 변환한 기계어를 파일에 담음. 보통은 .exe, .dll 파일 형태로 저장됨 "],
["control-program.html", "2.2 프로그램", " 2.2 프로그램 프로그램(program): 특정 작업(목적)을 수행할 수 있도록 작성한 일련의 R 문장(명령어)의 집합 일련의 문장(명령어)들은 텍스트 편집기를 통해 작성하며, 스크립트(script)로 명칭되는 파일로 저장 \\(\\rightarrow\\) R 스크립트 .R 확장자를 가짐 # Hello.R print(&quot;안녕 R!!&quot;) #한국어 print(&quot;Hi R!!&quot;) # 영어 print(&quot;こんにちはR!!&quot;) # 일본어 print(&quot;Γεια R!!&quot;) #그리스어 source(&quot;hello.R&quot;, encoding = &quot;UTF-8&quot;) [1] &quot;안녕 R!!&quot; [1] &quot;Hi R!!&quot; [1] &quot;こんにちはR!!&quot; [1] &quot;Γεια R!!&quot; 예시: 텍스트 파일에서 가장 자주 나오는 단어 찾기 프로그램 https://statkclee.github.io/r4inf/r-intro.html#r-intro-what-is-a-program 참고 require(tidyverse) require(stringr) require(ggpubr) require(ggthemes) text_dat &lt;- readLines(&quot;data/text-example-01.txt&quot;) # 공백 또는 구둣점 문자를 기준으로 텍스트 나누기 # 공백 또는 구둣점 문자 기준으로 텍스트 토큰화 split_wd &lt;- str_split(text_dat, pattern = &quot;\\\\b|[[:punct:]]&quot;) split_wd &lt;- do.call(c, split_wd) id &lt;- grepl(&quot;[a-zA-Z]+&quot;, split_wd) #알파벳을 포함한 단어 인덱스 split_wd &lt;- split_wd[id] unique_wd &lt;- unique(split_wd) # 중복을 제외한 총 사용 단어 res_v &lt;- vector(&quot;integer&quot;, length(unique_wd)) # 저장 벡터 생성 for (i in seq_along(unique_wd)) { for (j in seq_along(split_wd)) { if (unique_wd[i] == split_wd[j]) { res_v[i] &lt;- res_v[i] + 1 } } } bind_cols(&quot;word&quot; = unique_wd, &quot;freq&quot; = res_v) %&gt;% arrange(desc(freq)) 프로그램 작성을 위한 개념적 요소 입력(input): 외부로부터 가져온 데이터, 값 등 출력(output): 입력에 대한 반응(결과 출력, 파일 저장, 음악 재생, …) 순차실행(sequential execution): 스크립트 또는 코드 작성 순서에 따라 한줄씩 실행 조건실행(conditional execution): 특정 조건에 따라 문장(명령)을 실행하거나 건너뜀 번복실행(iterative execution): 특정 명령을 반복적으로 실행 재사용(resuse): 스크립트의 집합(다수 줄로 구성된 코드 또는 스크립트)에 이름을 부여하고 저장 \\(\\rightarrow\\) 사용자 지정 함수(function) 프로그램 오류의 종류 구문오류(syntax error): R 언어가 이해할 수 없는 문장 또는 문법으로 실행했을 때 나타나는 오류 \\(\\rightarrow\\) 가장 고치기 쉽고 즉각적으로 알려줌 논리 또는 run-time 오류(logic or run-time error): 구문은 완벽하지만 실행 순서 또는 논리적으로 연관방식에 문제가 있어서 명령어를 수행할 수 없는 경우 의미론적 오류(sementic error): 프로그램은 구문적으로 오류가 없고 실행되지만 올바른 결과를 출력하지 않는 경우 \\(\\rightarrow\\) 제일 고치기 어려움 가장 간단한 프로그래밍은 순차적으로 명령을 실행하되 입력 시 흐름을 잠시 중단하고 대기하는 방법 \\(\\rightarrow\\) 프롬프트 상 명령어 한 줄씩 입력 # 아주 간단한 프로그래밍 예제 # readline() 함수 이용해 R한테 인사 받기 name &lt;- readline(&quot;What&#39;s your name?: &quot;) cat(&quot;Hello, &quot;, name, &quot;!\\n&quot;, sep = &quot;&quot;) # readline() 함수를 이용해 알바비 계산 x &lt;- as.numeric(readline(prompt = &quot;하루 아르바이트 시간을 입력하시오: &quot;)) y &lt;- as.numeric(readline(prompt = &quot;시급을 입력하시오 (단위=원): &quot;)) z &lt;- as.numeric(readline(prompt = &quot;한달 동안 총 몇 일 동안 일을 하셨나요? &quot;)) cat(&quot;월 급여는 &quot;, x * y * z, &quot; 원 입니다.\\n&quot;, sep = &quot;&quot;) "],
["condition.html", "2.3 조건문(Conditionals)", " 2.3 조건문(Conditionals) if 구문을 통해 조건문 생성 불린 표현식(boolean expression): 참(TRUE) 또는 거짓(FALSE) 두 값 중 하나로 값이 도출되는 표현식1 비교 연산자(comparison operators) 같다, 같지 않다, 크다 등을 표현하기 위한 연산자 ==, !=, &gt;, &lt;, &gt;=, &lt;= 논리 연산자(logical operator) AND (&amp;, &amp;&amp;), OR (|, ||), NOT (!) x &lt;- 10; y &lt;- 13 # x가 2의 배수이고 y가 3의 배수 # 두 조건이 모두 참이여야 참 x %% 2 == 0 &amp; y %% 3 == 0 # x가 2의 배수이거나 y가 3의 배수 # 두 개 조건 중 하나만 참을 만족하면 참임 x %% 2 == 0 | y %% 3 == 0 # NOT (x &gt; y) !(x &gt; y) # 부정에 부정은 참 [1] FALSE [1] TRUE [1] TRUE 2.3.1 기본 구문 if (조건) 표현식 └ 괄호 안 조건을 만족하면 표현식을 실행하고 조건을 만족하지 않으면 실행하지 않음 x &lt;- 10 if (x &gt; 0) { print(&quot;x is positive&quot;) } x &lt;- -5 if (x &gt; 0) { print(&quot;x is positive&quot;) } [1] &quot;x is positive&quot; Figure 2.2: if 구문 기본 flow-chart if 구문의 사용 규칙 if 문은 조건을 정의하는 헤더 부분((, ))과 표현식이 위치하는 몸통 블록(body block, {표현식}) 으로 구성됨 (, )에 표현되는 조건은 벡터가 아닌 단일 값으로 나타내야 함. {, } 의 표현 또는 문장이 한 줄인 경우 블록 지정이 필요하지 않지만, 두 줄 이상인 경우 if 문의 범위를 지정해줘야 하기 때문에 꼭 중괄호(curly bracket, {})가 사용되야 함. # 조건문 사용 예시 x &lt;- c(TRUE, FALSE, FALSE) y &lt;- c(TRUE, TRUE, FALSE) z &lt;- &quot;Both TRUE!!&quot; if (x[1] &amp; y[1]) print(z) # x, y 첫 번째 원소만 사용 if (x &amp;&amp; y) print(z) # 강제로 첫 번째 원소만 사용 if (x &amp; y) print(z) # 경고 표시 Warning in if (x &amp; y) print(z): length &gt; 1 이라는 조건이 있고, 첫번째 요소만이 사용될 것입니다 [1] &quot;Both TRUE!!&quot; [1] &quot;Both TRUE!!&quot; [1] &quot;Both TRUE!!&quot; 대안 실행(alternative execution) 두 가지 경우가 존재하고 조건에 따라 어떤 명령을 실행할지를 결정 if와 else로 표현 가능 조건에 따라 실행이 분기(branch) 되기 때문에 if-else 구문을 분기문이라고도 함 else 는 if 조건을 배제(exclusive)한 나머지 경우이기 때문에 조건을 따로 지정하지 않으며, if와 동일하게 중괄호 내에 표현되어야 함 x &lt;- 9 if (x %% 2 == 0) { print(&quot;x is even&quot;) } else { print(&quot;x is odd&quot;) } [1] &quot;x is odd&quot; Figure 2.3: 대안실행(if-else 구문) flow-chart 2.3.2 연쇄 조건문(chained condition) 두 가지 이상의 분기가 존재하는 경우 조건 표현식 연쇄 조건문의 표현은 아래와 같음 if (조건1) { 표현식1 ... } else if (조건2) { 표현식2 ... } else { 표현식3 ... } x &lt;- 5; y &lt;- 10 if (x &lt; y) { print(&quot;x is less than y&quot;) } else if (x &gt; y) { print(&quot;x is greater than y&quot;) } else { print(&quot;x is equal to y&quot;) } [1] &quot;x is less than y&quot; Figure 2.4: 연쇄조건(if-else if-else 구문) flow-chart 2.3.3 중첩 조건문(nested contition) 하나의 조건문 내부에 하위 조건식이 존재하는 형태 if (조건1) { 표현식1 ... } else { if (조건2) { 표현식2 ... } else { 표현식3 ... } } x &lt;- 10; y &lt;- 10 if (x == y) { print(&quot;x is equal to y&quot;) } else { if (x &gt; y) { print(&quot;x is greater than y&quot;) } else { print(&quot;x is less than y&quot;) } } [1] &quot;x is equal to y&quot; Figure 2.5: 중첩 조건문 flow-chart 중첩 조건문은 코드의 가독성을 떨어뜨리기 때문에 피하는 것을 권장 중첩 조건문을 피하기 위한 한 가지 방법은 논리 연산자를 활용 # 중첩조건 x &lt;- 58 if (x &gt; 0) { if (x &lt; 10) { print(&quot;x는 한 자리 양수&quot;) } else { if (x &lt; 100) { print(&quot;x는 두 자리 양수&quot;) } else { print(&quot;x는 세 자리 이상 양수&quot;) } } } [1] &quot;x는 두 자리 양수&quot; # 연쇄 조건 x &lt;- 2020 if (x &gt; 0 &amp; x &lt; 10) { print(&quot;x는 한 자리 양수&quot;) } else if (x &gt;=10 &amp; x &lt; 100) { print(&quot;x는 두 자리 양수&quot;) } else { print(&quot;x는 세 자리 이상 양수&quot;) } [1] &quot;x는 세 자리 이상 양수&quot; 2.3.4 ifelse() 함수 if-else 구문을 사용하기 쉽게 구현된 R 내장 함수 if-else 구문과 다르게 조건 부분에 한 값(스칼라)이 아닌 논리형 벡터를 입력값으로 받아 조건에 따른 값(벡터)을 반환 # ifelse() 함수 인수 # help(ifelse) 참고 ifelse( test, 조건에 따른 논리형 벡터 yes, test에 정의한 조건이 참인 경우 새로운 벡터에 대입할 값 no, test 조건이 거짓인 경우 대입할 값 ) 사용 예시 # 평균이 23이고 표준편차가 5인 정규분포로부터 30개의 난수 추출 set.seed(12345) bmi &lt;- rnorm(30, 23, 5) bmi_cat &lt;- ifelse(bmi &lt; 25, &quot;normal&quot;, &quot;overweight&quot;) bmi_cat [1] &quot;overweight&quot; &quot;overweight&quot; &quot;normal&quot; &quot;normal&quot; &quot;overweight&quot; [6] &quot;normal&quot; &quot;overweight&quot; &quot;normal&quot; &quot;normal&quot; &quot;normal&quot; [11] &quot;normal&quot; &quot;overweight&quot; &quot;normal&quot; &quot;overweight&quot; &quot;normal&quot; [16] &quot;overweight&quot; &quot;normal&quot; &quot;normal&quot; &quot;overweight&quot; &quot;normal&quot; [21] &quot;overweight&quot; &quot;overweight&quot; &quot;normal&quot; &quot;normal&quot; &quot;normal&quot; [26] &quot;overweight&quot; &quot;normal&quot; &quot;overweight&quot; &quot;overweight&quot; &quot;normal&quot; # ifelse() 함수를 연쇄조건문 처럼 사용할 수 있다 bmi_cat2 &lt;- ifelse(bmi &lt; 18.5, &quot;underweight&quot;, ifelse(bmi &lt; 24.9, &quot;normal&quot;, ifelse(bmi &lt; 29.9, &quot;overweight&quot;, &quot;obesity&quot;))) bmi_cat2 [1] &quot;overweight&quot; &quot;overweight&quot; &quot;normal&quot; &quot;normal&quot; &quot;overweight&quot; [6] &quot;underweight&quot; &quot;overweight&quot; &quot;normal&quot; &quot;normal&quot; &quot;underweight&quot; [11] &quot;normal&quot; &quot;obesity&quot; &quot;normal&quot; &quot;overweight&quot; &quot;normal&quot; [16] &quot;overweight&quot; &quot;normal&quot; &quot;normal&quot; &quot;overweight&quot; &quot;normal&quot; [21] &quot;overweight&quot; &quot;obesity&quot; &quot;normal&quot; &quot;underweight&quot; &quot;underweight&quot; [26] &quot;obesity&quot; &quot;normal&quot; &quot;overweight&quot; &quot;overweight&quot; &quot;normal&quot; 비교 및 논리 연산자(통계프로그래밍언어 2.1.4절 참고)↩︎ "],
["looping.html", "2.4 반복문(Looping)", " 2.4 반복문(Looping) Prerequisite 프로그램 또는 알고리즘 구현 시 특정 문장 또는 표현을 반복해야만 하는 상황이 발생 특히 시뮬레이션 시 반복문은 거의 필수적임 반복문을 통해 코딩의 효율을 극대화 할 수 있음 반복문은 특정 변수의 값을 갱신(update) 하기 위해 주로 사용 x &lt;- x + 1 # 현재 값에 1을 더해서 x를 새로운 값으로 update 통상적으로 특정 변수의 값을 갱신하기 위해 변수 값을 초기화(initialize) x &lt;- 0 # x 변수 초기화 x &lt;- x + 1 몇 번 반복이라는 정의가 없는 상태에서 특정 조건이 거짓(FALSE)이 될 때 까지 계속 반복 2.4.1 repeat 구문 repeat 표현식 repeat 다음에 오는 표현식을 무한 반복(infinite loop) repeat print(&quot;무한 루프에 걸림...ESC 키 누르시오!!&quot;) [1] &quot;무한 루프에 걸림...ESC 키 누르시오!!&quot; [1] &quot;무한 루프에 걸림...ESC 키 누르시오!!&quot; [1] &quot;무한 루프에 걸림...ESC 키 누르시오!!&quot; [1] &quot;무한 루프에 걸림...ESC 키 누르시오!!&quot; [1] &quot;무한 루프에 걸림...ESC 키 누르시오!!&quot; ... ... 특정 작업에 대해 블록을 지정(중괄호)하고 블록 안에 표현 가능 일반적으로 특정 조건(if (조건) break)을 두어 무한루프에서 탈출 if 문의 조건은 언제 반복이 끝날 지를 제어하는 변수로 반복변수(iteration variable) 이라고도 함 언제까지(until) 반복(repeat) \\(\\rightarrow\\) REPEAT-UNTIL 구문으로 표현 repeat { 표현식 1 if (조건) break 반복변수 update } Figure 2.6: REPEAT 구문 flow-chart # REPEAT-UNTIL 예시 1 # 1:100 까지 합 계산 함수 tot &lt;- 0; i &lt;- 1 # 사용 변수 초기화 (update 변수) repeat { tot &lt;- tot + i if (i &gt;= 100) break # i는 반복 변수 i &lt;- i + 1 } tot # check sum(1:100) [1] 5050 [1] 5050 tot에 i를 더한 후 i 가 조건을 만족하는지 확인 조건에 부합하지 않으면 다음 문장 실행(i에 1을 증가 후 업데이트) 1. 의 작업을 반복(loop) i가 조건에 부합하면 반복 종료 # REPEAT 예시 2 # 1에서 20 사이 숫자 알아맞추기 게임 n &lt;- 20 number &lt;- sample(1:n, size = 1) cat(&quot;1에서 &quot;, n, &quot;까지 숫자 알아 맞추기&quot;, sep = &quot;&quot;) repeat { guess &lt;- readline(&quot;어떤 숫자를 생각하시나요? (종료: q 입력) &quot;) if (guess == &quot;q&quot;) { cat(&quot;재미가 없나봐요.\\n&quot;) break } else if (as.numeric(guess) == number) { cat(&quot;천재인데요?ㅋㅋㅋ&quot;) break } # 틀리면 계속 반복 } guess에 readline() 으로부터 값 입력 guess 값이 q 이면 종료 guess 값이 number 와 일치하면 종료 2.와 3. 조건에 부합하지 않으면 guess 값을 반복적으로 입력 어떤 숫자를 생각하시나요? (종료: q 입력) 1 어떤 숫자를 생각하시나요? (종료: q 입력) 2 어떤 숫자를 생각하시나요? (종료: q 입력) 3 천재인데요?ㅋㅋㅋ 2.4.2 while 구문 while (조건) 표현식 ... while에 지정된 조건이 참이면 계속해서 반복 repeat는 반복이 처음부터 시작되는 반면, while 문은 조건을 먼저 평가한 후 반복이 시작됨. while (FALSE)인 경우 루프 본문 코드가 실행되지 않음 while (TRUE)는 repeat 구문과 동일 while문 의 일반적 형태 while (조건) { 표현식 1 반복변수 update } Figure 2.7: WHILE 구문 flow-chart # WHILE 구문 예시 1 # 1:100 까지 합 계산 함수 tot &lt;- 0; i &lt;- 1 # 사용 변수 초기화 (update 변수) while (i &lt;= 100) { tot &lt;- tot + i i &lt;- i + 1 } tot [1] 5050 초기값 i가 조건 i &lt;= 100 인지 확인 참인 경우 tot + i를 통해 tot을 업데이트 한 다음 i를 1만큼 증가 만약 i에 대한 조건 평가 결과가 거짓이면 while 구문을 빠져나감 # while 문 조건이 TRUE 인 경우 tot &lt;- 0; i &lt;- 1 # 사용 변수 초기화 (update 변수) while (TRUE) { tot &lt;- tot + i if (i &gt;= 100) break i &lt;- i + 1 } tot [1] 5050 while 의 조건이 참이기 때문에 무한 반복 단 i가 100과 같거나 클 경우 구문 탈출 그 전 까지는 tot와 i를 갱신 # WHILE 구문 예시 2 # 문자열 벡터에서 특정 문자열의 인덱스를 반환 txtvec &lt;- c(&quot;R&quot;, &quot;package&quot;, &quot;flow-control&quot;, &quot;while&quot;, &quot;if&quot;, &quot;for&quot;, &quot;repeat&quot;) found &lt;- FALSE i &lt;- 1 word &lt;- readline(&quot;검색할 텍스트: &quot;) while (!found &amp; i &lt;= length(txtvec)) { if (txtvec[i] == word) { found &lt;- TRUE break } cat(i, &quot; 번째 위치에 해당 단어가 존재하지 않습니다.\\n&quot;, sep=&quot;&quot;) i &lt;- i + 1 } if (found) { cat(i, &quot; 번째 위치에 &quot;, word, &quot;를 찾았습니다.&quot;, sep = &quot;&quot;) } else { cat(word, &quot; 단어는 해당 문자열 벡터에 존재하지 않습니다.\\n&quot;, sep = &quot;&quot;) } found = FALSE, i = 1을 초기값으로 입력 readline()으로 입력한 텍스트를 word에 저장 found 가 참이고 i가 텍스트 벡터의 길이 값과 같을 때 까지 다음 구문 반복 txtvec 각 원소와 word 값이 같은지 확인 while 입력 결과 1 번째 위치에 해당 단어가 존재하지 않습니다. 2 번째 위치에 해당 단어가 존재하지 않습니다. 3 번째 위치에 해당 단어가 존재하지 않습니다. 4 번째 위치에 while 를 찾았습니다. temp 입력 결과 1 번째 위치에 해당 단어가 존재하지 않습니다. 2 번째 위치에 해당 단어가 존재하지 않습니다. 3 번째 위치에 해당 단어가 존재하지 않습니다. 4 번째 위치에 해당 단어가 존재하지 않습니다. 5 번째 위치에 해당 단어가 존재하지 않습니다. 6 번째 위치에 해당 단어가 존재하지 않습니다. 7 번째 위치에 해당 단어가 존재하지 않습니다. temp 단어는 해당 문자열 벡터에 존재하지 않습니다. repeat, while과 같이 반복의 횟수가 지정되지 않는 반목구문을 불확정 반복문(indefinite loop)이라고 함. 다음에 배울 for 구문은 위 두 반복문과는 다르게 반복의 범위를 명확히 지정하기 때문에 확정 반복문(definite loop)라고 함. 2.4.3 for 구문 가장 많이 사용되는 반복구문으로 일반적인 형태는 아래와 같음 for (반복변수 in sequence) { 표현식 1 ... } R에서 sequence은 특정 유형의 벡터이며, 반복변수에 sequence의 원소를 순차적으로 할당함 반복변수는 for 반복문 안의 표현식 1에서 사용됨 Figure 2.8: FOR 구문 flow-chart #for 문 예시 1 student &lt;- readxl::read_excel(&quot;data/stat-students.xlsx&quot;) student_name &lt;- student$이름 for (s in student_name) { cat(s, &quot;학생!! 즐거운 명절 보내세요^^\\n&quot;) } 김세민 학생!! 즐거운 명절 보내세요^^ 김기랑 학생!! 즐거운 명절 보내세요^^ 이종영 학생!! 즐거운 명절 보내세요^^ 이원규 학생!! 즐거운 명절 보내세요^^ 황보영 학생!! 즐거운 명절 보내세요^^ 구나현 학생!! 즐거운 명절 보내세요^^ 엄용현 학생!! 즐거운 명절 보내세요^^ 오동원 학생!! 즐거운 명절 보내세요^^ 윤지우 학생!! 즐거운 명절 보내세요^^ 이근범 학생!! 즐거운 명절 보내세요^^ 이승호 학생!! 즐거운 명절 보내세요^^ 이희도 학생!! 즐거운 명절 보내세요^^ 정보경 학생!! 즐거운 명절 보내세요^^ 채시진 학생!! 즐거운 명절 보내세요^^ 최호진 학생!! 즐거운 명절 보내세요^^ 박인혜 학생!! 즐거운 명절 보내세요^^ 박준기 학생!! 즐거운 명절 보내세요^^ 최소미 학생!! 즐거운 명절 보내세요^^ 백승완 학생!! 즐거운 명절 보내세요^^ 김지원 학생!! 즐거운 명절 보내세요^^ 신형원 학생!! 즐거운 명절 보내세요^^ 임현정 학생!! 즐거운 명절 보내세요^^ 정수빈 학생!! 즐거운 명절 보내세요^^ 최예린 학생!! 즐거운 명절 보내세요^^ 황정인 학생!! 즐거운 명절 보내세요^^ student_name의 첫 번째 원소를 s에 할당 for 구문 안에 표현 실행 student_name의 마지막 원소까지 반복 # 위 예시와 동일한 표현 ## 인덱싱을 사용 for (i in 1:length(student_name)) { cat(student_name[i], &quot;학생!! 즐거운 명절 보내세요^^\\n&quot;) } ## sequence를 만드는 함수 seq_along() 사용 for (i in seq_along(student_name)) { cat(student_name[i], &quot;학생!! 즐거운 명절 보내세요^^\\n&quot;) } for 구문 안에 for 문을 1개 이상 중첩 가능 ## 2중 for 문 예시 set.seed(12345) id &lt;- sample(1:length(student_name), 5) sel_student &lt;- student_name[id] for (i in seq_along(student_name)) { for (j in seq_along(sel_student)) { if (student_name[i] == sel_student[j]) { cat(sel_student[j], &quot;님!! 당첨 축하 드립니다!!\\n&quot;) } } } 김기랑 님!! 당첨 축하 드립니다!! 이승호 님!! 당첨 축하 드립니다!! 채시진 님!! 당첨 축하 드립니다!! 박인혜 님!! 당첨 축하 드립니다!! 백승완 님!! 당첨 축하 드립니다!! 불확정 반복문 학습 시 무한루프로부터 break를 통해 루프에서 탈출 루프를 완전히 탈출하지 않고 현재 반복을 중지하고 그 다음 반복을 진행하고 싶을 경우 next 예약어를 사용 # 알파벳 e와 일치하는 경우에만 텍스트 메세지 출력 vec &lt;- c(&quot;a&quot;,&quot;e&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;, &quot;e&quot;, &quot;z&quot;) word &lt;- &quot;e&quot; for (i in 1:length(vec)) { if (vec[i] != word) next cat(word, &quot;가&quot;, i, &quot;번 째 인덱스에 있네요!!\\n&quot;) } e 가 2 번 째 인덱스에 있네요!! e 가 3 번 째 인덱스에 있네요!! e 가 7 번 째 인덱스에 있네요!! "],
["function.html", "2.5 함수 (function)", " 2.5 함수 (function) Figure 2.9: 함수 함수: 특정한 목적을 위한 연산을 수행하기 위해 명명된 일련의 문장(추상화) 예: sum(x) \\(\\rightarrow\\) 벡터 x의 값을 모두 합산하는 함수로 “sum” 이라고 명명된 내장 함수 R 콘솔에서 함수 명칭(예: sum)을 입력 후 실행하면 함수 내부 확인 가능 sum function (..., na.rm = FALSE) .Primitive(&quot;sum&quot;) 함수의 명칭(위의 예에서 sum)으로 특정 합수를 호출(call) R의 스크립트는 내장된 혹은 사용자가 정의한 함수들을 호출함으로써 작성됨 함수를 사용해야만 하는 이유 매우 큰 프로그램 작업을 해야할 경우 함수를 통해 작업 단위 별로 분할 가능 한 번 작성한 함수는 재사용 가능 프로그램의 체계적 관리가 가능하기 때문에 유지 및 보수가 용이 프로그램 코드의 간결화 2.5.1 함수의 정의 function 이라는 R의 예약어를 통해 사용자 함수 정의 함수 정의 시 함수의 명칭을 반드시 부여해야 함 함수 이름 &lt;- function() 함수는 일반적으로 인수(argument)로 입력값을 전달 받으면 그 결과값을 반환(return) 함수의 인수와 반환에 따라 다음과 같이 4 가지 유형의 함수 정의 가능 인수를 갖는 함수 인수를 갖지 않는 함수 값을 반환하는 함수 값을 반환하지 않는 함수 # (1) 인수를 갖는 함수 ## (모)분산을 계산하는 함수 var_pop &lt;- function(x) { n &lt;- length(x) if (n &lt; 2) { stop(&quot;적어도 두 개 이상의 관찰값이 존재해야 합니다&quot;) } mx &lt;- mean(x) v &lt;- sum((x - mx)^2)/n return(v) # 결과를 반환하는 함수: v를 함수의 출력값으로 설정 } ## test set.seed(1) # 동일한 난수 생성을 위해 seed 번호 부여 x &lt;- rnorm(1) var_pop(x) Error in var_pop(x): 적어도 두 개 이상의 관찰값이 존재해야 합니다 set.seed(1000) x &lt;- rnorm(1000, 2, 4) # 평균이 2이고 표준편차가 4인 정규분포로부터 1000개 난수 추출 var_pop(x) [1] 15.40581 # (2) 인수를 갖지 않는 함수 print_lyrics_let_it_be &lt;- function() { print(&quot;When I find myself in times of trouble, &quot;) print(&quot;Mother Mary comes to me.&quot;) print(&quot;Speaking words of wisdom &#39;let it be&#39;.&quot;) } print_lyrics_let_it_be() [1] &quot;When I find myself in times of trouble, &quot; [1] &quot;Mother Mary comes to me.&quot; [1] &quot;Speaking words of wisdom &#39;let it be&#39;.&quot; print_lyrics_let_it_be(beatles) Error in print_lyrics_let_it_be(beatles): 사용되지 않은 인자 (beatles) ## 주사위를 돌리는 함수 rolling_dice &lt;- function() { sample(1:6, 1, replace = TRUE) } rolling_dice(); rolling_dice(); rolling_dice(); [1] 4 [1] 4 [1] 4 # (3) 값을 반환하는 함수 manual_mean &lt;- function(x) { n &lt;- length(x) sumi &lt;- 0 for (i in 1:n) { sumi &lt;- sumi + x[i] } return(sumi/n) } set.seed(20) x &lt;- sample(1:200, 20, replace = FALSE) # 1 ~ 200 중 랜덤하게 20개 추출(비복원) manual_mean(x) [1] 107 # 미리 정의하지 않은 인수를 입력한 경우 set.seed(4) na_idx &lt;- sample(1:length(x), 4) x[na_idx] &lt;- NA manual_mean(x, na.rm = TRUE) Error in manual_mean(x, na.rm = TRUE): 사용되지 않은 인자 (na.rm = TRUE) # (4) 값을 반환하지 않는 함수(void function) summary_mean &lt;- function(x, ...) { n &lt;- sum(!is.na(x)) mx &lt;- sum(x, ...)/n cat(&quot;Data: &quot;, sprintf(&quot;%.2f&quot;, x), &quot;\\n&quot;) # 소숫점 2째 짜리 까지 출력 cat(&quot;전체 관찰값 개수(결측 제외) = &quot;, n, &quot;\\n&quot;) cat(&quot;산술평균 = &quot;, mx, &quot;\\n&quot;) } set.seed(20) x &lt;- rnorm(20) summary_mean(x) Data: 1.16 -0.59 1.79 -1.33 -0.45 0.57 -2.89 -0.87 -0.46 -0.56 -0.02 -0.15 -0.63 1.32 -1.52 -0.44 0.97 0.03 -0.09 0.39 전체 관찰값 개수(결측 제외) = 20 산술평균 = -0.1877639 result &lt;- summary_mean(x) Data: 1.16 -0.59 1.79 -1.33 -0.45 0.57 -2.89 -0.87 -0.46 -0.56 -0.02 -0.15 -0.63 1.32 -1.52 -0.44 0.97 0.03 -0.09 0.39 전체 관찰값 개수(결측 제외) = 20 산술평균 = -0.1877639 result NULL x[na_idx] &lt;- NA # ...를 통해 미리 정하지 않은 인수를 # 함수 내부에서 호출한 다른 함수로 전달 가능 summary_mean(x, na.rm = TRUE) Data: 1.16 -0.59 NA -1.33 -0.45 0.57 NA -0.87 -0.46 -0.56 NA -0.15 -0.63 1.32 -1.52 -0.44 0.97 0.03 NA 0.39 전체 관찰값 개수(결측 제외) = 16 산술평균 = -0.1590692 x &lt;- summary_mean(x, na.rm = TRUE) Data: 1.16 -0.59 NA -1.33 -0.45 0.57 NA -0.87 -0.46 -0.56 NA -0.15 -0.63 1.32 -1.52 -0.44 0.97 0.03 NA 0.39 전체 관찰값 개수(결측 제외) = 16 산술평균 = -0.1590692 2.5.2 함수의 인수 전달 방법 함수는 입력값(input) 을 가지며, 이러한 입력값은 함수의 인수(argument)에 해당 값을 할당함으로써 입력값이 함수로 전달됨 함수의 인수 정의는 내 마음대로 가능(개수 무관) R에서 함수 호출 시 인수 전달은 “값”을 호출 하는 방식(call by value) call by value와 상반되는 개념으로 참조에 의한 호출(call by reference)로 값이 아니라 값이 저장되어 있는 메모리의 주소 값을 전달하는 방식(대표적인 예: C 언어의 포인터)임. 계산 효율은 참조에 의한 호출이 월등히 뛰어나지만, 프로그램의 구조가 복잡하다는 단점을 가짐. R은 데이터 분석에 특화된 프로그램이기 때문에 직관적인 call by value 방식을 택함. 예시 # 두 변수의 값을 바꾸는 함수: swap swap &lt;- function(x, y) { temp &lt;- x x &lt;- y y &lt;- temp cat(&quot;두 값이 바뀌었습니다.&quot;, sprintf(&quot;x = %d, y = %d&quot;, x, y) ,&quot;\\n&quot;) } x &lt;- 3; y &lt;- 10 swap(x, y) 두 값이 바뀌었습니다. x = 10, y = 3 x; y # x, y 두 값이 바뀌지 않음 [1] 3 [1] 10 인수를 전달하는 방법은 다음 두 가지임 인수의 위치 순서에 의한 전달: 정의한 인수의 순서대로 각 인수에 대응하는 값을 전달 인수의 이름에 의한 전달: 위치와 관계 없이 정의한 인수의 이름을 지정하여 값을 전달 # 표준편차 계산 함수: stdev stdev &lt;- function(x, na.rm = TRUE) { if (is.matrix(x)) apply(x, 2, sd, na.rm = na.rm) else if (is.vector(x)) sqrt(var(x, na.rm = na.rm)) else if (is.data.frame(x)) sapply(x, sd, na.rm = na.rm) else sqrt(var(as.vector(x), na.rm = na.rm)) } set.seed(1000) X &lt;- matrix(rnorm(1000), 100, 10) x &lt;- rpois(50, lambda = 10) # 포아송 분포(lambda = 10)에서 50개 난수 추출 dat &lt;- mtcars # R 내장 데이터를 dat 에 저장 # (1) 순서에 의한 전달 stdev(X, T); stdev(X) # 동일한 결과 [1] 1.0065940 0.9033927 0.9727257 0.9905631 0.8202803 1.0114516 0.9855547 [8] 1.0211373 1.0716219 1.0426811 [1] 1.0065940 0.9033927 0.9727257 0.9905631 0.8202803 1.0114516 0.9855547 [8] 1.0211373 1.0716219 1.0426811 stdev(x) [1] 3.41569 stdev(dat) mpg cyl disp hp drat wt 6.0269481 1.7859216 123.9386938 68.5628685 0.5346787 0.9784574 qsec vs am gear carb 1.7869432 0.5040161 0.4989909 0.7378041 1.6152000 stdev(TRUE, dat) # 오류 why?? Warning in if (na.rm) &quot;na.or.complete&quot; else &quot;everything&quot;: length &gt; 1 이라는 조건 이 있고, 첫번째 요소만이 사용될 것입니다 Error in if (na.rm) &quot;na.or.complete&quot; else &quot;everything&quot;: argument is not interpretable as logical # (2) 이름에 의한 전달 set.seed(5) na_idx &lt;- sample(1:50, 5) x[na_idx] &lt;- NA stdev(na.rm = T, x = x) [1] 3.411211 stdev(dat = dat, na.rm = TRUE) # 오류 why??? Error in stdev(dat = dat, na.rm = TRUE): 사용되지 않은 인자 (dat = dat) 2.5.3 함수의 기본 구성 요소 Figure 2.10: 함수의 기본 구조 function()에서 () 안의 부분(일반적으로 첫 번째 줄)을 머리(header) 부분 함수의 초기 형태(매개변수 또는 인수의 형태)를 지정 연산 또는 명령이 수행되는 부분은 함수의 몸통(body) 부분({} 로 표시) 함수 내부에서 실행되는 연산 명령어들의 집합으로 구성 인수(argument): 함수의 기능을 선택적으로 조정하는 parameter로 함수 안에서 작동하는 매개변수들을 통칭 인수는 argument 또는 argument = default value로 설정 복수의 인수는 콤마(,)로 구분 \\(\\rightarrow\\) fun_name &lt;- function(arg1, arg2, arg3) 특수 인수 ...: 어떠한 개수의 인수를 함수로 전달할 수 있음 일반적으로 인수의 개수가 불특정하거나 함수 안에서 다른 함수를 호출할 때 특정 인수를 다른 함수로 전달시킬 때 유용(위 예시 참고) # (1) 인수에 default 값을 주지 않은 함수 fun_without_arg_default &lt;- function(x, y) { x*y } set.seed(10) a &lt;- sample(1:20, 10, replace = TRUE) # 복원 추출 a[7] &lt;- NA b &lt;- 5 fun_without_arg_default(a, b) [1] 55 45 50 80 60 40 NA 95 75 75 # (2) 인수에 default 값을 부여한 함수 fun_with_arg_default &lt;- function(x = 5, y = 8) { x*y } fun_with_arg_default() [1] 40 trim_mean &lt;- function(x, trim = 0, na.rm = F) { mean(x, trim = trim, na.rm = na.rm) } trim_mean(a) [1] NA trim_mean(x = a, trim = 0.2, na.rm = TRUE) # 인수 이름으로 값 전달 [1] 12.57143 trim_mean(a, 0.3, TRUE) # 인수 순서대로 값 전달 [1] 12.6 # (3) ... 인수 사용 예제 # list() 함수를 이용해 `...`에 해당하는 인수들을 리스트 객체로 만든 후 # 이를 함수에서 사용 dot_example &lt;- function(x, ...) { # browser() trim &lt;- 0 na.rm &lt;- FALSE dots &lt;- list(...) # ...에 해당하는 인수 추출 for (arg in names(dots)) { if (arg == &quot;trim&quot;) trim &lt;- as.numeric(dots[arg]) if (arg == &quot;na.rm&quot;) na.rm &lt;- as.logical(dots[arg]) } mean(x, trim = trim, na.rm = na.rm) } dot_example(a) [1] NA set.seed(30) a &lt;- sample(1:30, 15, replace = TRUE) # 복원 추출 dot_example(a) [1] 17.06667 a[9] &lt;- NA dot_example(a) [1] NA dot_example(a, trim = 0.1, na.rm = TRUE) [1] 17.75 # (4) `...` 인수가 함수 내 사용(호출)된 # 다른 함수의 인수로 전달하는 경우 # summary_mean() 함수 예제와 유사 mean_manual &lt;- function(x, ...) { mean(x, ...) } set.seed(30) x &lt;- rnorm(30, mean = 10, sd = 5) na_idx &lt;- sample(1:30, 3, replace = TRUE) xna &lt;- x; xna[na_idx] &lt;- NA mean_manual(x) [1] 8.347683 mean_manual(xna) [1] NA mean_manual(xna, na.rm = TRUE) [1] 8.127862 mean_manual(x = xna, trim = 0.2, na.rm = TRUE) [1] 7.534424 함수 몸체 안에 browser()을 입력하면, browser() 전 까지 함수 몸체 안 명령들이 수행되고, 이후 명령들이 어떻게 실행되는지 확인할 수 있음. 함수 작성 시 함수 로직을 세우고 디버깅 할 때 매우 유용하게 사용 인수 관련 몇 가지 유용한 함수들 args(): 특정 함수에서 사용되는 인수 확인 args(fun_without_arg_default) function (x, y) NULL args(rnorm) function (n, mean = 0, sd = 1) NULL body(): 함수의 몸체 조회 body(var_pop) { n &lt;- length(x) if (n &lt; 2) { stop(&quot;적어도 두 개 이상의 관찰값이 존재해야 합니다&quot;) } mx &lt;- mean(x) v &lt;- sum((x - mx)^2)/n return(v) } body(dot_example) { trim &lt;- 0 na.rm &lt;- FALSE dots &lt;- list(...) for (arg in names(dots)) { if (arg == &quot;trim&quot;) trim &lt;- as.numeric(dots[arg]) if (arg == &quot;na.rm&quot;) na.rm &lt;- as.logical(dots[arg]) } mean(x, trim = trim, na.rm = na.rm) } match.arg(): 인수를 매치하는 함수로 매치할 대상의 인수를 지정 arg: 매치할 대상 인수 지정 choice: 매치될 인수값 목록 several.ok: 복수 선택 여부(TRUE/FALSE) # 인수의 매치 match.arg(arg = c(&quot;med&quot;, &quot;max&quot;), choices = c(&quot;mean&quot;, &quot;median&quot;, &quot;iqr&quot;, &quot;minimum&quot;, &quot;maximum&quot;, &quot;range&quot;), several.ok = TRUE) [1] &quot;median&quot; &quot;maximum&quot; match.arg(arg = c(&quot;median&quot;, &quot;maximuum&quot;), choices = c(&quot;mean&quot;, &quot;med&quot;, &quot;iqr&quot;, &quot;minimum&quot;, &quot;max&quot;, &quot;range&quot;), several.ok = TRUE) # 오류 why?? Error in match.arg(arg = c(&quot;median&quot;, &quot;maximuum&quot;), choices = c(&quot;mean&quot;, : &#39;arg&#39;은 반드시 &quot;mean&quot;, &quot;med&quot;, &quot;iqr&quot;, &quot;minimum&quot;, &quot;max&quot;, &quot;range&quot; 중 하나이어야 합니다 match.arg(arg = c(&quot;med&quot;, &quot;max&quot;), choices = c(&quot;mean&quot;, &quot;median&quot;, &quot;iqr&quot;, &quot;minimum&quot;, &quot;maximum&quot;, &quot;range&quot;), several.ok = FALSE) Error in match.arg(arg = c(&quot;med&quot;, &quot;max&quot;), choices = c(&quot;mean&quot;, &quot;median&quot;, : &#39;arg&#39;는 반드시 길이가 1이어야 합니다 # match.arg() 함수 응용 # 중심값 관련 통계량 계산 함수 # 평균(mean), 절삭평균(trimmed mean), 중앙값(median), 최빈수(mode) 계산 # pkg_list &lt;- rownames(installed.packages()) # 설치된 패키지 목록 # if (!(&quot;DescTools&quot; %in% pkg_list)) # install.packages(&quot;DescTools&quot;) # 최빈수를 구하기 위한 패키지 설치 center &lt;- function(x, type = c(&quot;mean&quot;, &quot;trimmed&quot;, &quot;median&quot;, &quot;mode&quot;), ... ) { # browser() trim = 0; na.rm = FALSE # dot 인수 초기값 type &lt;- match.arg(type) dots &lt;- list(...) for (arg in names(dots)) { if (arg == &quot;trim&quot;) trim &lt;- as.numeric(dots[arg]) if (arg == &quot;na.rm&quot;) na.rm &lt;- as.logical(dots[arg]) } switch(type, mean = mean(x, na.rm = na.rm), trimmed = mean(x, trim = trim, na.rm = na.rm), median = median(x, na.rm = na.rm), mode = DescTools::Mode(round(x, 1), na.rm = na.rm) # DescTools 패키지 내 Mode 함수를 # workspace에 불러오지 않고 사용 ) } set.seed(100) x &lt;- rchisq(100, df = 3) # 자유도가 3인 카이제곱분포에서 난수 추출 xna &lt;- x; xna[na_idx] &lt;- NA center(x, &quot;mean&quot;); center(x, &quot;me&quot;) [1] 2.929673 Error in match.arg(type): &#39;arg&#39;은 반드시 &quot;mean&quot;, &quot;trimmed&quot;, &quot;median&quot;, &quot;mode&quot; 중 하나이어야 합니다 [1] 2.929673 center(x, &quot;trimmed&quot;, trim = 0.1) [1] 2.565866 center(x, &quot;median&quot;) [1] 2.45614 center(x, &quot;mode&quot;) [1] 1.7 attr(,&quot;freq&quot;) [1] 6 center(xna, &quot;median&quot;) [1] NA center(xna, &quot;median&quot;, na.rm = TRUE) [1] 2.423723 switch() 함수는 ifelse() 함수의 확장 버전으로 \\(n\\) 개의 조건에 대한 분기 가능 함수 제어 관련 주요 함수 return(): 계산된 결과를 반환하는 함수로 함수의 흐름에서 return()이 나타나면 결과값을 반환하고 함수 종료 강제 종료가 필요한 경우 응용 가능 # (1) 객체 반환 set.seed(100) x &lt;- rnorm(100, mean = 24, sd = 2.2) value_return1 &lt;- function(x) { tot &lt;- sum(x) n &lt;- length(x) result &lt;- list(size = n, total = tot, average = mean(x), stdev = sd(x)) return(result) } value_return_exp(x) Error in value_return_exp(x): 함수 &quot;value_return_exp&quot;를 찾을 수 없습니다 desc &lt;- value_return_exp(x) Error in value_return_exp(x): 함수 &quot;value_return_exp&quot;를 찾을 수 없습니다 desc$stdev Error in desc$stdev: 객체의 타입 &#39;closure&#39;는 부분대입할 수 없습니다 value_return2 &lt;- function(x) { return(sum(x)/length(x)) } value_return2(x) [1] 24.00641 # (2) 강제 종료 시 활용 value_return3 &lt;- function(x) { if (anyNA(x)) return return(sum(x)/length(x)) } xna &lt;- x; xna[na_idx] &lt;- NA value_return3(xna) [1] NA value_return3(x) [1] 24.00641 stop(): 예외처리 함수의 일종으로 특정 조건일 경우 (오류) 메세지를 출력하고 함수 종료 인수로 문자열을 가짐 # (1) stop() 함수 사용 # 복소수 값을 실수와 허수로 분할 split_complex &lt;- function(z) { if(!is.complex(z)) stop(&quot;입력값이 복소수가 아닙니다&quot;) re &lt;- Re(z) im &lt;- Im(z) return(list(real = re, imaginary = im)) } split_complex(pi) Error in split_complex(pi): 입력값이 복소수가 아닙니다 split_complex(23 + 7i) $real [1] 23 $imaginary [1] 7 2.5.4 함수의 적용 범위(scoping rule) Scoping rule: 변수 또는 객체가 어디에서 사용 가능한지를 결정하는 규칙 매개변수(parameter): 함수를 적용할 때 사용되는 변수로 인수로부터 발생함 함수의 인수 리스트에서 인수값이 매개변수로 할당 지역변수(local variable): 함수의 몸체 부분에서 정의된 변수들을 지칭하며 함수의 종료와 동시에 재사용 불가 전역변수(global variable): 함수의 외부(workspace)에서 정의된 변수로 함수 내부에서 값을 할당하지 않더라도 사용 가능 # (1) 매개변수, 지역변수, 전역변수 구분 x &lt;- 10 # 전역변수 y &lt;- 5 # 전역변수 scope1 &lt;- function(x) { y &lt;- x^2 print(x) # 매개변수 print(y) # 지역변수 } x; y # 전역변수가 출력 [1] 10 [1] 5 scope1(x = 10) [1] 10 [1] 100 작업공간에서 x와 y는 각각 10, 5 값이 할당 작업공간 상에서 x y 값은 변하지 않음 지역변수 y의 사용 범위는 함수 몸체이기 때문에 함수 밖에 있는 y는 값이 변하지 않음 x &lt;- 10 # 전역변수 y &lt;- 5 # 전역변수 rm(z) scope2 &lt;- function(x) { y &lt;- x^2 print(x) # 매개변수 print(y) # 지역변수 print(z) } scope2(x = 5) [1] 5 [1] 25 Error in print(z): 객체 &#39;z&#39;를 찾을 수 없습니다 z &lt;- 13 # 전역변수로 z 할당 scope2(x = 5) [1] 5 [1] 25 [1] 13 함수 외부와 내부 모두에서 z가 정의되지 않았기 때문에 에러 출력 작업공간 상에 z를 정의한 경우 함수 내부에서 workspace에서 정의한 z를 그대로 사용 \\(\\rightarrow\\) 함수 외부와 내부 자유로이 사용 가능한 변수를 자유변수(free variable)이라고 지칭함. 지역변수의 사용 범위는 함수 몸체 안이지만 그 범위를 밖으로 확장할 수 있음 \\(\\rightarrow\\) &lt;&lt;- 또는 -&gt;&gt; 사용 # 지경변수의 확장 예제 x &lt;- 1; y &lt;- 2; z &lt;- 3; k &lt;- 10 scope3 &lt;- function(x) { y &lt;&lt;- x + 10 y * 3 -&gt;&gt; z print(x) # 매개변수 print(y) # 지역변수 print(z) # 지역변수 print(k) # 자유변수 } x;y;z;k [1] 1 [1] 2 [1] 3 [1] 10 scope3(x = 2) [1] 2 [1] 12 [1] 36 [1] 10 x;y;z;k [1] 1 [1] 12 [1] 36 [1] 10 하나의 함수 내부에 또 다른 함수 생성 가능 mean_manual2 &lt;- function(x) { tot &lt;- sum(x) size &lt;- function(x) { return(length(x)) } return(tot/size(x)) } mean_manual2(1:10) [1] 5.5 2.5.5 재귀 호출 함수(recursive call function) 함수 자신을 다시 호출하는 함수로 직관적으로 이해하기 쉽고 간결함 재귀함수 작성 시 재귀호출을 탈출하는 조건을 명확히 하는 것이 관건 예제1: 계승(factorial) 계산하기 \\[ n! = \\begin{cases} n \\times (n - 1)!, &amp; n=1, \\cdots \\\\ 1, &amp; n = 0 \\end{cases} \\] \\(f(n) = n!\\) 이라고 하면 \\(f(n)\\)은 아래와 같이 나타낼 수 있음. \\[ n! = \\begin{cases} n \\times f(n-1), &amp; n=1, \\cdots \\\\ 1, &amp; n = 0 \\end{cases} \\] 위 식을 이용해 \\(3!\\)을 구하는 과정: - \\(f(3) = 3\\times f(2) = 3\\times 2 \\times f(1) = 3 \\times 2\\times 1\\times f(0) = 3\\times 2\\times 1\\times 1\\times = 6\\) f(3) = 3*f(2) f(2) = 2 * f(1) f(1) = 1 위 과정을 함수로 구현 factorial_manual &lt;- function(n) { if (n == 0) return(1) return(n * factorial_manual(n-1)) } # test factorial_manual(3) [1] 6 factorial_manual(10) [1] 3628800 # R 내장함수로 검증 factorial(10) [1] 3628800 예제: 하노이 탑(tower of Hanoi) “인도 베나레스에 있는 한 사원에는 세상의 중심을 나타내는 큰 돔이 있고 그 안에 세 개의 다이아몬드 바늘이 동판 위에 세워져 있습니다. 바늘의 높이는 1 큐빗이고 굵기는 벌의 몸통만 합니다. 바늘 가운데 하나에는 신이 64개의 순금 원판을 끼워 놓았습니다. 가장 큰 원판이 바닥에 놓여 있고, 나머지 원판들이 점점 작아지며 꼭대기까지 쌓아 있습니다. 이것은 신성한 브라흐마의 탑입니다. 브라흐마의 지시에 따라 승려들은 모든 원판을 다른 바늘로 옮기기 위해 밤낮 없이 차례로 제단에 올라 규칙에 따라 원판을 하나씩 옮깁니다. 이 일이 끝날 때, 탑은 무너지고 세상은 종말을 맞이하게 됩니다.” [Wikipedia] 문제: 3개의 기둥 A, B, C가 있고, 기둥 A에 \\(N\\) 개의 원판이 크기 순서대로 쌓여져 있을 때(제일 밑에 원판이 가장 큼), 모든 원판을 기둥 C로 옮기기 조건 한 번에 하나의 원판만 옮길 수 있음 큰 원판이 작은 원판 위에 있으면 안됨 Figure 2.11: 하노이 탑 문제 Solution 원판의 크기가 제일 작은 것 부터 큰 것 까지 각각 1, 2, 3 번을 부여 했을 때 1 번 원판을 봉 A에서 C로 옮김 (A \\(\\rightarrow\\) C) 2 번 원판을 봉 A에서 B로 옮김 (A \\(\\rightarrow\\) B) 1 번 원판을 봉 C에서 B로 옮김 (C \\(\\rightarrow\\) B) 3 번 원판을 봉 A에서 C로 옮김 (A \\(\\rightarrow\\) C) 1 번 원판을 봉 B에서 A로 옮김 (B \\(\\rightarrow\\) A) 2 번 원판을 봉 B에서 C로 옮김 (B \\(\\rightarrow\\) C) 1 번 원판을 봉 A에서 C로 옮김 (A \\(\\rightarrow\\) C) 원판이 3개인 경우 총 7번의 이동이 필요 \\(\\rightarrow\\) \\(n\\)개의 원판이 있을 경우 \\(2^n - 1\\) 번의 이동이 필요 Figure 2.12: 하노이 탑 문제 알고리즘 구현 move &lt;- function(n, from, to) print(sprintf(&quot;%d 번 원판을 %s 에서 %s 로 이동&quot;, n, from, to)) move_hanoi &lt;- function(n, from, to, via) { if (n == 1) { move(1, from, to) } else { move_hanoi(n - 1, from, via, to) move(n, from, to) move_hanoi(n - 1, via, to, from) } } move_hanoi(3, &quot;A&quot;, &quot;C&quot;, &quot;B&quot;) [1] &quot;1 번 원판을 A 에서 C 로 이동&quot; [1] &quot;2 번 원판을 A 에서 B 로 이동&quot; [1] &quot;1 번 원판을 C 에서 B 로 이동&quot; [1] &quot;3 번 원판을 A 에서 C 로 이동&quot; [1] &quot;1 번 원판을 B 에서 A 로 이동&quot; [1] &quot;2 번 원판을 B 에서 C 로 이동&quot; [1] &quot;1 번 원판을 A 에서 C 로 이동&quot; move_hanoi(4, &quot;A&quot;, &quot;C&quot;, &quot;B&quot;) [1] &quot;1 번 원판을 A 에서 B 로 이동&quot; [1] &quot;2 번 원판을 A 에서 C 로 이동&quot; [1] &quot;1 번 원판을 B 에서 C 로 이동&quot; [1] &quot;3 번 원판을 A 에서 B 로 이동&quot; [1] &quot;1 번 원판을 C 에서 A 로 이동&quot; [1] &quot;2 번 원판을 C 에서 B 로 이동&quot; [1] &quot;1 번 원판을 A 에서 B 로 이동&quot; [1] &quot;4 번 원판을 A 에서 C 로 이동&quot; [1] &quot;1 번 원판을 B 에서 C 로 이동&quot; [1] &quot;2 번 원판을 B 에서 A 로 이동&quot; [1] &quot;1 번 원판을 C 에서 A 로 이동&quot; [1] &quot;3 번 원판을 B 에서 C 로 이동&quot; [1] &quot;1 번 원판을 A 에서 B 로 이동&quot; [1] &quot;2 번 원판을 A 에서 C 로 이동&quot; [1] &quot;1 번 원판을 B 에서 C 로 이동&quot; 숙제2: 하노이 탑 문제의 어느 부분을 재귀함수로 나타낼 수 있는지를 명확히 기술하고, 위 함수의 실행 원리를 설명 또는 도식화 하시오. 제출일: 2020년 11월 6일 금요일 23:59분 까지 제출방법: R markdown으로 작성한 문서와 Rmd 파일을 ’학번-이름.zip’으로 압축 후 제출 "]
]
