[
["index.html", "통계 패키지 활용 2020년도 2학기 충남대학교 정보통계학과 강의 노트 Course Overview", " 통계 패키지 활용 2020년도 2학기 충남대학교 정보통계학과 강의 노트 한국한의학연구원, 구본초 2020-10-30 Course Overview R을 이용한 데이터 분석 시 CRAN에 등록된 패키지를 활용한다. 적절한 패키지의 활용은 데이터 분석의 효율을 증대할 뿐 아니라 분석의 재현성을 향상할 수 있다. 본 강의는 지난학기에 학습한 통계프로그래밍언어 강의 내용의 연속선 상에서 진행할 예정이며, 해당 강의에서 학습한 내용들을 기반으로 데이터 분석 및 그 결과에 대한 보고서 작성, 그리고 R 생성 파일에 대한 버전 관리 방법에 대해 알아보고자 한다. 교과 목표 R Markdown의 이해와 활용 R 프로그래밍 능력 향상 및 통계 시뮬레이션의 이해 R을 이용한 데이터 분석 실습 R을 이용한 기초 통계분석 텍스트 마이닝에 대한 이해 Shiny, plotly 를 활용한 동적 문서 및 시각화 이해 RStudio + Github을 이용한 버전관리 이해 선수과목 통계학 개론 통계 프로그래밍 언어 수업 방법 강의: 30 % 실험/실습: 70 % 평가방법 중간고사: 35 % 기말고사: 35 % 출석: 10 % 과제: 20 % 교재 별도의 교재 없이 본 강의 노트로 수업을 진행할 예정이며, 수업의 이해도 향상을 위해 아래 소개할 도서 및 웹 문서 등을 참고할 것을 권장함. 참고문헌 R Markdown Cookbook (Xie, Dervieux, and Riederer 2020) bookdown: Authoring Books and Technical Documents with R Markdown (Xie 2016) R과 knitr를 활용한 데이터 연동형 문서 만들기 (고석범 2014) R for data science (Wickham and Grolemund 2016) Statistical Computing with R (Rizzo 2019) R programming for data science (Peng 2016) Text mining with R (Silge and Robinson 2017) References "],
["r-markdown.html", "1 R Markdown", " 1 R Markdown Sketch 동일한 문서에 코드, 결과, 텍스트가 동시에 있을 수 있을까? 만약 결과와 도표가 자동으로 생성된 경우 데이터가 변경 되더라도 자동으로 문서를 업데이트 할 수 있을까? 최종 완료한 문서가 미래에도 열 수 있을까? 이러한 모든 과정이 매우 쉽다면?? Figure 1.1: R markdown 세계(https://ulyngs.github.io/rmarkdown-workshop-2019 에서 발췌) "],
["r-markdown의-구성.html", "1.1 R Markdown의 구성", " 1.1 R Markdown의 구성 본 절의 내용 중 일부는 지난 학기 강의노트 1.7절과 중복되거나 재구성한 내용이 포함됨. R Markdown은 R 코드와 분석 결과(표, 그림 등)을 포함한 문서 또는 컨텐츠를 제작하는 도구로 일반적으로 아래 열거한 형태로 활용함 문서 또는 논문(pdf, html, docx) 프리젠테이션(pdf, html, pptx) 웹 또는 블로그 재현가능(reproducible)한 분석 및 연구1 가능 신뢰성 있는 문서 작성 Copy &amp; paste를 하지 않고 효율적 작업 가능 R 마크다운 파일 = .Rmd 확장자를 가진 일반 텍스트 파일 --- title: &quot;Untitled.Rmd&quot; date: &quot;2020-09-11&quot; output: html_document --- ```{r setup, include=FALSE} knitr::opts_chunk$set(echo = TRUE) ``` ## R Markdown Markdown은 HTML, PDF 및 MS Word 문서를 작성하 기위한 간단한 형식 지정 구문입니다. R Markdown 사용에 대한 자세한 내용은 &lt;http://rmarkdown.rstudio.com&gt;을 참조하십시오. **Knit** 버튼을 클릭하면 두 가지를 모두 포함하는 문서가 생성됩니다. 문서에 포함 된 R 코드 청크의 출력 내용뿐 아니라 다음과 같이 R 코드 청크를 포함 할 수 있습니다. ```{r cars} summary(cars) ``` ## Including Plots You can also embed plots, for example: ```{r pressure, echo=FALSE} plot(pressure) ``` `echo = FALSE` 매개 변수가 코드 청크에 추가되었습니다. 플롯을 생성 한 R 코드의 인쇄를 방지합니다. 위 R Markdown 문서는 아래 그림과 같이 YAML, Markdown 텍스트, Code Chunk 세 부분으로 구성됨. Figure 1.2: R markdown structure YAML (YAML Ain’t Markup Language) R Markdown 문서의 metadata로 문서의 맨 처음에 항상 포함(header)되어야 함. R Markdown 문서의 최종 출력 형태(html, pdf, docx, pptx 등), 제목, 저자, 날짜 등의 정보 등을 포함 최종 문서 생성 과정 Rmd 파일을 knitr 을 통해 .md 파일로 변환 후 pandoc 이라는 문서 변환기를 통해 원하는 문서 포맷으로 출력 Figure 1.3: R Markdown의 최종 결과물 산출과정(http://applied-r.com/project-reporting-template/) 과학적 연구의 결과물을 오픈소스로 내놓고 누구라도 검증 가능↩︎ "],
["r-markdown-문서-시작하기.html", "1.2 R Markdown 문서 시작하기", " 1.2 R Markdown 문서 시작하기 R Markdown 문서 생성: [File] -&gt; [New File] -&gt; [R Markdown..]을 선택 RStudio를 처음 설치하고 위와 같이 진행할 경우 아래와 같은 패키지 설치 여부를 묻는 팝업 창이 나타남. 패키지 설치 여부에 [Yes]를 클릭하면 R Markdown 문서 생성을 위해 필요한 패키지들이 자동으로 설치 설치 완료 후 R Markdown으로 생성할 최종 문서 유형 선택 질의 창이 나타남. 아래 창에서 제목(Title)과 저자(Author) 이름 입력 후 [OK] 버튼 클릭(Document, html 문서 선택) 아래 그림과 같이 새로운 문서 창이 생성되고 test.Rmd 파일로 저장2 문서 상단에 Knit 아이콘을 클릭 후 Knit to HTML 클릭 또는 문서 아무 곳에 커서를 위치하고 단축키 [Ctrl] + [Shift] + [K] 입력 knitr + R Markdown + pandoc \\(\\rightarrow\\) html 파일 생성 결과 Figure 1.4: test.html 문서 화면(저장 폴더 내 test.html을 크롬 브라우저로 실행) [RStudio 프로젝트]에서 생성한 폴더 내에 파일 저장↩︎ "],
["r-markdown-기본-문법syntax.html", "1.3 R Markdown 기본 문법(syntax)", " 1.3 R Markdown 기본 문법(syntax) R Markdown의 기본 문법은 Rstudio 풀다운 메뉴 [Help] \\(\\rightarrow\\) [Markdown Quick Reference] 에서 확인 가능 1.3.1 텍스트 문법 강조(emphasis) 이텔릭체: *italic1*, _italic2_ \\(\\rightarrow\\) italic1, italic2 볼드(굵은)체: *bold1*, __bold2__ \\(\\rightarrow\\) bold1, bold2 Inline code `inline code` \\(\\rightarrow\\) inline code 아래/위 첨자(sub/superscript) subscript~2~ \\(\\rightarrow\\) subscript2 superscript^2^ \\(\\rightarrow\\) superscript2 삭제표시(strike through) ~~strikethrough~~ \\(\\rightarrow\\) strikethrough 생략표시(ellipsis) ... \\(\\rightarrow\\) … 긴/짧은 대쉬(en/emd-dash) 짧은 대쉬: -- \\(\\rightarrow\\) – 긴 대쉬: --- \\(\\rightarrow\\) — 특수문자 탈출 지정자 \\*, \\_, \\~, \\\\ \\(\\rightarrow\\) *, _, ~, \\ 하이퍼링크 -[text](link) \\(\\rightarrow\\) 통계프로그래밍언어 외부그림 삽입 ![image title](path/to/image): ![장난꾸러기](figures/son-02.jpg) 장난꾸러기 강제 줄바꿈(line breaks) 하나의 줄에서 공백(space) 두 개 이상 또는 백슬레시(\\) 입력 후 [Enter] End a line with two spaces to start a new paragraph End a line with two spaces to start a new paragraph End a line with two spaces to start\\ a new paragraph End a line with two spaces to start a new paragraph 각주(footnote) A footnote^[주석내용] \\(\\rightarrow\\) A footnote3 주석(comment) &lt;!-- this is a comment that won't be shown --&gt; \\(\\rightarrow\\) RStudio에서 단축키 [Ctrl] + [Shift] + [C]를 통해 전체 line 에 대해 주석처리 가능 1.3.2 Block-level elements 장/절(header) # Header 1 (chapter, 장) ## Header 2 (section, 절) ### Header 3 (subsection, 관) 목록(list) 비순서(unordered) 목록: -, *, + 중 어느 하나로 입력 가능 - one item * two item + sub-item 1 + sub-item 2 - subsub-item 1 - subsub-item 2 one item two item sub-item 1 sub-item 2 subsub-item 1 subsub-item 2 순서(ordered) 목록: 비순서 목록의 기호 대신 숫자로 리스트 생성 1. the first item - sub-item 1 2. the second item 3. the third item the first item sub-item 1 the second item the third item 같은 숫자로 적어도 순서대로 목록 생성 1. the first item - sub-item 1 1. the second item 1. the third item the first item sub-item 1 the second item the third item 인용구(blockquote): &gt;로 시작 &gt; &quot;There are three kinds of lies: lies, damn lies, and statistics&quot; &gt; &gt; --- Benjamin Disraeli “There are three kinds of lies: lies, damn lies, and statistics” — Benjamin Disraeli 1.3.3 수식표현(math expression) 줄 안에 수식 입력 시 $수식표현$ 으로 입력 수식 display style (보통 교과서에 정리 및 정의에 기술된 수식들) 적용 시 $$ ~ $$ 안에 수식 입력 수식 표현은 LaTeX 의 수식 표현을 동일하게 준용(https://www.latex4technics.com/, https://latex.codecogs.com/legacy/eqneditor/editor.php 에서 수식 입력 명령어 학습 가능) LaTeX 수식 입력 코드는 예시 \\[ P(X = x) = f(x; n, p) = {n \\choose x} p^x (1-p)^{n-x} \\] Inline equation: $P(X = x) = f(x; n, p) = {n \\choose x} p^x (1-p)^{n-x}$ \\(\\rightarrow\\) \\(P(X = x) = f(x; n, p) = {n \\choose x} p^x (1-p)^{n-x}\\) Math block: $$P(X = x) = f(x; n, p) = {n \\choose x} p^x (1-p)^{n-x}$$ \\[P(X = x) = f(x; n, p) = {n \\choose x} p^x (1-p)^{n-x}\\] $ $ 또는 $$ $$ 안에 LaTeX에서 제공하는 수식 함수 사용 가능 $$\\begin{array}{ccc} x_{11} &amp; x_{12} &amp; x_{13}\\\\ x_{21} &amp; x_{22} &amp; x_{23} \\end{array}$$ \\[\\begin{array}{ccc} x_{11} &amp; x_{12} &amp; x_{13}\\\\ x_{21} &amp; x_{22} &amp; x_{23} \\end{array}\\] $$\\Theta = \\begin{pmatrix}\\alpha &amp; \\beta\\\\ \\gamma &amp; \\delta \\end{pmatrix}$$ \\[\\Theta = \\begin{pmatrix}\\alpha &amp; \\beta\\\\ \\gamma &amp; \\delta \\end{pmatrix}\\] $$\\begin{align} g(X_{n}) &amp;= g(\\theta)+g&#39;({\\tilde{\\theta}})(X_{n}-\\theta) \\notag \\\\ \\sqrt{n}[g(X_{n})-g(\\theta)] &amp;= g&#39;\\left({\\tilde{\\theta}}\\right) \\sqrt{n}[X_{n}-\\theta ] \\end{align}$$ \\[\\begin{aligned} g(X_{n}) &amp;= g(\\theta)+g&#39;({\\tilde{\\theta}})(X_{n}-\\theta) \\notag \\\\ \\sqrt{n}[g(X_{n})-g(\\theta)] &amp;= g&#39;\\left({\\tilde{\\theta}}\\right) \\sqrt{n}[X_{n}-\\theta ] \\end{aligned}\\] 주석내용↩︎ "],
["r-code-chunks.html", "1.4 R Code Chunks", " 1.4 R Code Chunks 실제 R code가 실행되는 부분임 Code chunk 실행 시 다양한 옵션 존재(본 강의에서는 몇 개의 옵션만 다룰 것이며, 더 자세한 내용은 https://yihui.org/knitr/options/ 또는 R Markdown 레퍼런스 가이드 참조 Code chunk는 ```{r}로 시작되며 r은 code 언어 이름을 나타냄. Code chunk는 ``` 로 종료 R Markdown 문서 작성 시 단축키 [Ctrl] + [Alt] + [I]를 입력하면 Chunk 입력창이 자동 생성됨 Code chunk의 옵션 조정을 통해 코드의 출력여부, 코드 출력 시 코드의 출력 형태, 코드의 결과물 출력 조정 가능 Figure 1.5: Chunk anatomy (https://ulyngs.github.io/rmarkdown-workshop-2019 에서 발췌) 자주 활용하는 chunk 옵션 코드 실행 관련 청크 Table 1.1: 코드 실행 관련 청크 Chunk 옵션 Default 설명 eval TRUE R 실행(코드 실행 결과)에 대응하는 결과 출력 여부 include TRUE 출력 문서에 코드 청크의 내용을 포함할지 여부 ```{r ex01-1, eval=TRUE} summary(iris) hist(iris$Sepal.Length) ``` ```{r ex01-2, eval=FALSE} summary(iris) hist(iris$Sepal.Length) ``` #청크 옵션 eval=TRUE summary(iris) Sepal.Length Sepal.Width Petal.Length Petal.Width Min. :4.300 Min. :2.000 Min. :1.000 Min. :0.100 1st Qu.:5.100 1st Qu.:2.800 1st Qu.:1.600 1st Qu.:0.300 Median :5.800 Median :3.000 Median :4.350 Median :1.300 Mean :5.843 Mean :3.057 Mean :3.758 Mean :1.199 3rd Qu.:6.400 3rd Qu.:3.300 3rd Qu.:5.100 3rd Qu.:1.800 Max. :7.900 Max. :4.400 Max. :6.900 Max. :2.500 Species setosa :50 versicolor:50 virginica :50 hist(iris$Sepal.Length) #청크 옵션 eval=FALSE summary(iris) hist(iris$Sepal.Length) 소스 코드 출력(텍스트) 결과 관련 청크 Table 1.2: 소스 코드 출력 결과 관련 청크 Chunk 옵션 Default 설명 echo TRUE R 실행 결과에 대응하는 코드 출력 여부 results markup 출력 결과 포맷 지정을 위한 옵션으로 추가적으로 3 가지 옵션 선택 가능: ‘hide’, ‘asis’, ‘hold’, ‘markup’ error TRUE 코드 또는 스크립트에 구문오류 메세지 출력 여부 message TRUE 코드로부터 생성된 메세지 출력 여부 warning TRUE 경고 메세지 출력 여부 echo: 코드 청크에 작성한 R-script 출력 여부 결정 echo = FALSE 이면 소스 코드 출력 없이 그림 결과만 출력 ```{r ex01-2, echo=TRUE} require(ggthemes) # ggtheme 패키지 불러오기 require(ggpubr) # ggpubr 패키지 불러오기 iris %&gt;% ggplot(aes(x = Sepal.Length, y = Petal.Width, color = Species)) + geom_point(size = 5) + theme_pubclean() + theme(axis.line = element_line(size = 0.8), legend.title = element_text(face = &quot;bold&quot;, size = 15), legend.text = element_text(face = &quot;bold&quot;, size = 12)) ``` ```{r ex01-3, echo=FALSE} require(ggthemes) # ggtheme 패키지 불러오기 require(ggpubr) # ggpubr 패키지 불러오기 iris %&gt;% ggplot(aes(x = Sepal.Length, y = Petal.Width, color = Species)) + geom_point(size = 5) + theme_pubclean() + theme(axis.line = element_line(size = 0.8), legend.title = element_text(face = &quot;bold&quot;, size = 15), legend.text = element_text(face = &quot;bold&quot;, size = 12)) ``` # echo = TRUE require(ggthemes) # ggtheme 패키지 불러오기 require(ggpubr) # ggpubr 패키지 불러오기 iris %&gt;% ggplot(aes(x = Sepal.Length, y = Petal.Width, color = Species)) + geom_point(size = 5) + theme_pubclean() + theme(axis.line = element_line(size = 0.8), legend.title = element_text(face = &quot;bold&quot;, size = 15), legend.text = element_text(face = &quot;bold&quot;, size = 12)) results: 코드의 텍스트 출력 결과 포맷 지정 markup (default): 코드 청크 내 스크립트의 출력 형태에 따라 텍스트 출력 결과를 mark-up asis: 변환하지 않은 원래 R 출력 결과 그대로(as is) 출력 hide: R 스크립트로 생성된 텍스트 출력을 보여주지 않음(warning, message 출력 예외) hold: 코드 청크로 생성된 모든 소스 및 출력을 단일 블록으로 축소 # results = &#39;markup&#39;인 경우 아래 텍스트를 mark-up # (이 경우 아래 텍스트는 ``` ``` 블럭 처리)한 결과를 md 파일로 전송 cat(&quot;I&#39;m raw **Markdown** content.\\n&quot;) I&#39;m raw **Markdown** content. Figure 1.6: 청크 옵션 results = ’markup’인 경우 rmd vs. md 파일 비교 # results = &#39;asis&#39; 인 경우 텍스트를 그대로 md 파일에 입력 cat(&quot;I&#39;m raw **Markdown** content.\\n&quot;) I’m raw Markdown content. Figure 1.7: 청크 옵션 results = ’asis’인 경우 rmd vs. md 파일 비교 # results = &#39;hide&#39; cat(&quot;I&#39;m raw **Markdown** content.\\n&quot;) # 텍스트 결과를 출력하지 않음 # results = &#39;hold&#39;가 아닌 경우 한 라인 별 출력 결과 생성 x &lt;- rnorm(10) x [1] -0.3511108325 -0.0002684261 -0.1753683371 -0.6228810481 0.0013627284 [6] -0.0280161327 -0.7798342738 -1.8466630468 0.0177557431 -0.9458054823 y &lt;- rnorm(10, 1, 2) y [1] 1.56812522 1.90365735 3.60437081 2.18261516 -0.23593182 3.59878093 [7] 0.05533190 -1.63399924 -0.38308245 0.08814993 x + y [1] 1.2170144 1.9033889 3.4290025 1.5597341 -0.2345691 3.5707648 [7] -0.7245024 -3.4806623 -0.3653267 -0.8576556 # results = &#39;hold&#39;인 경우 코드 부분과 출력 부분이 따로 블록 처리 x &lt;- rnorm(10) x y &lt;- rnorm(10, 1, 2) y x + y [1] -0.17693369 1.16262229 -0.16107736 0.29189649 1.16534931 -0.57698724 [7] -1.51149702 1.00427570 -0.92551577 0.07122251 [1] 2.031579686 1.085656789 1.224249692 5.110128692 0.002955198 [6] 1.082779369 0.303931455 0.949308000 -6.028318318 -4.280061183 [1] 1.8546460 2.2482791 1.0631723 5.4020252 1.1683045 0.5057921 [7] -1.2075656 1.9535837 -6.9538341 -4.2088387 error: 코드 청크 내 스크립트에 오류에 대한 보존 여부(stop()) 기본적으로 Rmarkdown 컴파일 시 error에 대한 옵션이 FALSE이기 때문에 스크립트(코드)에 오류가 포함되면 컴파일이 정지됨. error = TRUE 이면 오류 메세지를 포함한 텍스트 결과를 출력 3x &lt;- 3 x &lt;- 25 # 위 행이 구문 오류를 포함하고 있기 때문에 # 오류 이후의 코드는 실행되지 않음 x Error: &lt;text&gt;:1:2: 예상하지 못한 기호(symbol)입니다. 1: 3x ^ message/warning: 텍스트 출력물 중 경고(warning, warning() 함수의 출력 결과) 메세지 출력 여부 결정 # message = TRUE 인 경우 함수 message 출력 testit &lt;- function() { message(&quot;testing package startup messages&quot;) packageStartupMessage(&quot;initializing ...&quot;, appendLF = FALSE) Sys.sleep(1) packageStartupMessage(&quot; done&quot;) } # help(message) 예시 중 발췌 testit() testing package startup messages initializing ... done # message=FALSE -&gt; 메세지 출력하지 않음 testit() # 경고 메세지 출력 x &lt;- c(1, 2, &quot;new&quot;, 4:10) x &lt;- as.numeric(x) Warning: 강제형변환에 의해 생성된 NA 입니다 코드 서식 관련 청크 옵션 Table 1.3: 코드 서식 관련 청크 Chunk 옵션 Default 설명 comment TRUE 소스 코드 실행 출력의 각 줄 앞에 붙는 표시문자 출력 여부: 기본 값은 ‘##’ 임 highlight TRUE 구문 강조 여부 prompt FALSE R 프롬프트 출력 여부 tidy FALSE R 소스 코드 출력 정리 여부 comment: 텍스트 출력물에 주석 표시(default)를 함으로써 소스 코드와 출력 결과를 동시 선택과 복사를 가능(##는 주석 표시이기 때문에 실행되지 않음) 주석 표시를 제거하고 싶다면 comment = NA 또는 comment = '' # 디폴트 comment 사용 summary(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## Min. :4.300 Min. :2.000 Min. :1.000 Min. :0.100 ## 1st Qu.:5.100 1st Qu.:2.800 1st Qu.:1.600 1st Qu.:0.300 ## Median :5.800 Median :3.000 Median :4.350 Median :1.300 ## Mean :5.843 Mean :3.057 Mean :3.758 Mean :1.199 ## 3rd Qu.:6.400 3rd Qu.:3.300 3rd Qu.:5.100 3rd Qu.:1.800 ## Max. :7.900 Max. :4.400 Max. :6.900 Max. :2.500 ## Species ## setosa :50 ## versicolor:50 ## virginica :50 ## ## ## highlight: 구문 강조 표시 여부 highlight=FALSE 일 때 소스 코드 출력 결과 # highlight=FALSE iris %&gt;% ggplot(aes(x = Sepal.Length, y = Petal.Width, color = Species)) + geom_point(size = 5) + theme_pubclean() + theme(axis.line = element_line(size = 0.8), legend.title = element_text(face = &quot;bold&quot;, size = 15), legend.text = element_text(face = &quot;bold&quot;, size = 12)) prompt: R 콘솔 상 프롬프트 &gt;, + 출력 여부 &gt; # prompt = TRUE 인 경우 코드 출력 결과 &gt; require(ggthemes) # ggtheme 패키지 불러오기 &gt; require(ggpubr) # ggpubr 패키지 불러오기 &gt; iris %&gt;% + ggplot(aes(x = Sepal.Length, y = Petal.Width, color = Species)) + + geom_point(size = 5) + + theme_pubclean() + + theme(axis.line = element_line(size = 0.8), + legend.title = element_text(face = &quot;bold&quot;, size = 15), + legend.text = element_text(face = &quot;bold&quot;, size = 12)) tidy: 코드를 사용자가 지정(혹은 formatR::tidy_sorce() 함수에 초기값으로 지정된 코드 정리 값)한 줄 당 문자 길이 등을 반영해 코드를 정리 tidy=TRUE 인 경우 자동으로 줄 바꿈 &gt; # tidy = FALSE 인 경우 코드 출력 결과 &gt; require(ggthemes) # ggtheme 패키지 불러오기 &gt; require(ggpubr) # ggpubr 패키지 불러오기 &gt; iris %&gt;% ggplot(aes(x = Sepal.Length, y = Petal.Width, color = Species)) + geom_point(size = 5) + theme_pubclean() + theme(axis.line = element_line(size = 0.8), legend.title = element_text(face = &quot;bold&quot;, size = 15), legend.text = element_text(face = &quot;bold&quot;, size = 12)) &gt; # tidy = TRUE 인 경우 코드 출력 결과 &gt; require(ggthemes) # ggtheme 패키지 불러오기 &gt; require(ggpubr) # ggpubr 패키지 불러오기 &gt; iris %&gt;% ggplot(aes(x = Sepal.Length, y = Petal.Width, color = Species)) + geom_point(size = 5) + + theme_pubclean() + theme(axis.line = element_line(size = 0.8), legend.title = element_text(face = &quot;bold&quot;, + size = 15), legend.text = element_text(face = &quot;bold&quot;, size = 12)) 그림(plot) 출력 관련 청크 옵션 Table 1.4: Plot 출력 관련 청크 Chunk 옵션 Default 설명 fig.align default 최종 문서에 plot 정렬 방식 결정(center/left/right) fig.height/fig.width 7 그림 크기(단위: 인치) fig.cap NULL 그림 캡션(문자열 입력) dpi 72 dot per inche: 출력 그림 해상도 알아두면 좋은 청크 형태 Setup 청크 일반적으로 Rmarkdown 문서는 YAML 해더 뒤에 전역적 청크 옵션 지정과 R 패키지를 불러오는 것으로 시작 청크 옵션은 knitr::opts_chunk$set(청크 옵션 지정) 형태로 지정 가능 다음은 RStudio 에서 Rmd 문서 생성 시 맨 처음 나오는 코드 청크 예시임 ```{r ex01-2, include=FALSE} knitr::opts_chunk$set(echo = TRUE) ``` 일반적 활용 예시 ```{r option-init, include=FALSE} knitr::opts_chunk$set(root.dir = &#39;../..&#39;, # 프로젝트 폴더 지정 eval = TRUE, echo = FALSE, cache = FALSE, include = TRUE, tidy = TRUE, tidy.opts = list(blank=FALSE, width.cutoff=120), # 소스 출력길이 지정 message = FALSE, warning = FALSE, engine = &quot;R&quot;, # Chunks will always have R code, unless noted error = TRUE, fig.path=&quot;Figures/&quot;, # Set the figure options fig.align = &quot;center&quot;, fig.width = 7, fig.height = 7, fig.keep=&#39;all&#39;, fig.retina=2) ``` 이미지 불러오기 ```{r, fig.cap = &quot;Taj Mahal&quot;} knitr::include_graphics(&quot;figures/taj.JPG&quot;, dpi = NA) ``` Figure 1.8: Taj Mahal ```{r, fig.cap = &quot;Taj Mahal&quot;} cars %&gt;% ggplot(aes(x = speed, y = dist)) + geom_point(size = 5) + theme_tufte(base_size = 15) # ggtheme::theme_tufte() ``` R 생성 도표 포함 Figure 1.9: Scatterplot of the car dataset 테이블 삽입 가장 간단한 테이블은 knitr::kable() 함수를 통해 생성 가능 kable() 함수는 가장 단순한 형태의 표만 생성하기 때문에 복잡한 표를 만들기에는 한계가 존재함 이를 보완하기 위해 다음과 같은 패키지 활용 kableExtra: HTML 또는 LaTeX 용 표 생성 https://cran.r-project.org/web/packages/kableExtra/vignettes/awesome_table_in_html.html https://cran.r-project.org/web/packages/kableExtra/vignettes/awesome_table_in_pdf.pdf flextable + officer: HTML, 워드 문서 표 작성 https://davidgohel.github.io/flextable/ ```{r} knitr::kable(head(iris)) ``` Sepal.Length Sepal.Width Petal.Length Petal.Width Species 5.1 3.5 1.4 0.2 setosa 4.9 3.0 1.4 0.2 setosa 4.7 3.2 1.3 0.2 setosa 4.6 3.1 1.5 0.2 setosa 5.0 3.6 1.4 0.2 setosa 5.4 3.9 1.7 0.4 setosa "],
["inline-code.html", "1.5 인라인(inline) R 코드", " 1.5 인라인(inline) R 코드 문서의 모든 숫자를 인라인 R 코드를 통해 재현가능하게 생성 가능 인라인 R 코드는 `r 과 ` 사이에 변수 계산 스크립트를 입력해 작성 가능 예를 들어 `r 10 + 4` 는 14 출력 활용 예시 head(mtcars, 5) N &lt;- nrow(mtcars) mtcars 데이터셋에 포함된 자동차는 `r N ` 개다. \\(\\rightarrow\\) mtcars 데이터셋에 포함된 자동차는 32 개다. "],
["yaml.html", "1.6 YAML", " 1.6 YAML R Markdown 문서의 가장 처음에 정의하는 metadata .Rmd 파일을 .md 파일로 변환 후 최종 출력문서 생성 시 필요한 pandoc의 옵션을 설정하는 것과 같은 의미임 일반적으로 문서 형태 및 생성을 위해 사용하는 R package (예: bookdown, officedown, rticles 등)에 따라 YAML 구성요소가 달라짐 기본 문법 /#: 주석 처리 YAML 문서의 시작과 끝은 --- 로 정의함 기본적으로 콜론(:)으로 구분된 태그(키): 값 쌍으로 구성됨 \\(\\rightarrow\\) key: value 여기서 콜론 바로 다음에는 반드시 공백문자가 있어야 함 한 key의 하위 키는 리스트 형태로 표현하고, 하위 키는 두 개 이상의 스페이스로 공백을 주어 표현 --- key : value subkey1: value1 subkey2: value2 subsubkey1: value3 --- R Markdown 기본 YAML 구조 --- title: &quot;문서 제목&quot; # 일반적으로 따옴표 사용 subtitle: &quot;문서 부제목&quot; author: &quot;문서 작성자&quot; date: &quot;문서 작성일자&quot; output: - &quot;html_document&quot; - &quot;word_document&quot; - &quot;pdf_document&quot; - &quot;md_document&quot; - &quot;isoslides_presentation&quot; - &quot;slidy_presentation&quot; - &quot;beamer_presentation&quot; bibliography: 참고문헌.bib # bibtex 서식 활용 . . . --- https://bookdown.org/yihui/rmarkdown/documents.html 에 자세한 예시 참고 "],
["rmarkdown-citation.html", "1.7 참고문헌 인용", " 1.7 참고문헌 인용 참고문헌 정보가 BibTeX 포맷으로 저장된 .bib 파일을 YAML에 선언 후 인용 가능 참고문헌 표현: [@citation-identifier] 또는 @citation-identifier BibTeX 포맷은 Google Scholar 에서 쉽게 획득 가능 Citation 스타일은 YAML 헤더에 cl: style.csl로 변경 가능하며 Zotero 에서 .csl 파일 다운로드 가능 "],
["control-structure.html", "2 제어문(Control Structure)", " 2 제어문(Control Structure) Sketch 프로그램이 무엇이고 이를 만들기 위해 어떤 것들이 필요할까? 프로그램 안의 특정 구문을 주어진 조건에 맞게 실행 여부를 제어하거나 동일한 작업을 반복할 수 있을까? 프로그램을 통해 특정 목적을 위한 나만의 함수를 만들 수 있을까? Figure 2.1: Flow-control example (https://homerhanumat.github.io/r-notes/flow.html) 참고: 본 장의 내용은 데이터과학 민주화와 Beginning Computer Programming with R의 내용을 기반으로 재구성함 "],
["control-prerequisite.html", "2.1 Prerequisite", " 2.1 Prerequisite 예약어(researved words): R에서 의미(sementic)를 미리 정해 놓은 단어 통계프로그래밍언어 강의노트 참고 Table 2.1: R 예약어 종류 및 설명 R 예약어 설명 if, else, while, function, in, next, break 조건, 함수, 반복문에 사용 TRUE/FALSE 논리 상수(logical constants) NULL 정의되지 않은 값 혹은 값이 없음 표현 Inf 무한(infinity) NaN 숫자가 아님(not a number) NA 결측값(not available) NA_integer_, NA_real_, NA_complex_, NA_character_ 결측값을 처리하는 상수 … 함수가 다른 함수에 인자를 전달하도록 지원 변수(variable): 사용자가 프로그램 처리를 위해 지정한 단어 적당한 값을 저장하고 나중에 필요시 해당 값을 호출해 사용하기 위한 목적으로 사용되는 표식(label) 예약어를 변수명으로 사용할 수 없음 통계프로그래밍언어 강의노트: R 기초문법 참고 고수준 언어(high-level language): 사람이 읽고 쓰기 쉬운 형태의 명령어를 컴퓨터가 읽고 처리할 수 있도록 고안된 프로그래밍 언어 컴퓨터가 이해할 수 있는 언어 \\(\\rightarrow\\) 중앙처리장치(central processing unit, CPU)가 이해하는 언어 \\(\\rightarrow\\) 기계어(machine language) 기계어는 0과 1로 구성된 이진수(binary number)임(예: 0100101001001001001110110101101010110) 고수준 언어의 종류: C, C++, JAVA, 베이직, Perl, Python, R, … 번역기(translator): 사람이 이해할 수 있는 표현(언어)를 기계(컴퓨터)가 이해할 수 있는 언어(기계어)로 변환 인터프리터(interpreter) 컴파일러(compiler) **인터프리터*: 코드(스크립트) 한 줄을 즉석에서 읽고, 파싱(프로그램을 검사하고 구문론적 구조를 분석)하고, 해석 R, Python, MATLAB 등은 인터프리터를 번역기로 사용 인터엑티브 모드 \\(\\rightarrow\\) R 프롬프트(&gt;) 뒤에 한 줄의 명령어를 작성하면 측석해서 처리 후 다음 입력에 대해 준비(prompt)함. 안녕하세요!! 통계패키지활용 수업에서 R을 배우고 있습니다. 처음이라 실수가 많습니다. 앞으로 잘 부탁해요!! Error: &lt;text&gt;:1:6: 예기치 않은 &#39;!&#39;입니다 1: 안녕하세요! ^ print(&quot;안녕하세요!!&quot;) print(&quot;통계패키지활용 수업을 위해 R을 배우고 있습니다.&quot;) print(&quot;처음이라 실수가 많습니다.&quot;) print(&quot;앞으로 잘 부탁해요!!&quot;) [1] &quot;안녕하세요!!&quot; [1] &quot;통계패키지활용 수업을 위해 R을 배우고 있습니다.&quot; [1] &quot;처음이라 실수가 많습니다.&quot; [1] &quot;앞으로 잘 부탁해요!!&quot; 컴파일러: 완전한 프로그램을 하나의 파일에 담고 파일 안에 저장되어 있는 소스코드를 기계어로 번역 후 다음 실행할 수 있도록 변환한 기계어를 파일에 담음. 보통은 .exe, .dll 파일 형태로 저장됨 "],
["control-program.html", "2.2 프로그램", " 2.2 프로그램 프로그램(program): 특정 작업(목적)을 수행할 수 있도록 작성한 일련의 R 문장(명령어)의 집합 일련의 문장(명령어)들은 텍스트 편집기를 통해 작성하며, 스크립트(script)로 명칭되는 파일로 저장 \\(\\rightarrow\\) R 스크립트 .R 확장자를 가짐 # Hello.R print(&quot;안녕 R!!&quot;) #한국어 print(&quot;Hi R!!&quot;) # 영어 print(&quot;こんにちはR!!&quot;) # 일본어 print(&quot;Γεια R!!&quot;) #그리스어 source(&quot;hello.R&quot;, encoding = &quot;UTF-8&quot;) [1] &quot;안녕 R!!&quot; [1] &quot;Hi R!!&quot; [1] &quot;こんにちはR!!&quot; [1] &quot;Γεια R!!&quot; 예시: 텍스트 파일에서 가장 자주 나오는 단어 찾기 프로그램 https://statkclee.github.io/r4inf/r-intro.html#r-intro-what-is-a-program 참고 require(tidyverse) require(stringr) require(ggpubr) require(ggthemes) text_dat &lt;- readLines(&quot;data/text-example-01.txt&quot;) # 공백 또는 구둣점 문자를 기준으로 텍스트 나누기 # 공백 또는 구둣점 문자 기준으로 텍스트 토큰화 split_wd &lt;- str_split(text_dat, pattern = &quot;\\\\b|[[:punct:]]&quot;) split_wd &lt;- do.call(c, split_wd) id &lt;- grepl(&quot;[a-zA-Z]+&quot;, split_wd) #알파벳을 포함한 단어 인덱스 split_wd &lt;- split_wd[id] unique_wd &lt;- unique(split_wd) # 중복을 제외한 총 사용 단어 res_v &lt;- vector(&quot;integer&quot;, length(unique_wd)) # 저장 벡터 생성 for (i in seq_along(unique_wd)) { for (j in seq_along(split_wd)) { if (unique_wd[i] == split_wd[j]) { res_v[i] &lt;- res_v[i] + 1 } } } bind_cols(&quot;word&quot; = unique_wd, &quot;freq&quot; = res_v) %&gt;% arrange(desc(freq)) 프로그램 작성을 위한 개념적 요소 입력(input): 외부로부터 가져온 데이터, 값 등 출력(output): 입력에 대한 반응(결과 출력, 파일 저장, 음악 재생, …) 순차실행(sequential execution): 스크립트 또는 코드 작성 순서에 따라 한줄씩 실행 조건실행(conditional execution): 특정 조건에 따라 문장(명령)을 실행하거나 건너뜀 번복실행(iterative execution): 특정 명령을 반복적으로 실행 재사용(resuse): 스크립트의 집합(다수 줄로 구성된 코드 또는 스크립트)에 이름을 부여하고 저장 \\(\\rightarrow\\) 사용자 지정 함수(function) 프로그램 오류의 종류 구문오류(syntax error): R 언어가 이해할 수 없는 문장 또는 문법으로 실행했을 때 나타나는 오류 \\(\\rightarrow\\) 가장 고치기 쉽고 즉각적으로 알려줌 논리 또는 run-time 오류(logic or run-time error): 구문은 완벽하지만 실행 순서 또는 논리적으로 연관방식에 문제가 있어서 명령어를 수행할 수 없는 경우 의미론적 오류(sementic error): 프로그램은 구문적으로 오류가 없고 실행되지만 올바른 결과를 출력하지 않는 경우 \\(\\rightarrow\\) 제일 고치기 어려움 가장 간단한 프로그래밍은 순차적으로 명령을 실행하되 입력 시 흐름을 잠시 중단하고 대기하는 방법 \\(\\rightarrow\\) 프롬프트 상 명령어 한 줄씩 입력 # 아주 간단한 프로그래밍 예제 # readline() 함수 이용해 R한테 인사 받기 name &lt;- readline(&quot;What&#39;s your name?: &quot;) cat(&quot;Hello, &quot;, name, &quot;!\\n&quot;, sep = &quot;&quot;) # readline() 함수를 이용해 알바비 계산 x &lt;- as.numeric(readline(prompt = &quot;하루 아르바이트 시간을 입력하시오: &quot;)) y &lt;- as.numeric(readline(prompt = &quot;시급을 입력하시오 (단위=원): &quot;)) z &lt;- as.numeric(readline(prompt = &quot;한달 동안 총 몇 일 동안 일을 하셨나요? &quot;)) cat(&quot;월 급여는 &quot;, x * y * z, &quot; 원 입니다.\\n&quot;, sep = &quot;&quot;) "],
["condition.html", "2.3 조건문(Conditionals)", " 2.3 조건문(Conditionals) if 구문을 통해 조건문 생성 불린 표현식(boolean expression): 참(TRUE) 또는 거짓(FALSE) 두 값 중 하나로 값이 도출되는 표현식4 비교 연산자(comparison operators) 같다, 같지 않다, 크다 등을 표현하기 위한 연산자 ==, !=, &gt;, &lt;, &gt;=, &lt;= 논리 연산자(logical operator) AND (&amp;, &amp;&amp;), OR (|, ||), NOT (!) x &lt;- 10; y &lt;- 13 # x가 2의 배수이고 y가 3의 배수 # 두 조건이 모두 참이여야 참 x %% 2 == 0 &amp; y %% 3 == 0 # x가 2의 배수이거나 y가 3의 배수 # 두 개 조건 중 하나만 참을 만족하면 참임 x %% 2 == 0 | y %% 3 == 0 # NOT (x &gt; y) !(x &gt; y) # 부정에 부정은 참 [1] FALSE [1] TRUE [1] TRUE 2.3.1 기본 구문 if (조건) 표현식 └ 괄호 안 조건을 만족하면 표현식을 실행하고 조건을 만족하지 않으면 실행하지 않음 x &lt;- 10 if (x &gt; 0) { print(&quot;x is positive&quot;) } x &lt;- -5 if (x &gt; 0) { print(&quot;x is positive&quot;) } [1] &quot;x is positive&quot; Figure 2.2: if 구문 기본 flow-chart if 구문의 사용 규칙 if 문은 조건을 정의하는 헤더 부분((, ))과 표현식이 위치하는 몸통 블록(body block, {표현식}) 으로 구성됨 (, )에 표현되는 조건은 벡터가 아닌 단일 값으로 나타내야 함. {, } 의 표현 또는 문장이 한 줄인 경우 블록 지정이 필요하지 않지만, 두 줄 이상인 경우 if 문의 범위를 지정해줘야 하기 때문에 꼭 중괄호(curly bracket, {})가 사용되야 함. # 조건문 사용 예시 x &lt;- c(TRUE, FALSE, FALSE) y &lt;- c(TRUE, TRUE, FALSE) z &lt;- &quot;Both TRUE!!&quot; if (x[1] &amp; y[1]) print(z) # x, y 첫 번째 원소만 사용 if (x &amp;&amp; y) print(z) # 강제로 첫 번째 원소만 사용 if (x &amp; y) print(z) # 경고 표시 Warning in if (x &amp; y) print(z): length &gt; 1 이라는 조건이 있고, 첫번째 요소만이 사용될 것입니다 [1] &quot;Both TRUE!!&quot; [1] &quot;Both TRUE!!&quot; [1] &quot;Both TRUE!!&quot; 대안 실행(alternative execution) 두 가지 경우가 존재하고 조건에 따라 어떤 명령을 실행할지를 결정 if와 else로 표현 가능 조건에 따라 실행이 분기(branch) 되기 때문에 if-else 구문을 분기문이라고도 함 else 는 if 조건을 배제(exclusive)한 나머지 경우이기 때문에 조건을 따로 지정하지 않으며, if와 동일하게 중괄호 내에 표현되어야 함 x &lt;- 9 if (x %% 2 == 0) { print(&quot;x is even&quot;) } else { print(&quot;x is odd&quot;) } [1] &quot;x is odd&quot; Figure 2.3: 대안실행(if-else 구문) flow-chart 2.3.2 연쇄 조건문(chained condition) 두 가지 이상의 분기가 존재하는 경우 조건 표현식 연쇄 조건문의 표현은 아래와 같음 if (조건1) { 표현식1 ... } else if (조건2) { 표현식2 ... } else { 표현식3 ... } x &lt;- 5; y &lt;- 10 if (x &lt; y) { print(&quot;x is less than y&quot;) } else if (x &gt; y) { print(&quot;x is greater than y&quot;) } else { print(&quot;x is equal to y&quot;) } [1] &quot;x is less than y&quot; Figure 2.4: 연쇄조건(if-else if-else 구문) flow-chart 2.3.3 중첩 조건문(nested contition) 하나의 조건문 내부에 하위 조건식이 존재하는 형태 if (조건1) { 표현식1 ... } else { if (조건2) { 표현식2 ... } else { 표현식3 ... } } x &lt;- 10; y &lt;- 10 if (x == y) { print(&quot;x is equal to y&quot;) } else { if (x &gt; y) { print(&quot;x is greater than y&quot;) } else { print(&quot;x is less than y&quot;) } } [1] &quot;x is equal to y&quot; Figure 2.5: 중첩 조건문 flow-chart 중첩 조건문은 코드의 가독성을 떨어뜨리기 때문에 피하는 것을 권장 중첩 조건문을 피하기 위한 한 가지 방법은 논리 연산자를 활용 # 중첩조건 x &lt;- 58 if (x &gt; 0) { if (x &lt; 10) { print(&quot;x는 한 자리 양수&quot;) } else { if (x &lt; 100) { print(&quot;x는 두 자리 양수&quot;) } else { print(&quot;x는 세 자리 이상 양수&quot;) } } } [1] &quot;x는 두 자리 양수&quot; # 연쇄 조건 x &lt;- 2020 if (x &gt; 0 &amp; x &lt; 10) { print(&quot;x는 한 자리 양수&quot;) } else if (x &gt;=10 &amp; x &lt; 100) { print(&quot;x는 두 자리 양수&quot;) } else { print(&quot;x는 세 자리 이상 양수&quot;) } [1] &quot;x는 세 자리 이상 양수&quot; 2.3.4 ifelse() 함수 if-else 구문을 사용하기 쉽게 구현된 R 내장 함수 if-else 구문과 다르게 조건 부분에 한 값(스칼라)이 아닌 논리형 벡터를 입력값으로 받아 조건에 따른 값(벡터)을 반환 # ifelse() 함수 인수 # help(ifelse) 참고 ifelse( test, 조건에 따른 논리형 벡터 yes, test에 정의한 조건이 참인 경우 새로운 벡터에 대입할 값 no, test 조건이 거짓인 경우 대입할 값 ) 사용 예시 # 평균이 23이고 표준편차가 5인 정규분포로부터 30개의 난수 추출 set.seed(12345) bmi &lt;- rnorm(30, 23, 5) bmi_cat &lt;- ifelse(bmi &lt; 25, &quot;normal&quot;, &quot;overweight&quot;) bmi_cat [1] &quot;overweight&quot; &quot;overweight&quot; &quot;normal&quot; &quot;normal&quot; &quot;overweight&quot; [6] &quot;normal&quot; &quot;overweight&quot; &quot;normal&quot; &quot;normal&quot; &quot;normal&quot; [11] &quot;normal&quot; &quot;overweight&quot; &quot;normal&quot; &quot;overweight&quot; &quot;normal&quot; [16] &quot;overweight&quot; &quot;normal&quot; &quot;normal&quot; &quot;overweight&quot; &quot;normal&quot; [21] &quot;overweight&quot; &quot;overweight&quot; &quot;normal&quot; &quot;normal&quot; &quot;normal&quot; [26] &quot;overweight&quot; &quot;normal&quot; &quot;overweight&quot; &quot;overweight&quot; &quot;normal&quot; # ifelse() 함수를 연쇄조건문 처럼 사용할 수 있다 bmi_cat2 &lt;- ifelse(bmi &lt; 18.5, &quot;underweight&quot;, ifelse(bmi &lt; 24.9, &quot;normal&quot;, ifelse(bmi &lt; 29.9, &quot;overweight&quot;, &quot;obesity&quot;))) bmi_cat2 [1] &quot;overweight&quot; &quot;overweight&quot; &quot;normal&quot; &quot;normal&quot; &quot;overweight&quot; [6] &quot;underweight&quot; &quot;overweight&quot; &quot;normal&quot; &quot;normal&quot; &quot;underweight&quot; [11] &quot;normal&quot; &quot;obesity&quot; &quot;normal&quot; &quot;overweight&quot; &quot;normal&quot; [16] &quot;overweight&quot; &quot;normal&quot; &quot;normal&quot; &quot;overweight&quot; &quot;normal&quot; [21] &quot;overweight&quot; &quot;obesity&quot; &quot;normal&quot; &quot;underweight&quot; &quot;underweight&quot; [26] &quot;obesity&quot; &quot;normal&quot; &quot;overweight&quot; &quot;overweight&quot; &quot;normal&quot; 비교 및 논리 연산자(통계프로그래밍언어 2.1.4절 참고)↩︎ "],
["looping.html", "2.4 반복문(Looping)", " 2.4 반복문(Looping) Prerequisite 프로그램 또는 알고리즘 구현 시 특정 문장 또는 표현을 반복해야만 하는 상황이 발생 특히 시뮬레이션 시 반복문은 거의 필수적임 반복문을 통해 코딩의 효율을 극대화 할 수 있음 반복문은 특정 변수의 값을 갱신(update) 하기 위해 주로 사용 x &lt;- x + 1 # 현재 값에 1을 더해서 x를 새로운 값으로 update 통상적으로 특정 변수의 값을 갱신하기 위해 변수 값을 초기화(initialize) x &lt;- 0 # x 변수 초기화 x &lt;- x + 1 몇 번 반복이라는 정의가 없는 상태에서 특정 조건이 거짓(FALSE)이 될 때 까지 계속 반복 2.4.1 repeat 구문 repeat 표현식 repeat 다음에 오는 표현식을 무한 반복(infinite loop) repeat print(&quot;무한 루프에 걸림...ESC 키 누르시오!!&quot;) [1] &quot;무한 루프에 걸림...ESC 키 누르시오!!&quot; [1] &quot;무한 루프에 걸림...ESC 키 누르시오!!&quot; [1] &quot;무한 루프에 걸림...ESC 키 누르시오!!&quot; [1] &quot;무한 루프에 걸림...ESC 키 누르시오!!&quot; [1] &quot;무한 루프에 걸림...ESC 키 누르시오!!&quot; ... ... 특정 작업에 대해 블록을 지정(중괄호)하고 블록 안에 표현 가능 일반적으로 특정 조건(if (조건) break)을 두어 무한루프에서 탈출 if 문의 조건은 언제 반복이 끝날 지를 제어하는 변수로 반복변수(iteration variable) 이라고도 함 언제까지(until) 반복(repeat) \\(\\rightarrow\\) REPEAT-UNTIL 구문으로 표현 repeat { 표현식 1 if (조건) break 반복변수 update } Figure 2.6: REPEAT 구문 flow-chart # REPEAT-UNTIL 예시 1 # 1:100 까지 합 계산 함수 tot &lt;- 0; i &lt;- 1 # 사용 변수 초기화 (update 변수) repeat { tot &lt;- tot + i if (i &gt;= 100) break # i는 반복 변수 i &lt;- i + 1 } tot # check sum(1:100) [1] 5050 [1] 5050 tot에 i를 더한 후 i 가 조건을 만족하는지 확인 조건에 부합하지 않으면 다음 문장 실행(i에 1을 증가 후 업데이트) 1. 의 작업을 반복(loop) i가 조건에 부합하면 반복 종료 # REPEAT 예시 2 # 1에서 20 사이 숫자 알아맞추기 게임 n &lt;- 20 number &lt;- sample(1:n, size = 1) cat(&quot;1에서 &quot;, n, &quot;까지 숫자 알아 맞추기&quot;, sep = &quot;&quot;) repeat { guess &lt;- readline(&quot;어떤 숫자를 생각하시나요? (종료: q 입력) &quot;) if (guess == &quot;q&quot;) { cat(&quot;재미가 없나봐요.\\n&quot;) break } else if (as.numeric(guess) == number) { cat(&quot;천재인데요?ㅋㅋㅋ&quot;) break } # 틀리면 계속 반복 } guess에 readline() 으로부터 값 입력 guess 값이 q 이면 종료 guess 값이 number 와 일치하면 종료 2.와 3. 조건에 부합하지 않으면 guess 값을 반복적으로 입력 어떤 숫자를 생각하시나요? (종료: q 입력) 1 어떤 숫자를 생각하시나요? (종료: q 입력) 2 어떤 숫자를 생각하시나요? (종료: q 입력) 3 천재인데요?ㅋㅋㅋ 2.4.2 while 구문 while (조건) 표현식 ... while에 지정된 조건이 참이면 계속해서 반복 repeat는 반복이 처음부터 시작되는 반면, while 문은 조건을 먼저 평가한 후 반복이 시작됨. while (FALSE)인 경우 루프 본문 코드가 실행되지 않음 while (TRUE)는 repeat 구문과 동일 while문 의 일반적 형태 while (조건) { 표현식 1 반복변수 update } Figure 2.7: WHILE 구문 flow-chart # WHILE 구문 예시 1 # 1:100 까지 합 계산 함수 tot &lt;- 0; i &lt;- 1 # 사용 변수 초기화 (update 변수) while (i &lt;= 100) { tot &lt;- tot + i i &lt;- i + 1 } tot [1] 5050 초기값 i가 조건 i &lt;= 100 인지 확인 참인 경우 tot + i를 통해 tot을 업데이트 한 다음 i를 1만큼 증가 만약 i에 대한 조건 평가 결과가 거짓이면 while 구문을 빠져나감 # while 문 조건이 TRUE 인 경우 tot &lt;- 0; i &lt;- 1 # 사용 변수 초기화 (update 변수) while (TRUE) { tot &lt;- tot + i if (i &gt;= 100) break i &lt;- i + 1 } tot [1] 5050 while 의 조건이 참이기 때문에 무한 반복 단 i가 100과 같거나 클 경우 구문 탈출 그 전 까지는 tot와 i를 갱신 # WHILE 구문 예시 2 # 문자열 벡터에서 특정 문자열의 인덱스를 반환 txtvec &lt;- c(&quot;R&quot;, &quot;package&quot;, &quot;flow-control&quot;, &quot;while&quot;, &quot;if&quot;, &quot;for&quot;, &quot;repeat&quot;) found &lt;- FALSE i &lt;- 1 word &lt;- readline(&quot;검색할 텍스트: &quot;) while (!found &amp; i &lt;= length(txtvec)) { if (txtvec[i] == word) { found &lt;- TRUE break } cat(i, &quot; 번째 위치에 해당 단어가 존재하지 않습니다.\\n&quot;, sep=&quot;&quot;) i &lt;- i + 1 } if (found) { cat(i, &quot; 번째 위치에 &quot;, word, &quot;를 찾았습니다.&quot;, sep = &quot;&quot;) } else { cat(word, &quot; 단어는 해당 문자열 벡터에 존재하지 않습니다.\\n&quot;, sep = &quot;&quot;) } found = FALSE, i = 1을 초기값으로 입력 readline()으로 입력한 텍스트를 word에 저장 found 가 참이고 i가 텍스트 벡터의 길이 값과 같을 때 까지 다음 구문 반복 txtvec 각 원소와 word 값이 같은지 확인 while 입력 결과 1 번째 위치에 해당 단어가 존재하지 않습니다. 2 번째 위치에 해당 단어가 존재하지 않습니다. 3 번째 위치에 해당 단어가 존재하지 않습니다. 4 번째 위치에 while 를 찾았습니다. temp 입력 결과 1 번째 위치에 해당 단어가 존재하지 않습니다. 2 번째 위치에 해당 단어가 존재하지 않습니다. 3 번째 위치에 해당 단어가 존재하지 않습니다. 4 번째 위치에 해당 단어가 존재하지 않습니다. 5 번째 위치에 해당 단어가 존재하지 않습니다. 6 번째 위치에 해당 단어가 존재하지 않습니다. 7 번째 위치에 해당 단어가 존재하지 않습니다. temp 단어는 해당 문자열 벡터에 존재하지 않습니다. repeat, while과 같이 반복의 횟수가 지정되지 않는 반목구문을 불확정 반복문(indefinite loop)이라고 함. 다음에 배울 for 구문은 위 두 반복문과는 다르게 반복의 범위를 명확히 지정하기 때문에 확정 반복문(definite loop)라고 함. 2.4.3 for 구문 가장 많이 사용되는 반복구문으로 일반적인 형태는 아래와 같음 for (반복변수 in sequence) { 표현식 1 ... } R에서 sequence은 특정 유형의 벡터이며, 반복변수에 sequence의 원소를 순차적으로 할당함 반복변수는 for 반복문 안의 표현식 1에서 사용됨 Figure 2.8: FOR 구문 flow-chart #for 문 예시 1 student &lt;- readxl::read_excel(&quot;data/stat-students.xlsx&quot;) student_name &lt;- student$이름 for (s in student_name) { cat(s, &quot;학생!! 즐거운 명절 보내세요^^\\n&quot;) } 김세민 학생!! 즐거운 명절 보내세요^^ 김기랑 학생!! 즐거운 명절 보내세요^^ 이종영 학생!! 즐거운 명절 보내세요^^ 이원규 학생!! 즐거운 명절 보내세요^^ 황보영 학생!! 즐거운 명절 보내세요^^ 구나현 학생!! 즐거운 명절 보내세요^^ 엄용현 학생!! 즐거운 명절 보내세요^^ 오동원 학생!! 즐거운 명절 보내세요^^ 윤지우 학생!! 즐거운 명절 보내세요^^ 이근범 학생!! 즐거운 명절 보내세요^^ 이승호 학생!! 즐거운 명절 보내세요^^ 이희도 학생!! 즐거운 명절 보내세요^^ 정보경 학생!! 즐거운 명절 보내세요^^ 채시진 학생!! 즐거운 명절 보내세요^^ 최호진 학생!! 즐거운 명절 보내세요^^ 박인혜 학생!! 즐거운 명절 보내세요^^ 박준기 학생!! 즐거운 명절 보내세요^^ 최소미 학생!! 즐거운 명절 보내세요^^ 백승완 학생!! 즐거운 명절 보내세요^^ 김지원 학생!! 즐거운 명절 보내세요^^ 신형원 학생!! 즐거운 명절 보내세요^^ 임현정 학생!! 즐거운 명절 보내세요^^ 정수빈 학생!! 즐거운 명절 보내세요^^ 최예린 학생!! 즐거운 명절 보내세요^^ 황정인 학생!! 즐거운 명절 보내세요^^ student_name의 첫 번째 원소를 s에 할당 for 구문 안에 표현 실행 student_name의 마지막 원소까지 반복 # 위 예시와 동일한 표현 ## 인덱싱을 사용 for (i in 1:length(student_name)) { cat(student_name[i], &quot;학생!! 즐거운 명절 보내세요^^\\n&quot;) } ## sequence를 만드는 함수 seq_along() 사용 for (i in seq_along(student_name)) { cat(student_name[i], &quot;학생!! 즐거운 명절 보내세요^^\\n&quot;) } for 구문 안에 for 문을 1개 이상 중첩 가능 ## 2중 for 문 예시 set.seed(12345) id &lt;- sample(1:length(student_name), 5) sel_student &lt;- student_name[id] for (i in seq_along(student_name)) { for (j in seq_along(sel_student)) { if (student_name[i] == sel_student[j]) { cat(sel_student[j], &quot;님!! 당첨 축하 드립니다!!\\n&quot;) } } } 김기랑 님!! 당첨 축하 드립니다!! 이승호 님!! 당첨 축하 드립니다!! 채시진 님!! 당첨 축하 드립니다!! 박인혜 님!! 당첨 축하 드립니다!! 백승완 님!! 당첨 축하 드립니다!! 불확정 반복문 학습 시 무한루프로부터 break를 통해 루프에서 탈출 루프를 완전히 탈출하지 않고 현재 반복을 중지하고 그 다음 반복을 진행하고 싶을 경우 next 예약어를 사용 # 알파벳 e와 일치하는 경우에만 텍스트 메세지 출력 vec &lt;- c(&quot;a&quot;,&quot;e&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;, &quot;e&quot;, &quot;z&quot;) word &lt;- &quot;e&quot; for (i in 1:length(vec)) { if (vec[i] != word) next cat(word, &quot;가&quot;, i, &quot;번 째 인덱스에 있네요!!\\n&quot;) } e 가 2 번 째 인덱스에 있네요!! e 가 3 번 째 인덱스에 있네요!! e 가 7 번 째 인덱스에 있네요!! "],
["function.html", "2.5 함수 (function)", " 2.5 함수 (function) Figure 2.9: 함수 함수: 특정한 목적을 위한 연산을 수행하기 위해 명명된 일련의 문장(추상화) 예: sum(x) \\(\\rightarrow\\) 벡터 x의 값을 모두 합산하는 함수로 “sum” 이라고 명명된 내장 함수 R 콘솔에서 함수 명칭(예: sum)을 입력 후 실행하면 함수 내부 확인 가능 sum function (..., na.rm = FALSE) .Primitive(&quot;sum&quot;) 함수의 명칭(위의 예에서 sum)으로 특정 합수를 호출(call) R의 스크립트는 내장된 혹은 사용자가 정의한 함수들을 호출함으로써 작성됨 함수를 사용해야만 하는 이유 매우 큰 프로그램 작업을 해야할 경우 함수를 통해 작업 단위 별로 분할 가능 한 번 작성한 함수는 재사용 가능 프로그램의 체계적 관리가 가능하기 때문에 유지 및 보수가 용이 프로그램 코드의 간결화 2.5.1 함수의 정의 function 이라는 R의 예약어를 통해 사용자 함수 정의 함수 정의 시 함수의 명칭을 반드시 부여해야 함 함수 이름 &lt;- function() 함수는 일반적으로 인수(argument)로 입력값을 전달 받으면 그 결과값을 반환(return) 함수의 인수와 반환에 따라 다음과 같이 4 가지 유형의 함수 정의 가능 인수를 갖는 함수 인수를 갖지 않는 함수 값을 반환하는 함수 값을 반환하지 않는 함수 # (1) 인수를 갖는 함수 ## (모)분산을 계산하는 함수 var_pop &lt;- function(x) { n &lt;- length(x) if (n &lt; 2) { stop(&quot;적어도 두 개 이상의 관찰값이 존재해야 합니다&quot;) } mx &lt;- mean(x) v &lt;- sum((x - mx)^2)/n return(v) # 결과를 반환하는 함수: v를 함수의 출력값으로 설정 } ## test set.seed(1) # 동일한 난수 생성을 위해 seed 번호 부여 x &lt;- rnorm(1) var_pop(x) Error in var_pop(x): 적어도 두 개 이상의 관찰값이 존재해야 합니다 set.seed(1000) x &lt;- rnorm(1000, 2, 4) # 평균이 2이고 표준편차가 4인 정규분포로부터 1000개 난수 추출 var_pop(x) [1] 15.40581 # (2) 인수를 갖지 않는 함수 print_lyrics_let_it_be &lt;- function() { print(&quot;When I find myself in times of trouble, &quot;) print(&quot;Mother Mary comes to me.&quot;) print(&quot;Speaking words of wisdom &#39;let it be&#39;.&quot;) } print_lyrics_let_it_be() [1] &quot;When I find myself in times of trouble, &quot; [1] &quot;Mother Mary comes to me.&quot; [1] &quot;Speaking words of wisdom &#39;let it be&#39;.&quot; print_lyrics_let_it_be(beatles) Error in print_lyrics_let_it_be(beatles): 사용되지 않은 인자 (beatles) ## 주사위를 돌리는 함수 rolling_dice &lt;- function() { sample(1:6, 1, replace = TRUE) } rolling_dice(); rolling_dice(); rolling_dice(); [1] 4 [1] 4 [1] 4 # (3) 값을 반환하는 함수 manual_mean &lt;- function(x) { n &lt;- length(x) sumi &lt;- 0 for (i in 1:n) { sumi &lt;- sumi + x[i] } return(sumi/n) } set.seed(20) x &lt;- sample(1:200, 20, replace = FALSE) # 1 ~ 200 중 랜덤하게 20개 추출(비복원) manual_mean(x) [1] 107 # 미리 정의하지 않은 인수를 입력한 경우 set.seed(4) na_idx &lt;- sample(1:length(x), 4) x[na_idx] &lt;- NA manual_mean(x, na.rm = TRUE) Error in manual_mean(x, na.rm = TRUE): 사용되지 않은 인자 (na.rm = TRUE) # (4) 값을 반환하지 않는 함수(void function) summary_mean &lt;- function(x, ...) { n &lt;- sum(!is.na(x)) mx &lt;- sum(x, ...)/n cat(&quot;Data: &quot;, sprintf(&quot;%.2f&quot;, x), &quot;\\n&quot;) # 소숫점 2째 짜리 까지 출력 cat(&quot;전체 관찰값 개수(결측 제외) = &quot;, n, &quot;\\n&quot;) cat(&quot;산술평균 = &quot;, mx, &quot;\\n&quot;) } set.seed(20) x &lt;- rnorm(20) summary_mean(x) Data: 1.16 -0.59 1.79 -1.33 -0.45 0.57 -2.89 -0.87 -0.46 -0.56 -0.02 -0.15 -0.63 1.32 -1.52 -0.44 0.97 0.03 -0.09 0.39 전체 관찰값 개수(결측 제외) = 20 산술평균 = -0.1877639 result &lt;- summary_mean(x) Data: 1.16 -0.59 1.79 -1.33 -0.45 0.57 -2.89 -0.87 -0.46 -0.56 -0.02 -0.15 -0.63 1.32 -1.52 -0.44 0.97 0.03 -0.09 0.39 전체 관찰값 개수(결측 제외) = 20 산술평균 = -0.1877639 result NULL x[na_idx] &lt;- NA # ...를 통해 미리 정하지 않은 인수를 # 함수 내부에서 호출한 다른 함수로 전달 가능 summary_mean(x, na.rm = TRUE) Data: 1.16 -0.59 NA -1.33 -0.45 0.57 NA -0.87 -0.46 -0.56 NA -0.15 -0.63 1.32 -1.52 -0.44 0.97 0.03 NA 0.39 전체 관찰값 개수(결측 제외) = 16 산술평균 = -0.1590692 x &lt;- summary_mean(x, na.rm = TRUE) Data: 1.16 -0.59 NA -1.33 -0.45 0.57 NA -0.87 -0.46 -0.56 NA -0.15 -0.63 1.32 -1.52 -0.44 0.97 0.03 NA 0.39 전체 관찰값 개수(결측 제외) = 16 산술평균 = -0.1590692 2.5.2 함수의 인수 전달 방법 함수는 입력값(input) 을 가지며, 이러한 입력값은 함수의 인수(argument)에 해당 값을 할당함으로써 입력값이 함수로 전달됨 함수의 인수 정의는 내 마음대로 가능(개수 무관) R에서 함수 호출 시 인수 전달은 “값”을 호출 하는 방식(call by value) call by value와 상반되는 개념으로 참조에 의한 호출(call by reference)로 값이 아니라 값이 저장되어 있는 메모리의 주소 값을 전달하는 방식(대표적인 예: C 언어의 포인터)임. 계산 효율은 참조에 의한 호출이 월등히 뛰어나지만, 프로그램의 구조가 복잡하다는 단점을 가짐. R은 데이터 분석에 특화된 프로그램이기 때문에 직관적인 call by value 방식을 택함. 예시 # 두 변수의 값을 바꾸는 함수: swap swap &lt;- function(x, y) { temp &lt;- x x &lt;- y y &lt;- temp cat(&quot;두 값이 바뀌었습니다.&quot;, sprintf(&quot;x = %d, y = %d&quot;, x, y) ,&quot;\\n&quot;) } x &lt;- 3; y &lt;- 10 swap(x, y) 두 값이 바뀌었습니다. x = 10, y = 3 x; y # x, y 두 값이 바뀌지 않음 [1] 3 [1] 10 인수를 전달하는 방법은 다음 두 가지임 인수의 위치 순서에 의한 전달: 정의한 인수의 순서대로 각 인수에 대응하는 값을 전달 인수의 이름에 의한 전달: 위치와 관계 없이 정의한 인수의 이름을 지정하여 값을 전달 # 표준편차 계산 함수: stdev stdev &lt;- function(x, na.rm = TRUE) { if (is.matrix(x)) apply(x, 2, sd, na.rm = na.rm) else if (is.vector(x)) sqrt(var(x, na.rm = na.rm)) else if (is.data.frame(x)) sapply(x, sd, na.rm = na.rm) else sqrt(var(as.vector(x), na.rm = na.rm)) } set.seed(1000) X &lt;- matrix(rnorm(1000), 100, 10) x &lt;- rpois(50, lambda = 10) # 포아송 분포(lambda = 10)에서 50개 난수 추출 dat &lt;- mtcars # R 내장 데이터를 dat 에 저장 # (1) 순서에 의한 전달 stdev(X, T); stdev(X) # 동일한 결과 [1] 1.0065940 0.9033927 0.9727257 0.9905631 0.8202803 1.0114516 0.9855547 [8] 1.0211373 1.0716219 1.0426811 [1] 1.0065940 0.9033927 0.9727257 0.9905631 0.8202803 1.0114516 0.9855547 [8] 1.0211373 1.0716219 1.0426811 stdev(x) [1] 3.41569 stdev(dat) mpg cyl disp hp drat wt 6.0269481 1.7859216 123.9386938 68.5628685 0.5346787 0.9784574 qsec vs am gear carb 1.7869432 0.5040161 0.4989909 0.7378041 1.6152000 stdev(TRUE, dat) # 오류 why?? Warning in if (na.rm) &quot;na.or.complete&quot; else &quot;everything&quot;: length &gt; 1 이라는 조건 이 있고, 첫번째 요소만이 사용될 것입니다 Error in if (na.rm) &quot;na.or.complete&quot; else &quot;everything&quot;: argument is not interpretable as logical # (2) 이름에 의한 전달 set.seed(5) na_idx &lt;- sample(1:50, 5) x[na_idx] &lt;- NA stdev(na.rm = T, x = x) [1] 3.411211 stdev(dat = dat, na.rm = TRUE) # 오류 why??? Error in stdev(dat = dat, na.rm = TRUE): 사용되지 않은 인자 (dat = dat) 2.5.3 함수의 기본 구성 요소 Figure 2.10: 함수의 기본 구조 function()에서 () 안의 부분(일반적으로 첫 번째 줄)을 머리(header) 부분 함수의 초기 형태(매개변수 또는 인수의 형태)를 지정 연산 또는 명령이 수행되는 부분은 함수의 몸통(body) 부분({} 로 표시) 함수 내부에서 실행되는 연산 명령어들의 집합으로 구성 인수(argument): 함수의 기능을 선택적으로 조정하는 parameter로 함수 안에서 작동하는 매개변수들을 통칭 인수는 argument 또는 argument = default value로 설정 복수의 인수는 콤마(,)로 구분 \\(\\rightarrow\\) fun_name &lt;- function(arg1, arg2, arg3) 특수 인수 ...: 어떠한 개수의 인수를 함수로 전달할 수 있음 일반적으로 인수의 개수가 불특정하거나 함수 안에서 다른 함수를 호출할 때 특정 인수를 다른 함수로 전달시킬 때 유용(위 예시 참고) # (1) 인수에 default 값을 주지 않은 함수 fun_without_arg_default &lt;- function(x, y) { x*y } set.seed(10) a &lt;- sample(1:20, 10, replace = TRUE) # 복원 추출 a[7] &lt;- NA b &lt;- 5 fun_without_arg_default(a, b) [1] 55 45 50 80 60 40 NA 95 75 75 # (2) 인수에 default 값을 부여한 함수 fun_with_arg_default &lt;- function(x = 5, y = 8) { x*y } fun_with_arg_default() [1] 40 trim_mean &lt;- function(x, trim = 0, na.rm = F) { mean(x, trim = trim, na.rm = na.rm) } trim_mean(a) [1] NA trim_mean(x = a, trim = 0.2, na.rm = TRUE) # 인수 이름으로 값 전달 [1] 12.57143 trim_mean(a, 0.3, TRUE) # 인수 순서대로 값 전달 [1] 12.6 # (3) ... 인수 사용 예제 # list() 함수를 이용해 `...`에 해당하는 인수들을 리스트 객체로 만든 후 # 이를 함수에서 사용 dot_example &lt;- function(x, ...) { # browser() trim &lt;- 0 na.rm &lt;- FALSE dots &lt;- list(...) # ...에 해당하는 인수 추출 for (arg in names(dots)) { if (arg == &quot;trim&quot;) trim &lt;- as.numeric(dots[arg]) if (arg == &quot;na.rm&quot;) na.rm &lt;- as.logical(dots[arg]) } mean(x, trim = trim, na.rm = na.rm) } dot_example(a) [1] NA set.seed(30) a &lt;- sample(1:30, 15, replace = TRUE) # 복원 추출 dot_example(a) [1] 17.06667 a[9] &lt;- NA dot_example(a) [1] NA dot_example(a, trim = 0.1, na.rm = TRUE) [1] 17.75 # (4) `...` 인수가 함수 내 사용(호출)된 # 다른 함수의 인수로 전달하는 경우 # summary_mean() 함수 예제와 유사 mean_manual &lt;- function(x, ...) { mean(x, ...) } set.seed(30) x &lt;- rnorm(30, mean = 10, sd = 5) na_idx &lt;- sample(1:30, 3, replace = TRUE) xna &lt;- x; xna[na_idx] &lt;- NA mean_manual(x) [1] 8.347683 mean_manual(xna) [1] NA mean_manual(xna, na.rm = TRUE) [1] 8.127862 mean_manual(x = xna, trim = 0.2, na.rm = TRUE) [1] 7.534424 함수 몸체 안에 browser()을 입력하면, browser() 전 까지 함수 몸체 안 명령들이 수행되고, 이후 명령들이 어떻게 실행되는지 확인할 수 있음. 함수 작성 시 함수 로직을 세우고 디버깅 할 때 매우 유용하게 사용 인수 관련 몇 가지 유용한 함수들 args(): 특정 함수에서 사용되는 인수 확인 args(fun_without_arg_default) function (x, y) NULL args(rnorm) function (n, mean = 0, sd = 1) NULL body(): 함수의 몸체 조회 body(var_pop) { n &lt;- length(x) if (n &lt; 2) { stop(&quot;적어도 두 개 이상의 관찰값이 존재해야 합니다&quot;) } mx &lt;- mean(x) v &lt;- sum((x - mx)^2)/n return(v) } body(dot_example) { trim &lt;- 0 na.rm &lt;- FALSE dots &lt;- list(...) for (arg in names(dots)) { if (arg == &quot;trim&quot;) trim &lt;- as.numeric(dots[arg]) if (arg == &quot;na.rm&quot;) na.rm &lt;- as.logical(dots[arg]) } mean(x, trim = trim, na.rm = na.rm) } match.arg(): 인수를 매치하는 함수로 매치할 대상의 인수를 지정 arg: 매치할 대상 인수 지정 choice: 매치될 인수값 목록 several.ok: 복수 선택 여부(TRUE/FALSE) # 인수의 매치 match.arg(arg = c(&quot;med&quot;, &quot;max&quot;), choices = c(&quot;mean&quot;, &quot;median&quot;, &quot;iqr&quot;, &quot;minimum&quot;, &quot;maximum&quot;, &quot;range&quot;), several.ok = TRUE) [1] &quot;median&quot; &quot;maximum&quot; match.arg(arg = c(&quot;median&quot;, &quot;maximuum&quot;), choices = c(&quot;mean&quot;, &quot;med&quot;, &quot;iqr&quot;, &quot;minimum&quot;, &quot;max&quot;, &quot;range&quot;), several.ok = TRUE) # 오류 why?? Error in match.arg(arg = c(&quot;median&quot;, &quot;maximuum&quot;), choices = c(&quot;mean&quot;, : &#39;arg&#39;은 반드시 &quot;mean&quot;, &quot;med&quot;, &quot;iqr&quot;, &quot;minimum&quot;, &quot;max&quot;, &quot;range&quot; 중 하나이어야 합니다 match.arg(arg = c(&quot;med&quot;, &quot;max&quot;), choices = c(&quot;mean&quot;, &quot;median&quot;, &quot;iqr&quot;, &quot;minimum&quot;, &quot;maximum&quot;, &quot;range&quot;), several.ok = FALSE) Error in match.arg(arg = c(&quot;med&quot;, &quot;max&quot;), choices = c(&quot;mean&quot;, &quot;median&quot;, : &#39;arg&#39;는 반드시 길이가 1이어야 합니다 # match.arg() 함수 응용 # 중심값 관련 통계량 계산 함수 # 평균(mean), 절삭평균(trimmed mean), 중앙값(median), 최빈수(mode) 계산 # pkg_list &lt;- rownames(installed.packages()) # 설치된 패키지 목록 # if (!(&quot;DescTools&quot; %in% pkg_list)) # install.packages(&quot;DescTools&quot;) # 최빈수를 구하기 위한 패키지 설치 center &lt;- function(x, type = c(&quot;mean&quot;, &quot;trimmed&quot;, &quot;median&quot;, &quot;mode&quot;), ... ) { # browser() trim = 0; na.rm = FALSE # dot 인수 초기값 type &lt;- match.arg(type) dots &lt;- list(...) for (arg in names(dots)) { if (arg == &quot;trim&quot;) trim &lt;- as.numeric(dots[arg]) if (arg == &quot;na.rm&quot;) na.rm &lt;- as.logical(dots[arg]) } switch(type, mean = mean(x, na.rm = na.rm), trimmed = mean(x, trim = trim, na.rm = na.rm), median = median(x, na.rm = na.rm), mode = DescTools::Mode(round(x, 1), na.rm = na.rm) # DescTools 패키지 내 Mode 함수를 # workspace에 불러오지 않고 사용 ) } set.seed(100) x &lt;- rchisq(100, df = 3) # 자유도가 3인 카이제곱분포에서 난수 추출 xna &lt;- x; xna[na_idx] &lt;- NA center(x, &quot;mean&quot;); center(x, &quot;me&quot;) [1] 2.929673 Error in match.arg(type): &#39;arg&#39;은 반드시 &quot;mean&quot;, &quot;trimmed&quot;, &quot;median&quot;, &quot;mode&quot; 중 하나이어야 합니다 [1] 2.929673 center(x, &quot;trimmed&quot;, trim = 0.1) [1] 2.565866 center(x, &quot;median&quot;) [1] 2.45614 center(x, &quot;mode&quot;) [1] 1.7 attr(,&quot;freq&quot;) [1] 6 center(xna, &quot;median&quot;) [1] NA center(xna, &quot;median&quot;, na.rm = TRUE) [1] 2.423723 switch() 함수는 ifelse() 함수의 확장 버전으로 \\(n\\) 개의 조건에 대한 분기 가능 함수 제어 관련 주요 함수 return(): 계산된 결과를 반환하는 함수로 함수의 흐름에서 return()이 나타나면 결과값을 반환하고 함수 종료 강제 종료가 필요한 경우 응용 가능 # (1) 객체 반환 set.seed(100) x &lt;- rnorm(100, mean = 24, sd = 2.2) value_return1 &lt;- function(x) { tot &lt;- sum(x) n &lt;- length(x) result &lt;- list(size = n, total = tot, average = mean(x), stdev = sd(x)) return(result) } value_return1(x) $size [1] 100 $total [1] 2400.641 $average [1] 24.00641 $stdev [1] 2.245563 desc &lt;- value_return1(x) desc$stdev [1] 2.245563 value_return2 &lt;- function(x) { return(sum(x)/length(x)) } value_return2(x) [1] 24.00641 # (2) 강제 종료 시 활용 value_return3 &lt;- function(x) { if (anyNA(x)) return return(sum(x)/length(x)) } xna &lt;- x; xna[na_idx] &lt;- NA value_return3(xna) [1] NA value_return3(x) [1] 24.00641 stop(): 예외처리 함수의 일종으로 특정 조건일 경우 (오류) 메세지를 출력하고 함수 종료 인수로 문자열을 가짐 # (1) stop() 함수 사용 # 복소수 값을 실수와 허수로 분할 split_complex &lt;- function(z) { if(!is.complex(z)) stop(&quot;입력값이 복소수가 아닙니다&quot;) re &lt;- Re(z) im &lt;- Im(z) return(list(real = re, imaginary = im)) } split_complex(pi) Error in split_complex(pi): 입력값이 복소수가 아닙니다 split_complex(23 + 7i) $real [1] 23 $imaginary [1] 7 2.5.4 함수의 적용 범위(scoping rule) Scoping rule: 변수 또는 객체가 어디에서 사용 가능한지를 결정하는 규칙 매개변수(parameter): 함수를 적용할 때 사용되는 변수로 인수로부터 발생함 함수의 인수 리스트에서 인수값이 매개변수로 할당 지역변수(local variable): 함수의 몸체 부분에서 정의된 변수들을 지칭하며 함수의 종료와 동시에 재사용 불가 전역변수(global variable): 함수의 외부(workspace)에서 정의된 변수로 함수 내부에서 값을 할당하지 않더라도 사용 가능 # (1) 매개변수, 지역변수, 전역변수 구분 x &lt;- 10 # 전역변수 y &lt;- 5 # 전역변수 scope1 &lt;- function(x) { y &lt;- x^2 print(x) # 매개변수 print(y) # 지역변수 } x; y # 전역변수가 출력 [1] 10 [1] 5 scope1(x = 10) [1] 10 [1] 100 작업공간에서 x와 y는 각각 10, 5 값이 할당 작업공간 상에서 x y 값은 변하지 않음 지역변수 y의 사용 범위는 함수 몸체이기 때문에 함수 밖에 있는 y는 값이 변하지 않음 x &lt;- 10 # 전역변수 y &lt;- 5 # 전역변수 rm(z) scope2 &lt;- function(x) { y &lt;- x^2 print(x) # 매개변수 print(y) # 지역변수 print(z) } scope2(x = 5) [1] 5 [1] 25 Error in print(z): 객체 &#39;z&#39;를 찾을 수 없습니다 z &lt;- 13 # 전역변수로 z 할당 scope2(x = 5) [1] 5 [1] 25 [1] 13 함수 외부와 내부 모두에서 z가 정의되지 않았기 때문에 에러 출력 작업공간 상에 z를 정의한 경우 함수 내부에서 workspace에서 정의한 z를 그대로 사용 \\(\\rightarrow\\) 함수 외부와 내부 자유로이 사용 가능한 변수를 자유변수(free variable)이라고 지칭함. 지역변수의 사용 범위는 함수 몸체 안이지만 그 범위를 밖으로 확장할 수 있음 \\(\\rightarrow\\) &lt;&lt;- 또는 -&gt;&gt; 사용 # 지경변수의 확장 예제 x &lt;- 1; y &lt;- 2; z &lt;- 3; k &lt;- 10 scope3 &lt;- function(x) { y &lt;&lt;- x + 10 y * 3 -&gt;&gt; z print(x) # 매개변수 print(y) # 지역변수 print(z) # 지역변수 print(k) # 자유변수 } x;y;z;k [1] 1 [1] 2 [1] 3 [1] 10 scope3(x = 2) [1] 2 [1] 12 [1] 36 [1] 10 x;y;z;k [1] 1 [1] 12 [1] 36 [1] 10 하나의 함수 내부에 또 다른 함수 생성 가능 mean_manual2 &lt;- function(x) { tot &lt;- sum(x) size &lt;- function(x) { return(length(x)) } return(tot/size(x)) } mean_manual2(1:10) [1] 5.5 2.5.5 재귀 호출 함수(recursive call function) 함수 자신을 다시 호출하는 함수로 직관적으로 이해하기 쉽고 간결함 재귀함수 작성 시 재귀호출을 탈출하는 조건을 명확히 하는 것이 관건 예제1: 계승(factorial) 계산하기 \\[ n! = \\begin{cases} n \\times (n - 1)!, &amp; n=1, \\cdots \\\\ 1, &amp; n = 0 \\end{cases} \\] \\(f(n) = n!\\) 이라고 하면 \\(f(n)\\)은 아래와 같이 나타낼 수 있음. \\[ n! = \\begin{cases} n \\times f(n-1), &amp; n=1, \\cdots \\\\ 1, &amp; n = 0 \\end{cases} \\] 위 식을 이용해 \\(3!\\)을 구하는 과정: - \\(f(3) = 3\\times f(2) = 3\\times 2 \\times f(1) = 3 \\times 2\\times 1\\times f(0) = 3\\times 2\\times 1\\times 1\\times = 6\\) f(3) = 3*f(2) f(2) = 2 * f(1) f(1) = 1 위 과정을 함수로 구현 factorial_manual &lt;- function(n) { if (n == 0) return(1) return(n * factorial_manual(n-1)) } # test factorial_manual(3) [1] 6 factorial_manual(10) [1] 3628800 # R 내장함수로 검증 factorial(10) [1] 3628800 예제: 하노이 탑(tower of Hanoi) “인도 베나레스에 있는 한 사원에는 세상의 중심을 나타내는 큰 돔이 있고 그 안에 세 개의 다이아몬드 바늘이 동판 위에 세워져 있습니다. 바늘의 높이는 1 큐빗이고 굵기는 벌의 몸통만 합니다. 바늘 가운데 하나에는 신이 64개의 순금 원판을 끼워 놓았습니다. 가장 큰 원판이 바닥에 놓여 있고, 나머지 원판들이 점점 작아지며 꼭대기까지 쌓아 있습니다. 이것은 신성한 브라흐마의 탑입니다. 브라흐마의 지시에 따라 승려들은 모든 원판을 다른 바늘로 옮기기 위해 밤낮 없이 차례로 제단에 올라 규칙에 따라 원판을 하나씩 옮깁니다. 이 일이 끝날 때, 탑은 무너지고 세상은 종말을 맞이하게 됩니다.” [Wikipedia] 문제: 3개의 기둥 A, B, C가 있고, 기둥 A에 \\(N\\) 개의 원판이 크기 순서대로 쌓여져 있을 때(제일 밑에 원판이 가장 큼), 모든 원판을 기둥 C로 옮기기 조건 한 번에 하나의 원판만 옮길 수 있음 큰 원판이 작은 원판 위에 있으면 안됨 Figure 2.11: 하노이 탑 문제 Solution 원판의 크기가 제일 작은 것 부터 큰 것 까지 각각 1, 2, 3 번을 부여 했을 때 1 번 원판을 봉 A에서 C로 옮김 (A \\(\\rightarrow\\) C) 2 번 원판을 봉 A에서 B로 옮김 (A \\(\\rightarrow\\) B) 1 번 원판을 봉 C에서 B로 옮김 (C \\(\\rightarrow\\) B) 3 번 원판을 봉 A에서 C로 옮김 (A \\(\\rightarrow\\) C) 1 번 원판을 봉 B에서 A로 옮김 (B \\(\\rightarrow\\) A) 2 번 원판을 봉 B에서 C로 옮김 (B \\(\\rightarrow\\) C) 1 번 원판을 봉 A에서 C로 옮김 (A \\(\\rightarrow\\) C) 원판이 3개인 경우 총 7번의 이동이 필요 \\(\\rightarrow\\) \\(n\\)개의 원판이 있을 경우 \\(2^n - 1\\) 번의 이동이 필요 Figure 2.12: 하노이 탑 문제 알고리즘 구현 move_hanoi &lt;- function(n, from, to, via) { if (n == 1) { print(sprintf(&quot;%d 번 원판을 %s 에서 %s 로 이동&quot;, 1, from, to)) } else { move_hanoi(n - 1, from, via, to) print(sprintf(&quot;%d 번 원판을 %s 에서 %s 로 이동&quot;, n, from, to)) move_hanoi(n - 1, via, to, from) } } move_hanoi(3, &quot;A&quot;, &quot;C&quot;, &quot;B&quot;) [1] &quot;1 번 원판을 A 에서 C 로 이동&quot; [1] &quot;2 번 원판을 A 에서 B 로 이동&quot; [1] &quot;1 번 원판을 C 에서 B 로 이동&quot; [1] &quot;3 번 원판을 A 에서 C 로 이동&quot; [1] &quot;1 번 원판을 B 에서 A 로 이동&quot; [1] &quot;2 번 원판을 B 에서 C 로 이동&quot; [1] &quot;1 번 원판을 A 에서 C 로 이동&quot; move_hanoi(4, &quot;A&quot;, &quot;C&quot;, &quot;B&quot;) [1] &quot;1 번 원판을 A 에서 B 로 이동&quot; [1] &quot;2 번 원판을 A 에서 C 로 이동&quot; [1] &quot;1 번 원판을 B 에서 C 로 이동&quot; [1] &quot;3 번 원판을 A 에서 B 로 이동&quot; [1] &quot;1 번 원판을 C 에서 A 로 이동&quot; [1] &quot;2 번 원판을 C 에서 B 로 이동&quot; [1] &quot;1 번 원판을 A 에서 B 로 이동&quot; [1] &quot;4 번 원판을 A 에서 C 로 이동&quot; [1] &quot;1 번 원판을 B 에서 C 로 이동&quot; [1] &quot;2 번 원판을 B 에서 A 로 이동&quot; [1] &quot;1 번 원판을 C 에서 A 로 이동&quot; [1] &quot;3 번 원판을 B 에서 C 로 이동&quot; [1] &quot;1 번 원판을 A 에서 B 로 이동&quot; [1] &quot;2 번 원판을 A 에서 C 로 이동&quot; [1] &quot;1 번 원판을 B 에서 C 로 이동&quot; 숙제2: 하노이 탑 문제의 어느 부분을 재귀함수로 나타낼 수 있는지를 명확히 기술하고, 위 함수의 실행 원리를 설명 또는 도식화 하시오. 제출일: 2020년 11월 6일 금요일 23:59분 까지 제출방법: R markdown으로 작성한 문서와 Rmd 파일을 ’학번-이름.zip’으로 압축 후 제출 "],
["Simulation.html", "3 시뮬레이션", " 3 시뮬레이션 Sketch 시뮬레이션이 뭐지? 통계학에서 시뮬레이션이 왜 필요할까? 중요한 기초통계 이론을 눈으로 확인할 수 있을까? "],
["시뮬레이션모의실험의-의미.html", "3.1 시뮬레이션(모의실험)의 의미", " 3.1 시뮬레이션(모의실험)의 의미 알반적 의미 현실세계에서는 시간 및 비용 등의 문제로 실현하기 어렵거나 불가능한 시스템을 모형을 통해 실제 시스템을 모사함으로써 현상에 대한 문제를 이해하고자 하는 목적으로 고안한 일련의 방법 시뮬레이션의 활용 사례 군사 모의실험 비행 모의실험 선거 모의실험 민방위 훈련 … 통계적 모의실험(statistical or stochastic simulation) 통계학의 표본이론과 확률론에 근간을 두고 난수(random number)와 임의표본(random sample)을 이용해 어떤 결과나 문제의 해를 근사해 실제 이론으로 도출한 해와 비교함. 이러한 형태의 모의실험 방법을 몬테칼로 시뮬레이션(Monte Carlo simulation)이라고 함. 통계적 모의실험에 Monte carlo 라는 명칭이 붙게된 계기는 2차 세계대전 당시 미국의 원자폭탄 개발계획인 Manhattan 프로젝트에서 중성자의 특성을 연구하기 위한 모의실험의 명칭에 모나코의 유명한 도박 도시 Monte Carlo 이름을 붙힌 것에서 유래함. 통계적 모형은 결국 수학적으로 데이터가 어떻게 생성되었는가를 의미함. “모형을 시뮬레이션 한다” = 단계적으로 “데이터 처럼 보이는 것”을 생성하기 위해 모형을 적용 통계적 시뮬레이션 결과는 동일한 초기값에서 시작하더라도 동일한 결과를 보장하지 않음 예시: \\(X_1 \\sim \\mathcal{N}(3, 2^2)\\), \\(X_2 \\sim \\mathcal{N}(5, 3^2)\\) 이고, \\(X \\perp \\!\\!\\! \\perp Y\\) 일때 \\(X_3 = X_1 + 2X_2\\) 의 분포는? \\(X3 \\sim \\mathcal{N}(3 + 5, 2^2 + 4\\times 3^2) = \\mathcal{N}(8, 40)\\) set.seed(10000) x1 &lt;- rnorm(10000, 3, 2) x2 &lt;- rnorm(10000, 5, 3) x3 &lt;- x1 + 2*x2 mean(x3); var(x3) [1] 13.0817 [1] 39.87758 통계적 모의실험의 특징 특정 분포를 따르는 확률변수의 관찰값이 필요 반복적으로 수많은 난수를 생성해야 하기 때문에 컴퓨터의 사용이 필수적 기본적으로 통계학의 가장 기본적 개념인 대수의 법칙(law of the large number)을 활용 통계적 모의실험을 하는 방법 통계적(확률) 모형은 보통 한 변수(\\(X\\))가 주어졌을 때 다른 변수(\\(Y\\))에 대한 조건부 분포임. 대표적인 예: 단순선형회귀모형(simple linear regression model) \\[ \\begin{eqnarray} X &amp; \\sim &amp; \\mathcal{N}(\\mu_x, \\sigma_1^2) \\\\ Y|X &amp; \\sim &amp; \\mathcal{N}(\\beta_0 + \\beta_1X, \\sigma_2^2) \\end{eqnarray} \\] - 위 식에서 우변에 주어진 확률변수를 생성하는 방법을 알고 있다면 위 회귀모형에 대한 시뮬레이션 가능 \\(\\rightarrow\\) 모든 종류의 확률 모형에 대한 시뮬레이션의 일반적 전략임(통계 프로그래밍 언어 기말고사 마지막 문제 상기!!) 통계적 모의실험(시뮬레이션) = 확률변수의 생성문제 "],
["통계-시뮬레이션에-활용되는-수학-함수-및-분포-함수.html", "3.2 통계 시뮬레이션에 활용되는 수학 함수 및 분포 함수", " 3.2 통계 시뮬레이션에 활용되는 수학 함수 및 분포 함수 3.2.1 수학함수 R은 광범위한 수학 함수를 내장하고 있고 다음 열거한 함수 목록은 그 일부임 exp(): 지수(e)를 밑으로 하는 지수 함수 log(): 자연 로그 함수 log10(): 10을 밑으로 하는 로그 sqrt(): 제곱근 abs(): 절대값 sin(), cos(), tan() … : 삼각함수 min(), max(): 벡터 내 최솟값과 최댓값 반환 which.min(), which.max(): 벡터 내 최댓값과 최솟값에 대한 인덱스 반환 sum(), prod(): 벡터 원소들의 합과 곱 결과 반환 cumsum(), cumprod(): 백터 원소들의 누적합과 누적곱 round(), floor(), ceiling(): 수치형 값의 반올림, 내림, 올림 factorial(): 팩토리얼 함수 \\(n!\\) choose(): 조합 함수 (\\(_n C_r = \\frac{n!}{r!(n-r)!}\\)) 확장예제1: 확률계산 \\(P_i\\): \\(n\\) 개의 독립적인 사건이 있고 \\(i\\) 번째 사건이 발생할 확률 \\(n = 3\\) 일 때, 각 사건의 이름을 각각 A, B, C 라고 할 때 이 중 사건 하나가 발생할 확률 P(사건 하나가 발생할 확률) = P(A가 일어나고 B와 C가 일어나지 않을 확률) + P(A가 일어나지 않고 B가 일어나고 C가 일어나지 않을 확률) + P(A, B가 일어나지 않고 C만 일어날 확률) 여기서 P(A가 일어나고 B와 C가 일어나지 않을 확률) = \\(P_A(1-P_B)(1-P_C)\\) \\(\\rightarrow\\) 나머지도 마찬가지임 일반화 하면 \\[ \\sum_{i=1}^{n} P_i(1-P_1)(1-P_2)\\cdots (1-P_{i-1})(1-P_{i+1})\\cdots (1-P_{n}) \\] 구현 함수 # 벡터 p에서 p_i 계산 함수 probability_i &lt;- function(p) { notp &lt;- 1 - p tot &lt;- 0 for (i in 1:length(p)) tot &lt;- tot + p[i] * prod(notp[-i]) return(tot) } # test set.seed(3) p &lt;- runif(3, 0, 1) # 0-1 사이 값 3개를 균일분포로부터 추출 probability_i(p) [1] 0.4947463 확장예제2: 누적합, 누적곱 # cumsum, cumprod 함수 사용 예시 x &lt;- c(2, 4, 1, 3, 7, 8) cumsum(x); cumprod(x) [1] 2 6 7 10 17 25 [1] 2 8 8 24 168 1344 확장예제3: 최솟값, 최댓값 # which.min, which.max 사용 예시 set.seed(100) x &lt;- sample(1:100, 100) idx_min &lt;- which.min(x) x[idx_min] [1] 1 idx_max &lt;- which.max(x) x[idx_max] [1] 100 # min(), max(), pmin(), pmax() 비교 set.seed(5) x &lt;- runif(5, 2, 4) y &lt;- runif(5, 2, 4) z &lt;- cbind(x, y) min(z); max(z) # z의 전체 값 중 최솟값과 최댓값 반환 [1] 2.2093 [1] 3.913 pmin(z); pmax(z) # 아무 값을 반환하지 않음 x y [1,] 2.400429 3.402115 [2,] 3.370437 3.055920 [3,] 3.833752 3.615870 [4,] 2.568799 3.913000 [5,] 2.209300 2.220906 x y [1,] 2.400429 3.402115 [2,] 3.370437 3.055920 [3,] 3.833752 3.615870 [4,] 2.568799 3.913000 [5,] 2.209300 2.220906 # 두 열을 비교해 각 행에서 최솟값, 최댓값을 반환 pmin(z[, 1], z[, 2]) [1] 2.400429 3.055920 3.615870 2.568799 2.209300 pmax(z[, 1], z[, 2]) [1] 3.402115 3.370437 3.833752 3.913000 2.220906 확장예제4: 미분/적분 문자의 미분 및 수치 적분 가능 # 도함수 구하기 ## D() 함수 사용 dx &lt;- D(expression(exp(x^2)), &quot;x&quot;) # exp(x^2)을 x에 대해서 1차 미분한 도함수 set.seed(3) x &lt;- runif(3, 1, 2) eval(dx) # 위 입력한 x에 대한 도함수 값 출력 [1] 9.141245 94.842390 18.856751 ## deriv() 함수 사용 grad &lt;- D(expression(x*sin(x)), &quot;x&quot;) # 도함수를 R의 function으로 바로 반환 가능 dx2 &lt;- deriv(expression(x*sin(x)), &quot;x&quot;, function.arg = TRUE) dx2(x) [1] 1.074580 1.757109 1.361092 attr(,&quot;gradient&quot;) x [1,] 1.3778035 [2,] 0.5482219 [3,] 1.2386966 # 수치 적분 ## integrate() 함수 사용 ## 주어진 함수의 적분식을 구한 후, 입력 구간에 대한 적분값 계산 integrate(f = function(x) x^2, lower = 0, upper = 1) 0.3333333 with absolute error &lt; 3.7e-15 확장예제 응용: Newton-Raphson method 임의의 함수 \\(f(x)\\)가 주어졌을 때 \\(f(x) = 0\\) (\\(f(x)\\)의 해)를 만족하는 \\(x\\)를 반복적인 수치계산을 통해 찾는 방법 Newton-Raphson (N-R) 방법 적용 시 \\(f(x)\\)의 만족 조건 \\(x\\)의 특정 범위 내에서 \\(f(x) = 0\\)를 만족하는 유일한 실수값 존재 \\(f(x)\\)는 미분 가능한 함수 Newton-Raphson 알고리즘 예시 N-R 알고리즘(스케치) step 1: 초기치 \\(x_{old}\\)를 설정 step 2: \\(x_{old}\\)에서 \\(f(x_{old})\\) 값 계산 step 3: \\(x_{old}\\)에서 접선의 기울기(미분계수) \\(f&#39;(x_{old})\\) 계산 step 4: \\(f&#39;(x_{old})\\)의 접선이 \\(x\\)축과 만나는 점을 새로운 값 \\(x_{new}\\)로 업데이트 \\[ x_{new} = x_{old} - \\frac{f(x_{old})}{f&#39;(x_{old})} \\] step 5: 일정 조건을 만족할 때 까지 step 1 ~ step 4 반복 step 4에서 초기값 \\(x_0\\)이 주어졌을 때 \\(f(x_0)\\)의 접선은 \\(f&#39;(x_0)\\) 이고 \\((x_0, f(x_0))\\)를 통과하므로 접선의 식은 아래와 같음 \\[ f(x) = f&#39;(x_0)(x - x_0) + f(x_0) \\] \\(f(x) = 0\\) 일때 \\(x\\)의 값은 \\[ x = x_0 -\\frac{f(x_0)}{f&#39;(x_0)} \\] - 따라서 다음 단계에서 해의 근사치 \\(x_{1} = x_0 - f(x_0)/f&#39;(x_0)\\) 이고, 이를 조금 더 일반화 하면, \\[ x_{n+1} = x_n - \\frac{f(x_n)}{f&#39;(x_n)} \\] 위 식은 테일러 전개(Taylor expansion)를 통해 도출 가능(한 번 생각해 볼 것!!) N-R 알고리즘의 특징 현재 \\(x_{old}\\) 또는 \\(x_{n}\\)이 0을 만족할 경우, 더 이상 다음 단계로 가지 않음. 현재 함수값이 0에서 멀리 떨어져 있을수록 다음 스텝이 커지고, 미분계수의 절대값이 클수록 다음 스텝이 작아짐 미분계수의 절대값이 크다 \\(\\rightarrow\\) \\(x_n\\)을 조금만 움직여도 함수값이 크게 변한다는 의미 따라서 미분계수의 값을 다음 스텝에 반영해야 함. 다음 \\(x_{new}\\)의 방향은 \\(f(x_{old})/f&#39;(x_{old})\\) 부호와 반대방향으로 결정 수렴속도가 빠르지만 초기값에 따라 알고리즘의 성능이 달라짐 \\(f&#39;(x)\\)를 반복적으로 계산해야 하고, 경우에 따라 \\(f&#39;(x) = 0\\)이면 반복식 계산이 불가 반복 종료 조건 처음 설정한 최대 반복 횟수를 넘었을 때 더 이상 \\(x\\)의 값이 움직이지 않는다고 판단되었을 경우 함수의 값이 충분히 0에 가까워 졌을 경우 N-R 알고리즘 구현 알고리즘에 입력되어야 할 변수 초기값과 해를 찾을 범위 지정 \\(\\rightarrow\\) 만약 초기값이 해당 범위를 벗어난 값이 입력되었다면 함수 종료 함수 반복횟수 0과 충분히 가까운 상수(종료 시 필요) \\(\\rightarrow\\) tol 함수 내부 또는 함수 외부에서 1차 미분 함수가 요구 함수 인수로 입력 vs. 함수 내부에서 도함수 계산? 도함수 계산 시 위 예제에서 사용한 R 내장 함수 사용 vs. 미분식 사용? \\[ \\lim_{d \\rightarrow 0} \\frac{f(x + d) - f(x)}{d} \\] 반복 종료조건에 도달할 때 까지 반복이 필요 \\(\\rightarrow\\) while 문 사용 반복 조건: 반복이 최대 반복수보다 작고 \\(|f(x_{new})|\\) 값이 tol 값보다 클 때 까지 newton_raphson &lt;- function(FUN, # 함수 x0 = 1, # 초기값 max_iters = 5000, # 최대 반복 횟수 tol = 1.0e-9, range = c(-Inf, Inf), ...) { iters &lt;- 1; grads &lt;- deriv(as.expression(body(FUN)), &quot;x&quot;, function.arg = TRUE) # grads 반환값 중 &quot;gradient&quot; 값 = f&#39;(x0) gap &lt;- x0 - FUN(x0)/attr(grads(x0), &quot;gradient&quot;) while(iters &lt; max_iters &amp; abs(gap) &gt; tol) { # x_new 계산 x_new &lt;- x0 - FUN(x0)/attr(grads(x0), &quot;gradient&quot;) gap &lt;- FUN(x_new) # x_new 가 범위를 벗어난 경우 처리 if (x_new &lt;= range[1]) x_new &lt;- range[1] if (x_new &gt;= range[2]) x_new &lt;- range[2] iters &lt;- iters + 1 x0 &lt;- x_new # 초기값 업데이트 } if (x_new == range[1] | x_new == range[2]) warning(&quot;마지막 점이 x 범위의 경계선 상에 있습니다.&quot;) if (iters &gt; max_iters) warning(&quot;최대 반복 때 까지 해를 찾지 못했습니다.&quot;) cat(&quot;x 가&quot;, x_new, &quot;일 때 함수값:&quot;, FUN(x_new), &quot;\\n&quot;) return(list(solution = x_new, iteration = iters)) } ## test: 위 동영상과 동일한 해를 갖는지 확인 f &lt;- function(x) 5 * x^3 - 7 * x^2 - 40 * x + 100 newton_raphson(FUN = f, x0 = 1, range = c(-10, 10)) -&gt; sols x 가 -3.151719 일 때 함수값: -3.547029e-11 Quiz: newton_raphson() 함수에서 1차 미분 도함수를 구하는 스크립트를 아래 일반 미분공식으로 변환한 함수 newton_raphson_gen()를 작성하고, 해당 함수가 정상적으로 작동하는지 확인하시오. \\[ \\lim_{d \\rightarrow 0} \\frac{f(x + d) - f(x)}{d} \\] 문제 제출이 필수는 아니지만 제출 시 가산점이 있음. 제출기간: 2020년 11월 4일 제출방법: 작성 스크립트를 학번-이름.R로 저장 후 E-mail로 제출 3.2.2 통계 분포 함수 R은 현존하는 대부분의 통계 확률 분포 함수를 제공하고 접두사 + 분포이름 형태의 함수명을 갖고 있으며, 보통 다음과 같은 접두사를 통해 분포 함수 생성 d: 밀도(density)의 약어로 확률 밀도함수(probability density function, pdf) 또는 이산형 분포의 확률 질량 함수(probability mass function, pmf) q: 분위수(quantile)의 약어로 상위 %에 해당하는 \\(x\\) 값을 반환 p: 누적분포함수(cumulative density function, cdf) r: 특정 분포로부터 난수(확률변수) 생성 예: dnorm(), qnorm(), pnorm(), rnorm() 은 정규분포 관련 함수임 Table 3.1: 일반적인 R 통계 분포함수(일부 제시) Distribution Density/Mass function R pdf R cdf R quantile RV generation Parameter 균일분포 \\(\\frac{1}{b -a},~\\mathrm{for}~x \\in [a, b]\\) dunif punif qunif runif min (a), max (b) 지수분포 \\(\\lambda \\exp{(-\\lambda x)}\\) dexp pexp qexp rexp rate (\\(\\lambda\\)) 정규분포 \\(\\frac{1}{\\sqrt{2\\pi}\\sigma}\\exp \\left\\{-\\frac{(x - \\mu)^2}{2\\sigma^2} \\right \\}\\) dnorm pnorm qnorm rnorm mean (\\(\\mu\\)), sd (\\(\\sigma\\)) \\(\\chi^2\\) 분포 \\(\\frac{1}{\\Gamma(\\nu/2)2^{\\nu/2}}x^{(\\nu/2) - 1}e^{(-x/2)}\\) dchisq pchisq qchisq rchisq df (\\(\\nu\\)) \\(t\\) 분포 \\(\\frac{\\Gamma(\\frac{\\nu + 1}{2})}{\\Gamma{(\\frac{\\nu}{2}})}\\frac{1}{\\sqrt{\\nu\\pi}}\\frac{1}{(1 + x^2/\\nu)^{(\\nu + 1)/2}}\\) dt pt qt rt df (\\(\\nu\\)) 이항분포 \\({n \\choose x} p^x (1 - p)^{n - x}\\) dbinom pbinom qbinom rbinom size (\\(n\\)), prob (\\(p\\)) 포아송 분포 \\(\\frac{e^{-\\lambda}\\lambda^x}{x!}\\) dpois ppois qpois rpois lambda (\\(\\lambda\\)) 예제: 확률 분포 함수 ## 카이제곱분포 x &lt;- seq(0, 30, by = 0.1) y &lt;- dchisq(x, df = 3) # 자유도가 3인 카이제곱분포 밀도 함수 plot(x, y, type = &quot;l&quot;, bty = &quot;n&quot;, xlab = &quot;&quot;, ylab = &quot;&quot;, main = expression(paste(&quot;PDF of &quot;, ~chi^2, &quot; distribution&quot;)), lwd = 2, cex.main = 2) # P(5 &lt; V &lt; 10) pchisq(10, df = 3) - pchisq(5, df = 3) [1] 0.153231 ## 그림에 표현 idx &lt;- x &gt;= 5 &amp; x &lt;= 10 polygon(c(5, x[idx], 10), c(0, y[idx], 0), col = &quot;blue&quot;, border = &quot;blue&quot;) abline(h = 0, col = &quot;darkgray&quot;) text(x = 10, y = 0.05, cex = 2, bquote(P({5 &lt;= V} &lt;= 10 ) == .(sprintf(&quot;%.3f&quot;, pchisq(10, df = 3) - pchisq(5, df = 3)))), adj = 0) # 분위수 qchisq(pchisq(10, df = 3), df = 3) [1] 10 # 난수 생성 v &lt;- rchisq(1000, df = 3) mean(v) # 카이제곱분포의 평균은 이론적으로 자유도 값과 같음 [1] 2.994 난수 생성의 방법 난수(random number): 어떤 방법으로도 예측될 수 없는 일련의 수열(숫자) 통계적 의미로 난수는 특정 범위(보통 0에서 1 사이)의 균일분포(uniform distribution)에서 추출된 표본들의 관찰값으로, 임의의 확률분포(예: 정규분포, 지수분포 등)를 따르는 확률변수와는 구별됨. 보통 확률 변수는 균일분포를 따르는 확률변수로부터 적절한 변환을 통해 얻을 수 있음. 난수를 발생하려면 어떤 알고리즘이 필요하고 알고리즘은 일정한 규칙에 의해 구현되기 때문에 컴퓨터로 발생한 난수는 엄밀한 의미에서 난수가 아님. 이를 구별하기 위해 보통 컴퓨터로 생성한 난수를 유사난수(pseudo-random number)라 칭함 난수 생성을 위한 알고리즘으로 합동법(congruential method), 역변환법(inversion method) 등이 널리 사용됨 통계 시뮬레이션에서는 특히 변수변환방법(transformation)을 통해 확률변수 생성 \\(Z \\sim \\mathcal{N}(0, 1)\\)일 때 \\(\\sigma Z + \\mu \\sim \\mathcal{N}(\\mu, \\sigma^2)\\) \\(Z^2 \\sim \\chi^2(1)\\) Figure 3.1: 확률분포의 관계도(http://www.math.wm.edu/~leemis/chart/UDR/UDR.html) "],
["references.html", "References", " References "]
]
