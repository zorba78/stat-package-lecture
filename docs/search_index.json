[
["index.html", "통계 패키지 활용 2020년도 2학기 충남대학교 정보통계학과 강의 노트 Course Overview", " 통계 패키지 활용 2020년도 2학기 충남대학교 정보통계학과 강의 노트 한국한의학연구원, 구본초 2020-12-02 Course Overview R을 이용한 데이터 분석 시 CRAN에 등록된 패키지를 활용한다. 적절한 패키지의 활용은 데이터 분석의 효율을 증대할 뿐 아니라 분석의 재현성을 향상할 수 있다. 본 강의는 지난학기에 학습한 통계프로그래밍언어 강의 내용의 연속선 상에서 진행할 예정이며, 해당 강의에서 학습한 내용들을 기반으로 데이터 분석 및 그 결과에 대한 보고서 작성, 그리고 R 생성 파일에 대한 버전 관리 방법에 대해 알아보고자 한다. 교과 목표 R Markdown의 이해와 활용 R 프로그래밍 능력 향상 및 통계 시뮬레이션의 이해 R을 이용한 데이터 분석 실습 R을 이용한 기초 통계분석 텍스트 마이닝에 대한 이해 Shiny, plotly 를 활용한 동적 문서 및 시각화 이해 RStudio + Github을 이용한 버전관리 이해 선수과목 통계학 개론 통계 프로그래밍 언어 수업 방법 강의: 30 % 실험/실습: 70 % 평가방법 중간고사: 35 % 기말고사: 35 % 출석: 10 % 과제: 20 % 교재 별도의 교재 없이 본 강의 노트로 수업을 진행할 예정이며, 수업의 이해도 향상을 위해 아래 소개할 도서 및 웹 문서 등을 참고할 것을 권장함. 참고문헌 R Markdown Cookbook (Xie, Dervieux, and Riederer 2020) bookdown: Authoring Books and Technical Documents with R Markdown (Xie 2016) R과 knitr를 활용한 데이터 연동형 문서 만들기 (고석범 2014) R for data science (Wickham and Grolemund 2016) Statistical Computing with R (Rizzo 2019) R programming for data science (Peng 2016) Text mining with R (Silge and Robinson 2017) References "],
["r-markdown.html", "1 R Markdown", " 1 R Markdown Sketch 동일한 문서에 코드, 결과, 텍스트가 동시에 있을 수 있을까? 만약 결과와 도표가 자동으로 생성된 경우 데이터가 변경 되더라도 자동으로 문서를 업데이트 할 수 있을까? 최종 완료한 문서가 미래에도 열 수 있을까? 이러한 모든 과정이 매우 쉽다면?? Figure 1.1: R markdown 세계(https://ulyngs.github.io/rmarkdown-workshop-2019 에서 발췌) "],
["r-markdown의-구성.html", "1.1 R Markdown의 구성", " 1.1 R Markdown의 구성 본 절의 내용 중 일부는 지난 학기 강의노트 1.7절과 중복되거나 재구성한 내용이 포함됨. R Markdown은 R 코드와 분석 결과(표, 그림 등)을 포함한 문서 또는 컨텐츠를 제작하는 도구로 일반적으로 아래 열거한 형태로 활용함 문서 또는 논문(pdf, html, docx) 프리젠테이션(pdf, html, pptx) 웹 또는 블로그 재현가능(reproducible)한 분석 및 연구1 가능 신뢰성 있는 문서 작성 Copy &amp; paste를 하지 않고 효율적 작업 가능 R 마크다운 파일 = .Rmd 확장자를 가진 일반 텍스트 파일 --- title: &quot;Untitled.Rmd&quot; date: &quot;2020-09-11&quot; output: html_document --- ```{r setup, include=FALSE} knitr::opts_chunk$set(echo = TRUE) ``` ## R Markdown Markdown은 HTML, PDF 및 MS Word 문서를 작성하 기위한 간단한 형식 지정 구문입니다. R Markdown 사용에 대한 자세한 내용은 &lt;http://rmarkdown.rstudio.com&gt;을 참조하십시오. **Knit** 버튼을 클릭하면 두 가지를 모두 포함하는 문서가 생성됩니다. 문서에 포함 된 R 코드 청크의 출력 내용뿐 아니라 다음과 같이 R 코드 청크를 포함 할 수 있습니다. ```{r cars} summary(cars) ``` ## Including Plots You can also embed plots, for example: ```{r pressure, echo=FALSE} plot(pressure) ``` `echo = FALSE` 매개 변수가 코드 청크에 추가되었습니다. 플롯을 생성 한 R 코드의 인쇄를 방지합니다. 위 R Markdown 문서는 아래 그림과 같이 YAML, Markdown 텍스트, Code Chunk 세 부분으로 구성됨. Figure 1.2: R markdown structure YAML (YAML Ain’t Markup Language) R Markdown 문서의 metadata로 문서의 맨 처음에 항상 포함(header)되어야 함. R Markdown 문서의 최종 출력 형태(html, pdf, docx, pptx 등), 제목, 저자, 날짜 등의 정보 등을 포함 최종 문서 생성 과정 Rmd 파일을 knitr 을 통해 .md 파일로 변환 후 pandoc 이라는 문서 변환기를 통해 원하는 문서 포맷으로 출력 Figure 1.3: R Markdown의 최종 결과물 산출과정(http://applied-r.com/project-reporting-template/) 과학적 연구의 결과물을 오픈소스로 내놓고 누구라도 검증 가능↩︎ "],
["r-markdown-문서-시작하기.html", "1.2 R Markdown 문서 시작하기", " 1.2 R Markdown 문서 시작하기 R Markdown 문서 생성: [File] -&gt; [New File] -&gt; [R Markdown..]을 선택 RStudio를 처음 설치하고 위와 같이 진행할 경우 아래와 같은 패키지 설치 여부를 묻는 팝업 창이 나타남. 패키지 설치 여부에 [Yes]를 클릭하면 R Markdown 문서 생성을 위해 필요한 패키지들이 자동으로 설치 설치 완료 후 R Markdown으로 생성할 최종 문서 유형 선택 질의 창이 나타남. 아래 창에서 제목(Title)과 저자(Author) 이름 입력 후 [OK] 버튼 클릭(Document, html 문서 선택) 아래 그림과 같이 새로운 문서 창이 생성되고 test.Rmd 파일로 저장2 문서 상단에 Knit 아이콘을 클릭 후 Knit to HTML 클릭 또는 문서 아무 곳에 커서를 위치하고 단축키 [Ctrl] + [Shift] + [K] 입력 knitr + R Markdown + pandoc \\(\\rightarrow\\) html 파일 생성 결과 Figure 1.4: test.html 문서 화면(저장 폴더 내 test.html을 크롬 브라우저로 실행) [RStudio 프로젝트]에서 생성한 폴더 내에 파일 저장↩︎ "],
["r-markdown-기본-문법syntax.html", "1.3 R Markdown 기본 문법(syntax)", " 1.3 R Markdown 기본 문법(syntax) R Markdown의 기본 문법은 Rstudio 풀다운 메뉴 [Help] \\(\\rightarrow\\) [Markdown Quick Reference] 에서 확인 가능 1.3.1 텍스트 문법 강조(emphasis) 이텔릭체: *italic1*, _italic2_ \\(\\rightarrow\\) italic1, italic2 볼드(굵은)체: *bold1*, __bold2__ \\(\\rightarrow\\) bold1, bold2 Inline code `inline code` \\(\\rightarrow\\) inline code 아래/위 첨자(sub/superscript) subscript~2~ \\(\\rightarrow\\) subscript2 superscript^2^ \\(\\rightarrow\\) superscript2 삭제표시(strike through) ~~strikethrough~~ \\(\\rightarrow\\) strikethrough 생략표시(ellipsis) ... \\(\\rightarrow\\) … 긴/짧은 대쉬(en/emd-dash) 짧은 대쉬: -- \\(\\rightarrow\\) – 긴 대쉬: --- \\(\\rightarrow\\) — 특수문자 탈출 지정자 \\*, \\_, \\~, \\\\ \\(\\rightarrow\\) *, _, ~, \\ 하이퍼링크 -[text](link) \\(\\rightarrow\\) 통계프로그래밍언어 외부그림 삽입 ![image title](path/to/image): ![장난꾸러기](figures/son-02.jpg) 장난꾸러기 강제 줄바꿈(line breaks) 하나의 줄에서 공백(space) 두 개 이상 또는 백슬레시(\\) 입력 후 [Enter] End a line with two spaces to start a new paragraph End a line with two spaces to start a new paragraph End a line with two spaces to start\\ a new paragraph End a line with two spaces to start a new paragraph 각주(footnote) A footnote^[주석내용] \\(\\rightarrow\\) A footnote3 주석(comment) &lt;!-- this is a comment that won't be shown --&gt; \\(\\rightarrow\\) RStudio에서 단축키 [Ctrl] + [Shift] + [C]를 통해 전체 line 에 대해 주석처리 가능 1.3.2 Block-level elements 장/절(header) # Header 1 (chapter, 장) ## Header 2 (section, 절) ### Header 3 (subsection, 관) 목록(list) 비순서(unordered) 목록: -, *, + 중 어느 하나로 입력 가능 - one item * two item + sub-item 1 + sub-item 2 - subsub-item 1 - subsub-item 2 one item two item sub-item 1 sub-item 2 subsub-item 1 subsub-item 2 순서(ordered) 목록: 비순서 목록의 기호 대신 숫자로 리스트 생성 1. the first item - sub-item 1 2. the second item 3. the third item the first item sub-item 1 the second item the third item 같은 숫자로 적어도 순서대로 목록 생성 1. the first item - sub-item 1 1. the second item 1. the third item the first item sub-item 1 the second item the third item 인용구(blockquote): &gt;로 시작 &gt; &quot;There are three kinds of lies: lies, damn lies, and statistics&quot; &gt; &gt; --- Benjamin Disraeli “There are three kinds of lies: lies, damn lies, and statistics” — Benjamin Disraeli 1.3.3 수식표현(math expression) 줄 안에 수식 입력 시 $수식표현$ 으로 입력 수식 display style (보통 교과서에 정리 및 정의에 기술된 수식들) 적용 시 $$ ~ $$ 안에 수식 입력 수식 표현은 LaTeX 의 수식 표현을 동일하게 준용(https://www.latex4technics.com/, https://latex.codecogs.com/legacy/eqneditor/editor.php 에서 수식 입력 명령어 학습 가능) LaTeX 수식 입력 코드는 예시 \\[ P(X = x) = f(x; n, p) = {n \\choose x} p^x (1-p)^{n-x} \\] Inline equation: $P(X = x) = f(x; n, p) = {n \\choose x} p^x (1-p)^{n-x}$ \\(\\rightarrow\\) \\(P(X = x) = f(x; n, p) = {n \\choose x} p^x (1-p)^{n-x}\\) Math block: $$P(X = x) = f(x; n, p) = {n \\choose x} p^x (1-p)^{n-x}$$ \\[P(X = x) = f(x; n, p) = {n \\choose x} p^x (1-p)^{n-x}\\] $ $ 또는 $$ $$ 안에 LaTeX에서 제공하는 수식 함수 사용 가능 $$\\begin{array}{ccc} x_{11} &amp; x_{12} &amp; x_{13}\\\\ x_{21} &amp; x_{22} &amp; x_{23} \\end{array}$$ \\[\\begin{array}{ccc} x_{11} &amp; x_{12} &amp; x_{13}\\\\ x_{21} &amp; x_{22} &amp; x_{23} \\end{array}\\] $$\\Theta = \\begin{pmatrix}\\alpha &amp; \\beta\\\\ \\gamma &amp; \\delta \\end{pmatrix}$$ \\[\\Theta = \\begin{pmatrix}\\alpha &amp; \\beta\\\\ \\gamma &amp; \\delta \\end{pmatrix}\\] $$\\begin{align} g(X_{n}) &amp;= g(\\theta)+g&#39;({\\tilde{\\theta}})(X_{n}-\\theta) \\notag \\\\ \\sqrt{n}[g(X_{n})-g(\\theta)] &amp;= g&#39;\\left({\\tilde{\\theta}}\\right) \\sqrt{n}[X_{n}-\\theta ] \\end{align}$$ \\[\\begin{aligned} g(X_{n}) &amp;= g(\\theta)+g&#39;({\\tilde{\\theta}})(X_{n}-\\theta) \\notag \\\\ \\sqrt{n}[g(X_{n})-g(\\theta)] &amp;= g&#39;\\left({\\tilde{\\theta}}\\right) \\sqrt{n}[X_{n}-\\theta ] \\end{aligned}\\] 주석내용↩︎ "],
["r-code-chunks.html", "1.4 R Code Chunks", " 1.4 R Code Chunks 실제 R code가 실행되는 부분임 Code chunk 실행 시 다양한 옵션 존재(본 강의에서는 몇 개의 옵션만 다룰 것이며, 더 자세한 내용은 https://yihui.org/knitr/options/ 또는 R Markdown 레퍼런스 가이드 참조 Code chunk는 ```{r}로 시작되며 r은 code 언어 이름을 나타냄. Code chunk는 ``` 로 종료 R Markdown 문서 작성 시 단축키 [Ctrl] + [Alt] + [I]를 입력하면 Chunk 입력창이 자동 생성됨 Code chunk의 옵션 조정을 통해 코드의 출력여부, 코드 출력 시 코드의 출력 형태, 코드의 결과물 출력 조정 가능 Figure 1.5: Chunk anatomy (https://ulyngs.github.io/rmarkdown-workshop-2019 에서 발췌) 자주 활용하는 chunk 옵션 코드 실행 관련 청크 Table 1.1: 코드 실행 관련 청크 Chunk 옵션 Default 설명 eval TRUE R 실행(코드 실행 결과)에 대응하는 결과 출력 여부 include TRUE 출력 문서에 코드 청크의 내용을 포함할지 여부 ```{r ex01-1, eval=TRUE} summary(iris) hist(iris$Sepal.Length) ``` ```{r ex01-2, eval=FALSE} summary(iris) hist(iris$Sepal.Length) ``` #청크 옵션 eval=TRUE summary(iris) Sepal.Length Sepal.Width Petal.Length Petal.Width Min. :4.300 Min. :2.000 Min. :1.000 Min. :0.100 1st Qu.:5.100 1st Qu.:2.800 1st Qu.:1.600 1st Qu.:0.300 Median :5.800 Median :3.000 Median :4.350 Median :1.300 Mean :5.843 Mean :3.057 Mean :3.758 Mean :1.199 3rd Qu.:6.400 3rd Qu.:3.300 3rd Qu.:5.100 3rd Qu.:1.800 Max. :7.900 Max. :4.400 Max. :6.900 Max. :2.500 Species setosa :50 versicolor:50 virginica :50 hist(iris$Sepal.Length) #청크 옵션 eval=FALSE summary(iris) hist(iris$Sepal.Length) 소스 코드 출력(텍스트) 결과 관련 청크 Table 1.2: 소스 코드 출력 결과 관련 청크 Chunk 옵션 Default 설명 echo TRUE R 실행 결과에 대응하는 코드 출력 여부 results markup 출력 결과 포맷 지정을 위한 옵션으로 추가적으로 3 가지 옵션 선택 가능: ‘hide’, ‘asis’, ‘hold’, ‘markup’ error TRUE 코드 또는 스크립트에 구문오류 메세지 출력 여부 message TRUE 코드로부터 생성된 메세지 출력 여부 warning TRUE 경고 메세지 출력 여부 echo: 코드 청크에 작성한 R-script 출력 여부 결정 echo = FALSE 이면 소스 코드 출력 없이 그림 결과만 출력 ```{r ex01-2, echo=TRUE} require(ggthemes) # ggtheme 패키지 불러오기 require(ggpubr) # ggpubr 패키지 불러오기 iris %&gt;% ggplot(aes(x = Sepal.Length, y = Petal.Width, color = Species)) + geom_point(size = 5) + theme_pubclean() + theme(axis.line = element_line(size = 0.8), legend.title = element_text(face = &quot;bold&quot;, size = 15), legend.text = element_text(face = &quot;bold&quot;, size = 12)) ``` ```{r ex01-3, echo=FALSE} require(ggthemes) # ggtheme 패키지 불러오기 require(ggpubr) # ggpubr 패키지 불러오기 iris %&gt;% ggplot(aes(x = Sepal.Length, y = Petal.Width, color = Species)) + geom_point(size = 5) + theme_pubclean() + theme(axis.line = element_line(size = 0.8), legend.title = element_text(face = &quot;bold&quot;, size = 15), legend.text = element_text(face = &quot;bold&quot;, size = 12)) ``` # echo = TRUE require(ggthemes) # ggtheme 패키지 불러오기 require(ggpubr) # ggpubr 패키지 불러오기 iris %&gt;% ggplot(aes(x = Sepal.Length, y = Petal.Width, color = Species)) + geom_point(size = 5) + theme_pubclean() + theme(axis.line = element_line(size = 0.8), legend.title = element_text(face = &quot;bold&quot;, size = 15), legend.text = element_text(face = &quot;bold&quot;, size = 12)) results: 코드의 텍스트 출력 결과 포맷 지정 markup (default): 코드 청크 내 스크립트의 출력 형태에 따라 텍스트 출력 결과를 mark-up asis: 변환하지 않은 원래 R 출력 결과 그대로(as is) 출력 hide: R 스크립트로 생성된 텍스트 출력을 보여주지 않음(warning, message 출력 예외) hold: 코드 청크로 생성된 모든 소스 및 출력을 단일 블록으로 축소 # results = &#39;markup&#39;인 경우 아래 텍스트를 mark-up # (이 경우 아래 텍스트는 ``` ``` 블럭 처리)한 결과를 md 파일로 전송 cat(&quot;I&#39;m raw **Markdown** content.\\n&quot;) I&#39;m raw **Markdown** content. Figure 1.6: 청크 옵션 results = ’markup’인 경우 rmd vs. md 파일 비교 # results = &#39;asis&#39; 인 경우 텍스트를 그대로 md 파일에 입력 cat(&quot;I&#39;m raw **Markdown** content.\\n&quot;) I’m raw Markdown content. Figure 1.7: 청크 옵션 results = ’asis’인 경우 rmd vs. md 파일 비교 # results = &#39;hide&#39; cat(&quot;I&#39;m raw **Markdown** content.\\n&quot;) # 텍스트 결과를 출력하지 않음 # results = &#39;hold&#39;가 아닌 경우 한 라인 별 출력 결과 생성 x &lt;- rnorm(10) x [1] -0.6824436 1.2206438 1.8970302 -0.3546418 -1.0174656 0.2019336 [7] -0.1719541 -0.6376793 0.0994186 -0.8738093 y &lt;- rnorm(10, 1, 2) y [1] 3.333933499 0.396847694 2.025672877 1.161125748 3.459372751 [6] 0.008239825 0.895658910 2.626167922 -0.524700955 3.881164116 x + y [1] 2.6514899 1.6174915 3.9227031 0.8064839 2.4419071 0.2101734 [7] 0.7237049 1.9884886 -0.4252824 3.0073548 # results = &#39;hold&#39;인 경우 코드 부분과 출력 부분이 따로 블록 처리 x &lt;- rnorm(10) x y &lt;- rnorm(10, 1, 2) y x + y [1] 1.32629535 0.71093174 0.02962478 -1.50705547 -0.44236260 -1.96655600 [7] 1.22277194 -0.18456550 -1.80179386 0.65696451 [1] 1.8125255 -0.1430960 4.6637336 -2.4015531 2.2949937 -2.6903537 [7] 0.5206064 1.7016025 -0.7295314 0.7653030 [1] 3.1388208 0.5678357 4.6933584 -3.9086086 1.8526311 -4.6569097 [7] 1.7433784 1.5170370 -2.5313252 1.4222675 error: 코드 청크 내 스크립트에 오류에 대한 보존 여부(stop()) 기본적으로 Rmarkdown 컴파일 시 error에 대한 옵션이 FALSE이기 때문에 스크립트(코드)에 오류가 포함되면 컴파일이 정지됨. error = TRUE 이면 오류 메세지를 포함한 텍스트 결과를 출력 3x &lt;- 3 x &lt;- 25 # 위 행이 구문 오류를 포함하고 있기 때문에 # 오류 이후의 코드는 실행되지 않음 x Error: &lt;text&gt;:1:2: 예상하지 못한 기호(symbol)입니다. 1: 3x ^ message/warning: 텍스트 출력물 중 경고(warning, warning() 함수의 출력 결과) 메세지 출력 여부 결정 # message = TRUE 인 경우 함수 message 출력 testit &lt;- function() { message(&quot;testing package startup messages&quot;) packageStartupMessage(&quot;initializing ...&quot;, appendLF = FALSE) Sys.sleep(1) packageStartupMessage(&quot; done&quot;) } # help(message) 예시 중 발췌 testit() testing package startup messages initializing ... done # message=FALSE -&gt; 메세지 출력하지 않음 testit() # 경고 메세지 출력 x &lt;- c(1, 2, &quot;new&quot;, 4:10) x &lt;- as.numeric(x) Warning: 강제형변환에 의해 생성된 NA 입니다 코드 서식 관련 청크 옵션 Table 1.3: 코드 서식 관련 청크 Chunk 옵션 Default 설명 comment TRUE 소스 코드 실행 출력의 각 줄 앞에 붙는 표시문자 출력 여부: 기본 값은 ‘##’ 임 highlight TRUE 구문 강조 여부 prompt FALSE R 프롬프트 출력 여부 tidy FALSE R 소스 코드 출력 정리 여부 comment: 텍스트 출력물에 주석 표시(default)를 함으로써 소스 코드와 출력 결과를 동시 선택과 복사를 가능(##는 주석 표시이기 때문에 실행되지 않음) 주석 표시를 제거하고 싶다면 comment = NA 또는 comment = '' # 디폴트 comment 사용 summary(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## Min. :4.300 Min. :2.000 Min. :1.000 Min. :0.100 ## 1st Qu.:5.100 1st Qu.:2.800 1st Qu.:1.600 1st Qu.:0.300 ## Median :5.800 Median :3.000 Median :4.350 Median :1.300 ## Mean :5.843 Mean :3.057 Mean :3.758 Mean :1.199 ## 3rd Qu.:6.400 3rd Qu.:3.300 3rd Qu.:5.100 3rd Qu.:1.800 ## Max. :7.900 Max. :4.400 Max. :6.900 Max. :2.500 ## Species ## setosa :50 ## versicolor:50 ## virginica :50 ## ## ## highlight: 구문 강조 표시 여부 highlight=FALSE 일 때 소스 코드 출력 결과 # highlight=FALSE iris %&gt;% ggplot(aes(x = Sepal.Length, y = Petal.Width, color = Species)) + geom_point(size = 5) + theme_pubclean() + theme(axis.line = element_line(size = 0.8), legend.title = element_text(face = &quot;bold&quot;, size = 15), legend.text = element_text(face = &quot;bold&quot;, size = 12)) prompt: R 콘솔 상 프롬프트 &gt;, + 출력 여부 &gt; # prompt = TRUE 인 경우 코드 출력 결과 &gt; require(ggthemes) # ggtheme 패키지 불러오기 &gt; require(ggpubr) # ggpubr 패키지 불러오기 &gt; iris %&gt;% + ggplot(aes(x = Sepal.Length, y = Petal.Width, color = Species)) + + geom_point(size = 5) + + theme_pubclean() + + theme(axis.line = element_line(size = 0.8), + legend.title = element_text(face = &quot;bold&quot;, size = 15), + legend.text = element_text(face = &quot;bold&quot;, size = 12)) tidy: 코드를 사용자가 지정(혹은 formatR::tidy_sorce() 함수에 초기값으로 지정된 코드 정리 값)한 줄 당 문자 길이 등을 반영해 코드를 정리 tidy=TRUE 인 경우 자동으로 줄 바꿈 &gt; # tidy = FALSE 인 경우 코드 출력 결과 &gt; require(ggthemes) # ggtheme 패키지 불러오기 &gt; require(ggpubr) # ggpubr 패키지 불러오기 &gt; iris %&gt;% ggplot(aes(x = Sepal.Length, y = Petal.Width, color = Species)) + geom_point(size = 5) + theme_pubclean() + theme(axis.line = element_line(size = 0.8), legend.title = element_text(face = &quot;bold&quot;, size = 15), legend.text = element_text(face = &quot;bold&quot;, size = 12)) &gt; # tidy = TRUE 인 경우 코드 출력 결과 &gt; require(ggthemes) # ggtheme 패키지 불러오기 &gt; require(ggpubr) # ggpubr 패키지 불러오기 &gt; iris %&gt;% ggplot(aes(x = Sepal.Length, y = Petal.Width, color = Species)) + geom_point(size = 5) + + theme_pubclean() + theme(axis.line = element_line(size = 0.8), legend.title = element_text(face = &quot;bold&quot;, + size = 15), legend.text = element_text(face = &quot;bold&quot;, size = 12)) 그림(plot) 출력 관련 청크 옵션 Table 1.4: Plot 출력 관련 청크 Chunk 옵션 Default 설명 fig.align default 최종 문서에 plot 정렬 방식 결정(center/left/right) fig.height/fig.width 7 그림 크기(단위: 인치) fig.cap NULL 그림 캡션(문자열 입력) dpi 72 dot per inche: 출력 그림 해상도 알아두면 좋은 청크 형태 Setup 청크 일반적으로 Rmarkdown 문서는 YAML 해더 뒤에 전역적 청크 옵션 지정과 R 패키지를 불러오는 것으로 시작 청크 옵션은 knitr::opts_chunk$set(청크 옵션 지정) 형태로 지정 가능 다음은 RStudio 에서 Rmd 문서 생성 시 맨 처음 나오는 코드 청크 예시임 ```{r ex01-2, include=FALSE} knitr::opts_chunk$set(echo = TRUE) ``` 일반적 활용 예시 ```{r option-init, include=FALSE} knitr::opts_chunk$set(root.dir = &#39;../..&#39;, # 프로젝트 폴더 지정 eval = TRUE, echo = FALSE, cache = FALSE, include = TRUE, tidy = TRUE, tidy.opts = list(blank=FALSE, width.cutoff=120), # 소스 출력길이 지정 message = FALSE, warning = FALSE, engine = &quot;R&quot;, # Chunks will always have R code, unless noted error = TRUE, fig.path=&quot;Figures/&quot;, # Set the figure options fig.align = &quot;center&quot;, fig.width = 7, fig.height = 7, fig.keep=&#39;all&#39;, fig.retina=2) ``` 이미지 불러오기 ```{r, fig.cap = &quot;Taj Mahal&quot;} knitr::include_graphics(&quot;figures/taj.JPG&quot;, dpi = NA) ``` Figure 1.8: Taj Mahal ```{r, fig.cap = &quot;Taj Mahal&quot;} cars %&gt;% ggplot(aes(x = speed, y = dist)) + geom_point(size = 5) + theme_tufte(base_size = 15) # ggtheme::theme_tufte() ``` R 생성 도표 포함 Figure 1.9: Scatterplot of the car dataset 테이블 삽입 가장 간단한 테이블은 knitr::kable() 함수를 통해 생성 가능 kable() 함수는 가장 단순한 형태의 표만 생성하기 때문에 복잡한 표를 만들기에는 한계가 존재함 이를 보완하기 위해 다음과 같은 패키지 활용 kableExtra: HTML 또는 LaTeX 용 표 생성 https://cran.r-project.org/web/packages/kableExtra/vignettes/awesome_table_in_html.html https://cran.r-project.org/web/packages/kableExtra/vignettes/awesome_table_in_pdf.pdf flextable + officer: HTML, 워드 문서 표 작성 https://davidgohel.github.io/flextable/ ```{r} knitr::kable(head(iris)) ``` Sepal.Length Sepal.Width Petal.Length Petal.Width Species 5.1 3.5 1.4 0.2 setosa 4.9 3.0 1.4 0.2 setosa 4.7 3.2 1.3 0.2 setosa 4.6 3.1 1.5 0.2 setosa 5.0 3.6 1.4 0.2 setosa 5.4 3.9 1.7 0.4 setosa "],
["inline-code.html", "1.5 인라인(inline) R 코드", " 1.5 인라인(inline) R 코드 문서의 모든 숫자를 인라인 R 코드를 통해 재현가능하게 생성 가능 인라인 R 코드는 `r 과 ` 사이에 변수 계산 스크립트를 입력해 작성 가능 예를 들어 `r 10 + 4` 는 14 출력 활용 예시 head(mtcars, 5) N &lt;- nrow(mtcars) mtcars 데이터셋에 포함된 자동차는 `r N ` 개다. \\(\\rightarrow\\) mtcars 데이터셋에 포함된 자동차는 32 개다. "],
["yaml.html", "1.6 YAML", " 1.6 YAML R Markdown 문서의 가장 처음에 정의하는 metadata .Rmd 파일을 .md 파일로 변환 후 최종 출력문서 생성 시 필요한 pandoc의 옵션을 설정하는 것과 같은 의미임 일반적으로 문서 형태 및 생성을 위해 사용하는 R package (예: bookdown, officedown, rticles 등)에 따라 YAML 구성요소가 달라짐 기본 문법 /#: 주석 처리 YAML 문서의 시작과 끝은 --- 로 정의함 기본적으로 콜론(:)으로 구분된 태그(키): 값 쌍으로 구성됨 \\(\\rightarrow\\) key: value 여기서 콜론 바로 다음에는 반드시 공백문자가 있어야 함 한 key의 하위 키는 리스트 형태로 표현하고, 하위 키는 두 개 이상의 스페이스로 공백을 주어 표현 --- key : value subkey1: value1 subkey2: value2 subsubkey1: value3 --- R Markdown 기본 YAML 구조 --- title: &quot;문서 제목&quot; # 일반적으로 따옴표 사용 subtitle: &quot;문서 부제목&quot; author: &quot;문서 작성자&quot; date: &quot;문서 작성일자&quot; output: - &quot;html_document&quot; - &quot;word_document&quot; - &quot;pdf_document&quot; - &quot;md_document&quot; - &quot;isoslides_presentation&quot; - &quot;slidy_presentation&quot; - &quot;beamer_presentation&quot; bibliography: 참고문헌.bib # bibtex 서식 활용 . . . --- https://bookdown.org/yihui/rmarkdown/documents.html 에 자세한 예시 참고 "],
["rmarkdown-citation.html", "1.7 참고문헌 인용", " 1.7 참고문헌 인용 참고문헌 정보가 BibTeX 포맷으로 저장된 .bib 파일을 YAML에 선언 후 인용 가능 참고문헌 표현: [@citation-identifier] 또는 @citation-identifier BibTeX 포맷은 Google Scholar 에서 쉽게 획득 가능 Citation 스타일은 YAML 헤더에 cl: style.csl로 변경 가능하며 Zotero 에서 .csl 파일 다운로드 가능 "],
["control-structure.html", "2 제어문(Control Structure)", " 2 제어문(Control Structure) Sketch 프로그램이 무엇이고 이를 만들기 위해 어떤 것들이 필요할까? 프로그램 안의 특정 구문을 주어진 조건에 맞게 실행 여부를 제어하거나 동일한 작업을 반복할 수 있을까? 프로그램을 통해 특정 목적을 위한 나만의 함수를 만들 수 있을까? Figure 2.1: Flow-control example (https://homerhanumat.github.io/r-notes/flow.html) 참고: 본 장의 내용은 데이터과학 민주화와 Beginning Computer Programming with R의 내용을 기반으로 재구성함 "],
["control-prerequisite.html", "2.1 Prerequisite", " 2.1 Prerequisite 예약어(researved words): R에서 의미(sementic)를 미리 정해 놓은 단어 통계프로그래밍언어 강의노트 참고 Table 2.1: R 예약어 종류 및 설명 R 예약어 설명 if, else, while, function, in, next, break 조건, 함수, 반복문에 사용 TRUE/FALSE 논리 상수(logical constants) NULL 정의되지 않은 값 혹은 값이 없음 표현 Inf 무한(infinity) NaN 숫자가 아님(not a number) NA 결측값(not available) NA_integer_, NA_real_, NA_complex_, NA_character_ 결측값을 처리하는 상수 … 함수가 다른 함수에 인자를 전달하도록 지원 변수(variable): 사용자가 프로그램 처리를 위해 지정한 단어 적당한 값을 저장하고 나중에 필요시 해당 값을 호출해 사용하기 위한 목적으로 사용되는 표식(label) 예약어를 변수명으로 사용할 수 없음 통계프로그래밍언어 강의노트: R 기초문법 참고 고수준 언어(high-level language): 사람이 읽고 쓰기 쉬운 형태의 명령어를 컴퓨터가 읽고 처리할 수 있도록 고안된 프로그래밍 언어 컴퓨터가 이해할 수 있는 언어 \\(\\rightarrow\\) 중앙처리장치(central processing unit, CPU)가 이해하는 언어 \\(\\rightarrow\\) 기계어(machine language) 기계어는 0과 1로 구성된 이진수(binary number)임(예: 0100101001001001001110110101101010110) 고수준 언어의 종류: C, C++, JAVA, 베이직, Perl, Python, R, … 번역기(translator): 사람이 이해할 수 있는 표현(언어)를 기계(컴퓨터)가 이해할 수 있는 언어(기계어)로 변환 인터프리터(interpreter) 컴파일러(compiler) **인터프리터*: 코드(스크립트) 한 줄을 즉석에서 읽고, 파싱(프로그램을 검사하고 구문론적 구조를 분석)하고, 해석 R, Python, MATLAB 등은 인터프리터를 번역기로 사용 인터엑티브 모드 \\(\\rightarrow\\) R 프롬프트(&gt;) 뒤에 한 줄의 명령어를 작성하면 측석해서 처리 후 다음 입력에 대해 준비(prompt)함. 안녕하세요!! 통계패키지활용 수업에서 R을 배우고 있습니다. 처음이라 실수가 많습니다. 앞으로 잘 부탁해요!! Error: &lt;text&gt;:1:6: 예기치 않은 &#39;!&#39;입니다 1: 안녕하세요! ^ print(&quot;안녕하세요!!&quot;) print(&quot;통계패키지활용 수업을 위해 R을 배우고 있습니다.&quot;) print(&quot;처음이라 실수가 많습니다.&quot;) print(&quot;앞으로 잘 부탁해요!!&quot;) [1] &quot;안녕하세요!!&quot; [1] &quot;통계패키지활용 수업을 위해 R을 배우고 있습니다.&quot; [1] &quot;처음이라 실수가 많습니다.&quot; [1] &quot;앞으로 잘 부탁해요!!&quot; 컴파일러: 완전한 프로그램을 하나의 파일에 담고 파일 안에 저장되어 있는 소스코드를 기계어로 번역 후 다음 실행할 수 있도록 변환한 기계어를 파일에 담음. 보통은 .exe, .dll 파일 형태로 저장됨 "],
["control-program.html", "2.2 프로그램", " 2.2 프로그램 프로그램(program): 특정 작업(목적)을 수행할 수 있도록 작성한 일련의 R 문장(명령어)의 집합 일련의 문장(명령어)들은 텍스트 편집기를 통해 작성하며, 스크립트(script)로 명칭되는 파일로 저장 \\(\\rightarrow\\) R 스크립트 .R 확장자를 가짐 # Hello.R print(&quot;안녕 R!!&quot;) #한국어 print(&quot;Hi R!!&quot;) # 영어 print(&quot;こんにちはR!!&quot;) # 일본어 print(&quot;Γεια R!!&quot;) #그리스어 source(&quot;hello.R&quot;, encoding = &quot;UTF-8&quot;) [1] &quot;안녕 R!!&quot; [1] &quot;Hi R!!&quot; [1] &quot;こんにちはR!!&quot; [1] &quot;Γεια R!!&quot; 예시: 텍스트 파일에서 가장 자주 나오는 단어 찾기 프로그램 https://statkclee.github.io/r4inf/r-intro.html#r-intro-what-is-a-program 참고 require(tidyverse) require(stringr) require(ggpubr) require(ggthemes) text_dat &lt;- readLines(&quot;data/text-example-01.txt&quot;) # 공백 또는 구둣점 문자를 기준으로 텍스트 나누기 # 공백 또는 구둣점 문자 기준으로 텍스트 토큰화 split_wd &lt;- str_split(text_dat, pattern = &quot;\\\\b|[[:punct:]]&quot;) split_wd &lt;- do.call(c, split_wd) id &lt;- grepl(&quot;[a-zA-Z]+&quot;, split_wd) #알파벳을 포함한 단어 인덱스 split_wd &lt;- split_wd[id] unique_wd &lt;- unique(split_wd) # 중복을 제외한 총 사용 단어 res_v &lt;- vector(&quot;integer&quot;, length(unique_wd)) # 저장 벡터 생성 for (i in seq_along(unique_wd)) { for (j in seq_along(split_wd)) { if (unique_wd[i] == split_wd[j]) { res_v[i] &lt;- res_v[i] + 1 } } } bind_cols(&quot;word&quot; = unique_wd, &quot;freq&quot; = res_v) %&gt;% arrange(desc(freq)) 프로그램 작성을 위한 개념적 요소 입력(input): 외부로부터 가져온 데이터, 값 등 출력(output): 입력에 대한 반응(결과 출력, 파일 저장, 음악 재생, …) 순차실행(sequential execution): 스크립트 또는 코드 작성 순서에 따라 한줄씩 실행 조건실행(conditional execution): 특정 조건에 따라 문장(명령)을 실행하거나 건너뜀 번복실행(iterative execution): 특정 명령을 반복적으로 실행 재사용(resuse): 스크립트의 집합(다수 줄로 구성된 코드 또는 스크립트)에 이름을 부여하고 저장 \\(\\rightarrow\\) 사용자 지정 함수(function) 프로그램 오류의 종류 구문오류(syntax error): R 언어가 이해할 수 없는 문장 또는 문법으로 실행했을 때 나타나는 오류 \\(\\rightarrow\\) 가장 고치기 쉽고 즉각적으로 알려줌 논리 또는 run-time 오류(logic or run-time error): 구문은 완벽하지만 실행 순서 또는 논리적으로 연관방식에 문제가 있어서 명령어를 수행할 수 없는 경우 의미론적 오류(sementic error): 프로그램은 구문적으로 오류가 없고 실행되지만 올바른 결과를 출력하지 않는 경우 \\(\\rightarrow\\) 제일 고치기 어려움 가장 간단한 프로그래밍은 순차적으로 명령을 실행하되 입력 시 흐름을 잠시 중단하고 대기하는 방법 \\(\\rightarrow\\) 프롬프트 상 명령어 한 줄씩 입력 # 아주 간단한 프로그래밍 예제 # readline() 함수 이용해 R한테 인사 받기 name &lt;- readline(&quot;What&#39;s your name?: &quot;) cat(&quot;Hello, &quot;, name, &quot;!\\n&quot;, sep = &quot;&quot;) # readline() 함수를 이용해 알바비 계산 x &lt;- as.numeric(readline(prompt = &quot;하루 아르바이트 시간을 입력하시오: &quot;)) y &lt;- as.numeric(readline(prompt = &quot;시급을 입력하시오 (단위=원): &quot;)) z &lt;- as.numeric(readline(prompt = &quot;한달 동안 총 몇 일 동안 일을 하셨나요? &quot;)) cat(&quot;월 급여는 &quot;, x * y * z, &quot; 원 입니다.\\n&quot;, sep = &quot;&quot;) "],
["condition.html", "2.3 조건문(Conditionals)", " 2.3 조건문(Conditionals) if 구문을 통해 조건문 생성 불린 표현식(boolean expression): 참(TRUE) 또는 거짓(FALSE) 두 값 중 하나로 값이 도출되는 표현식4 비교 연산자(comparison operators) 같다, 같지 않다, 크다 등을 표현하기 위한 연산자 ==, !=, &gt;, &lt;, &gt;=, &lt;= 논리 연산자(logical operator) AND (&amp;, &amp;&amp;), OR (|, ||), NOT (!) x &lt;- 10; y &lt;- 13 # x가 2의 배수이고 y가 3의 배수 # 두 조건이 모두 참이여야 참 x %% 2 == 0 &amp; y %% 3 == 0 # x가 2의 배수이거나 y가 3의 배수 # 두 개 조건 중 하나만 참을 만족하면 참임 x %% 2 == 0 | y %% 3 == 0 # NOT (x &gt; y) !(x &gt; y) # 부정에 부정은 참 [1] FALSE [1] TRUE [1] TRUE 2.3.1 기본 구문 if (조건) 표현식 └ 괄호 안 조건을 만족하면 표현식을 실행하고 조건을 만족하지 않으면 실행하지 않음 x &lt;- 10 if (x &gt; 0) { print(&quot;x is positive&quot;) } x &lt;- -5 if (x &gt; 0) { print(&quot;x is positive&quot;) } [1] &quot;x is positive&quot; Figure 2.2: if 구문 기본 flow-chart if 구문의 사용 규칙 if 문은 조건을 정의하는 헤더 부분((, ))과 표현식이 위치하는 몸통 블록(body block, {표현식}) 으로 구성됨 (, )에 표현되는 조건은 벡터가 아닌 단일 값으로 나타내야 함. {, } 의 표현 또는 문장이 한 줄인 경우 블록 지정이 필요하지 않지만, 두 줄 이상인 경우 if 문의 범위를 지정해줘야 하기 때문에 꼭 중괄호(curly bracket, {})가 사용되야 함. # 조건문 사용 예시 x &lt;- c(TRUE, FALSE, FALSE) y &lt;- c(TRUE, TRUE, FALSE) z &lt;- &quot;Both TRUE!!&quot; if (x[1] &amp; y[1]) print(z) # x, y 첫 번째 원소만 사용 if (x &amp;&amp; y) print(z) # 강제로 첫 번째 원소만 사용 if (x &amp; y) print(z) # 경고 표시 Warning in if (x &amp; y) print(z): length &gt; 1 이라는 조건이 있고, 첫번째 요소만이 사용될 것입니다 [1] &quot;Both TRUE!!&quot; [1] &quot;Both TRUE!!&quot; [1] &quot;Both TRUE!!&quot; 대안 실행(alternative execution) 두 가지 경우가 존재하고 조건에 따라 어떤 명령을 실행할지를 결정 if와 else로 표현 가능 조건에 따라 실행이 분기(branch) 되기 때문에 if-else 구문을 분기문이라고도 함 else 는 if 조건을 배제(exclusive)한 나머지 경우이기 때문에 조건을 따로 지정하지 않으며, if와 동일하게 중괄호 내에 표현되어야 함 x &lt;- 9 if (x %% 2 == 0) { print(&quot;x is even&quot;) } else { print(&quot;x is odd&quot;) } [1] &quot;x is odd&quot; Figure 2.3: 대안실행(if-else 구문) flow-chart 2.3.2 연쇄 조건문(chained condition) 두 가지 이상의 분기가 존재하는 경우 조건 표현식 연쇄 조건문의 표현은 아래와 같음 if (조건1) { 표현식1 ... } else if (조건2) { 표현식2 ... } else { 표현식3 ... } x &lt;- 5; y &lt;- 10 if (x &lt; y) { print(&quot;x is less than y&quot;) } else if (x &gt; y) { print(&quot;x is greater than y&quot;) } else { print(&quot;x is equal to y&quot;) } [1] &quot;x is less than y&quot; Figure 2.4: 연쇄조건(if-else if-else 구문) flow-chart 2.3.3 중첩 조건문(nested contition) 하나의 조건문 내부에 하위 조건식이 존재하는 형태 if (조건1) { 표현식1 ... } else { if (조건2) { 표현식2 ... } else { 표현식3 ... } } x &lt;- 10; y &lt;- 10 if (x == y) { print(&quot;x is equal to y&quot;) } else { if (x &gt; y) { print(&quot;x is greater than y&quot;) } else { print(&quot;x is less than y&quot;) } } [1] &quot;x is equal to y&quot; Figure 2.5: 중첩 조건문 flow-chart 중첩 조건문은 코드의 가독성을 떨어뜨리기 때문에 피하는 것을 권장 중첩 조건문을 피하기 위한 한 가지 방법은 논리 연산자를 활용 # 중첩조건 x &lt;- 58 if (x &gt; 0) { if (x &lt; 10) { print(&quot;x는 한 자리 양수&quot;) } else { if (x &lt; 100) { print(&quot;x는 두 자리 양수&quot;) } else { print(&quot;x는 세 자리 이상 양수&quot;) } } } [1] &quot;x는 두 자리 양수&quot; # 연쇄 조건 x &lt;- 2020 if (x &gt; 0 &amp; x &lt; 10) { print(&quot;x는 한 자리 양수&quot;) } else if (x &gt;=10 &amp; x &lt; 100) { print(&quot;x는 두 자리 양수&quot;) } else { print(&quot;x는 세 자리 이상 양수&quot;) } [1] &quot;x는 세 자리 이상 양수&quot; 2.3.4 ifelse() 함수 if-else 구문을 사용하기 쉽게 구현된 R 내장 함수 if-else 구문과 다르게 조건 부분에 한 값(스칼라)이 아닌 논리형 벡터를 입력값으로 받아 조건에 따른 값(벡터)을 반환 # ifelse() 함수 인수 # help(ifelse) 참고 ifelse( test, 조건에 따른 논리형 벡터 yes, test에 정의한 조건이 참인 경우 새로운 벡터에 대입할 값 no, test 조건이 거짓인 경우 대입할 값 ) 사용 예시 # 평균이 23이고 표준편차가 5인 정규분포로부터 30개의 난수 추출 set.seed(12345) bmi &lt;- rnorm(30, 23, 5) bmi_cat &lt;- ifelse(bmi &lt; 25, &quot;normal&quot;, &quot;overweight&quot;) bmi_cat [1] &quot;overweight&quot; &quot;overweight&quot; &quot;normal&quot; &quot;normal&quot; &quot;overweight&quot; [6] &quot;normal&quot; &quot;overweight&quot; &quot;normal&quot; &quot;normal&quot; &quot;normal&quot; [11] &quot;normal&quot; &quot;overweight&quot; &quot;normal&quot; &quot;overweight&quot; &quot;normal&quot; [16] &quot;overweight&quot; &quot;normal&quot; &quot;normal&quot; &quot;overweight&quot; &quot;normal&quot; [21] &quot;overweight&quot; &quot;overweight&quot; &quot;normal&quot; &quot;normal&quot; &quot;normal&quot; [26] &quot;overweight&quot; &quot;normal&quot; &quot;overweight&quot; &quot;overweight&quot; &quot;normal&quot; # ifelse() 함수를 연쇄조건문 처럼 사용할 수 있다 bmi_cat2 &lt;- ifelse(bmi &lt; 18.5, &quot;underweight&quot;, ifelse(bmi &lt; 24.9, &quot;normal&quot;, ifelse(bmi &lt; 29.9, &quot;overweight&quot;, &quot;obesity&quot;))) bmi_cat2 [1] &quot;overweight&quot; &quot;overweight&quot; &quot;normal&quot; &quot;normal&quot; &quot;overweight&quot; [6] &quot;underweight&quot; &quot;overweight&quot; &quot;normal&quot; &quot;normal&quot; &quot;underweight&quot; [11] &quot;normal&quot; &quot;obesity&quot; &quot;normal&quot; &quot;overweight&quot; &quot;normal&quot; [16] &quot;overweight&quot; &quot;normal&quot; &quot;normal&quot; &quot;overweight&quot; &quot;normal&quot; [21] &quot;overweight&quot; &quot;obesity&quot; &quot;normal&quot; &quot;underweight&quot; &quot;underweight&quot; [26] &quot;obesity&quot; &quot;normal&quot; &quot;overweight&quot; &quot;overweight&quot; &quot;normal&quot; 비교 및 논리 연산자(통계프로그래밍언어 2.1.4절 참고)↩︎ "],
["looping.html", "2.4 반복문(Looping)", " 2.4 반복문(Looping) Prerequisite 프로그램 또는 알고리즘 구현 시 특정 문장 또는 표현을 반복해야만 하는 상황이 발생 특히 시뮬레이션 시 반복문은 거의 필수적임 반복문을 통해 코딩의 효율을 극대화 할 수 있음 반복문은 특정 변수의 값을 갱신(update) 하기 위해 주로 사용 x &lt;- x + 1 # 현재 값에 1을 더해서 x를 새로운 값으로 update 통상적으로 특정 변수의 값을 갱신하기 위해 변수 값을 초기화(initialize) x &lt;- 0 # x 변수 초기화 x &lt;- x + 1 몇 번 반복이라는 정의가 없는 상태에서 특정 조건이 거짓(FALSE)이 될 때 까지 계속 반복 2.4.1 repeat 구문 repeat 표현식 repeat 다음에 오는 표현식을 무한 반복(infinite loop) repeat print(&quot;무한 루프에 걸림...ESC 키 누르시오!!&quot;) [1] &quot;무한 루프에 걸림...ESC 키 누르시오!!&quot; [1] &quot;무한 루프에 걸림...ESC 키 누르시오!!&quot; [1] &quot;무한 루프에 걸림...ESC 키 누르시오!!&quot; [1] &quot;무한 루프에 걸림...ESC 키 누르시오!!&quot; [1] &quot;무한 루프에 걸림...ESC 키 누르시오!!&quot; ... ... 특정 작업에 대해 블록을 지정(중괄호)하고 블록 안에 표현 가능 일반적으로 특정 조건(if (조건) break)을 두어 무한루프에서 탈출 if 문의 조건은 언제 반복이 끝날 지를 제어하는 변수로 반복변수(iteration variable) 이라고도 함 언제까지(until) 반복(repeat) \\(\\rightarrow\\) REPEAT-UNTIL 구문으로 표현 repeat { 표현식 1 if (조건) break 반복변수 update } Figure 2.6: REPEAT 구문 flow-chart # REPEAT-UNTIL 예시 1 # 1:100 까지 합 계산 함수 tot &lt;- 0; i &lt;- 1 # 사용 변수 초기화 (update 변수) repeat { tot &lt;- tot + i if (i &gt;= 100) break # i는 반복 변수 i &lt;- i + 1 } tot # check sum(1:100) [1] 5050 [1] 5050 tot에 i를 더한 후 i 가 조건을 만족하는지 확인 조건에 부합하지 않으면 다음 문장 실행(i에 1을 증가 후 업데이트) 1. 의 작업을 반복(loop) i가 조건에 부합하면 반복 종료 # REPEAT 예시 2 # 1에서 20 사이 숫자 알아맞추기 게임 n &lt;- 20 number &lt;- sample(1:n, size = 1) cat(&quot;1에서 &quot;, n, &quot;까지 숫자 알아 맞추기&quot;, sep = &quot;&quot;) repeat { guess &lt;- readline(&quot;어떤 숫자를 생각하시나요? (종료: q 입력) &quot;) if (guess == &quot;q&quot;) { cat(&quot;재미가 없나봐요.\\n&quot;) break } else if (as.numeric(guess) == number) { cat(&quot;천재인데요?ㅋㅋㅋ&quot;) break } # 틀리면 계속 반복 } guess에 readline() 으로부터 값 입력 guess 값이 q 이면 종료 guess 값이 number 와 일치하면 종료 2.와 3. 조건에 부합하지 않으면 guess 값을 반복적으로 입력 어떤 숫자를 생각하시나요? (종료: q 입력) 1 어떤 숫자를 생각하시나요? (종료: q 입력) 2 어떤 숫자를 생각하시나요? (종료: q 입력) 3 천재인데요?ㅋㅋㅋ 2.4.2 while 구문 while (조건) 표현식 ... while에 지정된 조건이 참이면 계속해서 반복 repeat는 반복이 처음부터 시작되는 반면, while 문은 조건을 먼저 평가한 후 반복이 시작됨. while (FALSE)인 경우 루프 본문 코드가 실행되지 않음 while (TRUE)는 repeat 구문과 동일 while문 의 일반적 형태 while (조건) { 표현식 1 반복변수 update } Figure 2.7: WHILE 구문 flow-chart # WHILE 구문 예시 1 # 1:100 까지 합 계산 함수 tot &lt;- 0; i &lt;- 1 # 사용 변수 초기화 (update 변수) while (i &lt;= 100) { tot &lt;- tot + i i &lt;- i + 1 } tot [1] 5050 초기값 i가 조건 i &lt;= 100 인지 확인 참인 경우 tot + i를 통해 tot을 업데이트 한 다음 i를 1만큼 증가 만약 i에 대한 조건 평가 결과가 거짓이면 while 구문을 빠져나감 # while 문 조건이 TRUE 인 경우 tot &lt;- 0; i &lt;- 1 # 사용 변수 초기화 (update 변수) while (TRUE) { tot &lt;- tot + i if (i &gt;= 100) break i &lt;- i + 1 } tot [1] 5050 while 의 조건이 참이기 때문에 무한 반복 단 i가 100과 같거나 클 경우 구문 탈출 그 전 까지는 tot와 i를 갱신 # WHILE 구문 예시 2 # 문자열 벡터에서 특정 문자열의 인덱스를 반환 txtvec &lt;- c(&quot;R&quot;, &quot;package&quot;, &quot;flow-control&quot;, &quot;while&quot;, &quot;if&quot;, &quot;for&quot;, &quot;repeat&quot;) found &lt;- FALSE i &lt;- 1 word &lt;- readline(&quot;검색할 텍스트: &quot;) while (!found &amp; i &lt;= length(txtvec)) { if (txtvec[i] == word) { found &lt;- TRUE break } cat(i, &quot; 번째 위치에 해당 단어가 존재하지 않습니다.\\n&quot;, sep=&quot;&quot;) i &lt;- i + 1 } if (found) { cat(i, &quot; 번째 위치에 &quot;, word, &quot;를 찾았습니다.&quot;, sep = &quot;&quot;) } else { cat(word, &quot; 단어는 해당 문자열 벡터에 존재하지 않습니다.\\n&quot;, sep = &quot;&quot;) } found = FALSE, i = 1을 초기값으로 입력 readline()으로 입력한 텍스트를 word에 저장 found 가 참이고 i가 텍스트 벡터의 길이 값과 같을 때 까지 다음 구문 반복 txtvec 각 원소와 word 값이 같은지 확인 while 입력 결과 1 번째 위치에 해당 단어가 존재하지 않습니다. 2 번째 위치에 해당 단어가 존재하지 않습니다. 3 번째 위치에 해당 단어가 존재하지 않습니다. 4 번째 위치에 while 를 찾았습니다. temp 입력 결과 1 번째 위치에 해당 단어가 존재하지 않습니다. 2 번째 위치에 해당 단어가 존재하지 않습니다. 3 번째 위치에 해당 단어가 존재하지 않습니다. 4 번째 위치에 해당 단어가 존재하지 않습니다. 5 번째 위치에 해당 단어가 존재하지 않습니다. 6 번째 위치에 해당 단어가 존재하지 않습니다. 7 번째 위치에 해당 단어가 존재하지 않습니다. temp 단어는 해당 문자열 벡터에 존재하지 않습니다. repeat, while과 같이 반복의 횟수가 지정되지 않는 반목구문을 불확정 반복문(indefinite loop)이라고 함. 다음에 배울 for 구문은 위 두 반복문과는 다르게 반복의 범위를 명확히 지정하기 때문에 확정 반복문(definite loop)라고 함. 2.4.3 for 구문 가장 많이 사용되는 반복구문으로 일반적인 형태는 아래와 같음 for (반복변수 in sequence) { 표현식 1 ... } R에서 sequence은 특정 유형의 벡터이며, 반복변수에 sequence의 원소를 순차적으로 할당함 반복변수는 for 반복문 안의 표현식 1에서 사용됨 Figure 2.8: FOR 구문 flow-chart #for 문 예시 1 student &lt;- readxl::read_excel(&quot;data/stat-students.xlsx&quot;) student_name &lt;- student$이름 for (s in student_name) { cat(s, &quot;학생!! 즐거운 명절 보내세요^^\\n&quot;) } 김세민 학생!! 즐거운 명절 보내세요^^ 김기랑 학생!! 즐거운 명절 보내세요^^ 이종영 학생!! 즐거운 명절 보내세요^^ 이원규 학생!! 즐거운 명절 보내세요^^ 황보영 학생!! 즐거운 명절 보내세요^^ 구나현 학생!! 즐거운 명절 보내세요^^ 엄용현 학생!! 즐거운 명절 보내세요^^ 오동원 학생!! 즐거운 명절 보내세요^^ 윤지우 학생!! 즐거운 명절 보내세요^^ 이근범 학생!! 즐거운 명절 보내세요^^ 이승호 학생!! 즐거운 명절 보내세요^^ 이희도 학생!! 즐거운 명절 보내세요^^ 정보경 학생!! 즐거운 명절 보내세요^^ 채시진 학생!! 즐거운 명절 보내세요^^ 최호진 학생!! 즐거운 명절 보내세요^^ 박인혜 학생!! 즐거운 명절 보내세요^^ 박준기 학생!! 즐거운 명절 보내세요^^ 최소미 학생!! 즐거운 명절 보내세요^^ 백승완 학생!! 즐거운 명절 보내세요^^ 김지원 학생!! 즐거운 명절 보내세요^^ 신형원 학생!! 즐거운 명절 보내세요^^ 임현정 학생!! 즐거운 명절 보내세요^^ 정수빈 학생!! 즐거운 명절 보내세요^^ 최예린 학생!! 즐거운 명절 보내세요^^ 황정인 학생!! 즐거운 명절 보내세요^^ student_name의 첫 번째 원소를 s에 할당 for 구문 안에 표현 실행 student_name의 마지막 원소까지 반복 # 위 예시와 동일한 표현 ## 인덱싱을 사용 for (i in 1:length(student_name)) { cat(student_name[i], &quot;학생!! 즐거운 명절 보내세요^^\\n&quot;) } ## sequence를 만드는 함수 seq_along() 사용 for (i in seq_along(student_name)) { cat(student_name[i], &quot;학생!! 즐거운 명절 보내세요^^\\n&quot;) } for 구문 안에 for 문을 1개 이상 중첩 가능 ## 2중 for 문 예시 set.seed(12345) id &lt;- sample(1:length(student_name), 5) sel_student &lt;- student_name[id] for (i in seq_along(student_name)) { for (j in seq_along(sel_student)) { if (student_name[i] == sel_student[j]) { cat(sel_student[j], &quot;님!! 당첨 축하 드립니다!!\\n&quot;) } } } 김기랑 님!! 당첨 축하 드립니다!! 이승호 님!! 당첨 축하 드립니다!! 채시진 님!! 당첨 축하 드립니다!! 박인혜 님!! 당첨 축하 드립니다!! 백승완 님!! 당첨 축하 드립니다!! 불확정 반복문 학습 시 무한루프로부터 break를 통해 루프에서 탈출 루프를 완전히 탈출하지 않고 현재 반복을 중지하고 그 다음 반복을 진행하고 싶을 경우 next 예약어를 사용 # 알파벳 e와 일치하는 경우에만 텍스트 메세지 출력 vec &lt;- c(&quot;a&quot;,&quot;e&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;, &quot;e&quot;, &quot;z&quot;) word &lt;- &quot;e&quot; for (i in 1:length(vec)) { if (vec[i] != word) next cat(word, &quot;가&quot;, i, &quot;번 째 인덱스에 있네요!!\\n&quot;) } e 가 2 번 째 인덱스에 있네요!! e 가 3 번 째 인덱스에 있네요!! e 가 7 번 째 인덱스에 있네요!! "],
["function.html", "2.5 함수 (function)", " 2.5 함수 (function) Figure 2.9: 함수 함수: 특정한 목적을 위한 연산을 수행하기 위해 명명된 일련의 문장(추상화) 예: sum(x) \\(\\rightarrow\\) 벡터 x의 값을 모두 합산하는 함수로 “sum” 이라고 명명된 내장 함수 R 콘솔에서 함수 명칭(예: sum)을 입력 후 실행하면 함수 내부 확인 가능 sum function (..., na.rm = FALSE) .Primitive(&quot;sum&quot;) 함수의 명칭(위의 예에서 sum)으로 특정 합수를 호출(call) R의 스크립트는 내장된 혹은 사용자가 정의한 함수들을 호출함으로써 작성됨 함수를 사용해야만 하는 이유 매우 큰 프로그램 작업을 해야할 경우 함수를 통해 작업 단위 별로 분할 가능 한 번 작성한 함수는 재사용 가능 프로그램의 체계적 관리가 가능하기 때문에 유지 및 보수가 용이 프로그램 코드의 간결화 2.5.1 함수의 정의 function 이라는 R의 예약어를 통해 사용자 함수 정의 함수 정의 시 함수의 명칭을 반드시 부여해야 함 함수 이름 &lt;- function() 함수는 일반적으로 인수(argument)로 입력값을 전달 받으면 그 결과값을 반환(return) 함수의 인수와 반환에 따라 다음과 같이 4 가지 유형의 함수 정의 가능 인수를 갖는 함수 인수를 갖지 않는 함수 값을 반환하는 함수 값을 반환하지 않는 함수 # (1) 인수를 갖는 함수 ## (모)분산을 계산하는 함수 var_pop &lt;- function(x) { n &lt;- length(x) if (n &lt; 2) { stop(&quot;적어도 두 개 이상의 관찰값이 존재해야 합니다&quot;) } mx &lt;- mean(x) v &lt;- sum((x - mx)^2)/n return(v) # 결과를 반환하는 함수: v를 함수의 출력값으로 설정 } ## test set.seed(1) # 동일한 난수 생성을 위해 seed 번호 부여 x &lt;- rnorm(1) var_pop(x) Error in var_pop(x): 적어도 두 개 이상의 관찰값이 존재해야 합니다 set.seed(1000) x &lt;- rnorm(1000, 2, 4) # 평균이 2이고 표준편차가 4인 정규분포로부터 1000개 난수 추출 var_pop(x) [1] 15.40581 # (2) 인수를 갖지 않는 함수 print_lyrics_let_it_be &lt;- function() { print(&quot;When I find myself in times of trouble, &quot;) print(&quot;Mother Mary comes to me.&quot;) print(&quot;Speaking words of wisdom &#39;let it be&#39;.&quot;) } print_lyrics_let_it_be() [1] &quot;When I find myself in times of trouble, &quot; [1] &quot;Mother Mary comes to me.&quot; [1] &quot;Speaking words of wisdom &#39;let it be&#39;.&quot; print_lyrics_let_it_be(beatles) Error in print_lyrics_let_it_be(beatles): 사용되지 않은 인자 (beatles) ## 주사위를 돌리는 함수 rolling_dice &lt;- function() { sample(1:6, 1, replace = TRUE) } rolling_dice(); rolling_dice(); rolling_dice(); [1] 4 [1] 4 [1] 4 # (3) 값을 반환하는 함수 manual_mean &lt;- function(x) { n &lt;- length(x) sumi &lt;- 0 for (i in 1:n) { sumi &lt;- sumi + x[i] } return(sumi/n) } set.seed(20) x &lt;- sample(1:200, 20, replace = FALSE) # 1 ~ 200 중 랜덤하게 20개 추출(비복원) manual_mean(x) [1] 107 # 미리 정의하지 않은 인수를 입력한 경우 set.seed(4) na_idx &lt;- sample(1:length(x), 4) x[na_idx] &lt;- NA manual_mean(x, na.rm = TRUE) Error in manual_mean(x, na.rm = TRUE): 사용되지 않은 인자 (na.rm = TRUE) # (4) 값을 반환하지 않는 함수(void function) summary_mean &lt;- function(x, ...) { n &lt;- sum(!is.na(x)) mx &lt;- sum(x, ...)/n cat(&quot;Data: &quot;, sprintf(&quot;%.2f&quot;, x), &quot;\\n&quot;) # 소숫점 2째 짜리 까지 출력 cat(&quot;전체 관찰값 개수(결측 제외) = &quot;, n, &quot;\\n&quot;) cat(&quot;산술평균 = &quot;, mx, &quot;\\n&quot;) } set.seed(20) x &lt;- rnorm(20) summary_mean(x) Data: 1.16 -0.59 1.79 -1.33 -0.45 0.57 -2.89 -0.87 -0.46 -0.56 -0.02 -0.15 -0.63 1.32 -1.52 -0.44 0.97 0.03 -0.09 0.39 전체 관찰값 개수(결측 제외) = 20 산술평균 = -0.1877639 result &lt;- summary_mean(x) Data: 1.16 -0.59 1.79 -1.33 -0.45 0.57 -2.89 -0.87 -0.46 -0.56 -0.02 -0.15 -0.63 1.32 -1.52 -0.44 0.97 0.03 -0.09 0.39 전체 관찰값 개수(결측 제외) = 20 산술평균 = -0.1877639 result NULL x[na_idx] &lt;- NA # ...를 통해 미리 정하지 않은 인수를 # 함수 내부에서 호출한 다른 함수로 전달 가능 summary_mean(x, na.rm = TRUE) Data: 1.16 -0.59 NA -1.33 -0.45 0.57 NA -0.87 -0.46 -0.56 NA -0.15 -0.63 1.32 -1.52 -0.44 0.97 0.03 NA 0.39 전체 관찰값 개수(결측 제외) = 16 산술평균 = -0.1590692 x &lt;- summary_mean(x, na.rm = TRUE) Data: 1.16 -0.59 NA -1.33 -0.45 0.57 NA -0.87 -0.46 -0.56 NA -0.15 -0.63 1.32 -1.52 -0.44 0.97 0.03 NA 0.39 전체 관찰값 개수(결측 제외) = 16 산술평균 = -0.1590692 2.5.2 함수의 인수 전달 방법 함수는 입력값(input) 을 가지며, 이러한 입력값은 함수의 인수(argument)에 해당 값을 할당함으로써 입력값이 함수로 전달됨 함수의 인수 정의는 내 마음대로 가능(개수 무관) R에서 함수 호출 시 인수 전달은 “값”을 호출 하는 방식(call by value) call by value와 상반되는 개념으로 참조에 의한 호출(call by reference)로 값이 아니라 값이 저장되어 있는 메모리의 주소 값을 전달하는 방식(대표적인 예: C 언어의 포인터)임. 계산 효율은 참조에 의한 호출이 월등히 뛰어나지만, 프로그램의 구조가 복잡하다는 단점을 가짐. R은 데이터 분석에 특화된 프로그램이기 때문에 직관적인 call by value 방식을 택함. 예시 # 두 변수의 값을 바꾸는 함수: swap swap &lt;- function(x, y) { temp &lt;- x x &lt;- y y &lt;- temp cat(&quot;두 값이 바뀌었습니다.&quot;, sprintf(&quot;x = %d, y = %d&quot;, x, y) ,&quot;\\n&quot;) } x &lt;- 3; y &lt;- 10 swap(x, y) 두 값이 바뀌었습니다. x = 10, y = 3 x; y # x, y 두 값이 바뀌지 않음 [1] 3 [1] 10 인수를 전달하는 방법은 다음 두 가지임 인수의 위치 순서에 의한 전달: 정의한 인수의 순서대로 각 인수에 대응하는 값을 전달 인수의 이름에 의한 전달: 위치와 관계 없이 정의한 인수의 이름을 지정하여 값을 전달 # 표준편차 계산 함수: stdev stdev &lt;- function(x, na.rm = TRUE) { if (is.matrix(x)) apply(x, 2, sd, na.rm = na.rm) else if (is.vector(x)) sqrt(var(x, na.rm = na.rm)) else if (is.data.frame(x)) sapply(x, sd, na.rm = na.rm) else sqrt(var(as.vector(x), na.rm = na.rm)) } set.seed(1000) X &lt;- matrix(rnorm(1000), 100, 10) x &lt;- rpois(50, lambda = 10) # 포아송 분포(lambda = 10)에서 50개 난수 추출 dat &lt;- mtcars # R 내장 데이터를 dat 에 저장 # (1) 순서에 의한 전달 stdev(X, T); stdev(X) # 동일한 결과 [1] 1.0065940 0.9033927 0.9727257 0.9905631 0.8202803 1.0114516 0.9855547 [8] 1.0211373 1.0716219 1.0426811 [1] 1.0065940 0.9033927 0.9727257 0.9905631 0.8202803 1.0114516 0.9855547 [8] 1.0211373 1.0716219 1.0426811 stdev(x) [1] 3.41569 stdev(dat) mpg cyl disp hp drat wt 6.0269481 1.7859216 123.9386938 68.5628685 0.5346787 0.9784574 qsec vs am gear carb 1.7869432 0.5040161 0.4989909 0.7378041 1.6152000 stdev(TRUE, dat) # 오류 why?? Warning in if (na.rm) &quot;na.or.complete&quot; else &quot;everything&quot;: length &gt; 1 이라는 조건 이 있고, 첫번째 요소만이 사용될 것입니다 Error in if (na.rm) &quot;na.or.complete&quot; else &quot;everything&quot;: argument is not interpretable as logical # (2) 이름에 의한 전달 set.seed(5) na_idx &lt;- sample(1:50, 5) x[na_idx] &lt;- NA stdev(na.rm = T, x = x) [1] 3.411211 stdev(dat = dat, na.rm = TRUE) # 오류 why??? Error in stdev(dat = dat, na.rm = TRUE): 사용되지 않은 인자 (dat = dat) 2.5.3 함수의 기본 구성 요소 Figure 2.10: 함수의 기본 구조 function()에서 () 안의 부분(일반적으로 첫 번째 줄)을 머리(header) 부분 함수의 초기 형태(매개변수 또는 인수의 형태)를 지정 연산 또는 명령이 수행되는 부분은 함수의 몸통(body) 부분({} 로 표시) 함수 내부에서 실행되는 연산 명령어들의 집합으로 구성 인수(argument): 함수의 기능을 선택적으로 조정하는 parameter로 함수 안에서 작동하는 매개변수들을 통칭 인수는 argument 또는 argument = default value로 설정 복수의 인수는 콤마(,)로 구분 \\(\\rightarrow\\) fun_name &lt;- function(arg1, arg2, arg3) 특수 인수 ...: 어떠한 개수의 인수를 함수로 전달할 수 있음 일반적으로 인수의 개수가 불특정하거나 함수 안에서 다른 함수를 호출할 때 특정 인수를 다른 함수로 전달시킬 때 유용(위 예시 참고) # (1) 인수에 default 값을 주지 않은 함수 fun_without_arg_default &lt;- function(x, y) { x*y } set.seed(10) a &lt;- sample(1:20, 10, replace = TRUE) # 복원 추출 a[7] &lt;- NA b &lt;- 5 fun_without_arg_default(a, b) [1] 55 45 50 80 60 40 NA 95 75 75 # (2) 인수에 default 값을 부여한 함수 fun_with_arg_default &lt;- function(x = 5, y = 8) { x*y } fun_with_arg_default() [1] 40 trim_mean &lt;- function(x, trim = 0, na.rm = F) { mean(x, trim = trim, na.rm = na.rm) } trim_mean(a) [1] NA trim_mean(x = a, trim = 0.2, na.rm = TRUE) # 인수 이름으로 값 전달 [1] 12.57143 trim_mean(a, 0.3, TRUE) # 인수 순서대로 값 전달 [1] 12.6 # (3) ... 인수 사용 예제 # list() 함수를 이용해 `...`에 해당하는 인수들을 리스트 객체로 만든 후 # 이를 함수에서 사용 dot_example &lt;- function(x, ...) { # browser() trim &lt;- 0 na.rm &lt;- FALSE dots &lt;- list(...) # ...에 해당하는 인수 추출 for (arg in names(dots)) { if (arg == &quot;trim&quot;) trim &lt;- as.numeric(dots[arg]) if (arg == &quot;na.rm&quot;) na.rm &lt;- as.logical(dots[arg]) } mean(x, trim = trim, na.rm = na.rm) } dot_example(a) [1] NA set.seed(30) a &lt;- sample(1:30, 15, replace = TRUE) # 복원 추출 dot_example(a) [1] 17.06667 a[9] &lt;- NA dot_example(a) [1] NA dot_example(a, trim = 0.1, na.rm = TRUE) [1] 17.75 # (4) `...` 인수가 함수 내 사용(호출)된 # 다른 함수의 인수로 전달하는 경우 # summary_mean() 함수 예제와 유사 mean_manual &lt;- function(x, ...) { mean(x, ...) } set.seed(30) x &lt;- rnorm(30, mean = 10, sd = 5) na_idx &lt;- sample(1:30, 3, replace = TRUE) xna &lt;- x; xna[na_idx] &lt;- NA mean_manual(x) [1] 8.347683 mean_manual(xna) [1] NA mean_manual(xna, na.rm = TRUE) [1] 8.127862 mean_manual(x = xna, trim = 0.2, na.rm = TRUE) [1] 7.534424 함수 몸체 안에 browser()을 입력하면, browser() 전 까지 함수 몸체 안 명령들이 수행되고, 이후 명령들이 어떻게 실행되는지 확인할 수 있음. 함수 작성 시 함수 로직을 세우고 디버깅 할 때 매우 유용하게 사용 인수 관련 몇 가지 유용한 함수들 args(): 특정 함수에서 사용되는 인수 확인 args(fun_without_arg_default) function (x, y) NULL args(rnorm) function (n, mean = 0, sd = 1) NULL body(): 함수의 몸체 조회 body(var_pop) { n &lt;- length(x) if (n &lt; 2) { stop(&quot;적어도 두 개 이상의 관찰값이 존재해야 합니다&quot;) } mx &lt;- mean(x) v &lt;- sum((x - mx)^2)/n return(v) } body(dot_example) { trim &lt;- 0 na.rm &lt;- FALSE dots &lt;- list(...) for (arg in names(dots)) { if (arg == &quot;trim&quot;) trim &lt;- as.numeric(dots[arg]) if (arg == &quot;na.rm&quot;) na.rm &lt;- as.logical(dots[arg]) } mean(x, trim = trim, na.rm = na.rm) } match.arg(): 인수를 매치하는 함수로 매치할 대상의 인수를 지정 arg: 매치할 대상 인수 지정 choice: 매치될 인수값 목록 several.ok: 복수 선택 여부(TRUE/FALSE) # 인수의 매치 match.arg(arg = c(&quot;med&quot;, &quot;max&quot;), choices = c(&quot;mean&quot;, &quot;median&quot;, &quot;iqr&quot;, &quot;minimum&quot;, &quot;maximum&quot;, &quot;range&quot;), several.ok = TRUE) [1] &quot;median&quot; &quot;maximum&quot; match.arg(arg = c(&quot;median&quot;, &quot;maximuum&quot;), choices = c(&quot;mean&quot;, &quot;med&quot;, &quot;iqr&quot;, &quot;minimum&quot;, &quot;max&quot;, &quot;range&quot;), several.ok = TRUE) # 오류 why?? Error in match.arg(arg = c(&quot;median&quot;, &quot;maximuum&quot;), choices = c(&quot;mean&quot;, : &#39;arg&#39;은 반드시 &quot;mean&quot;, &quot;med&quot;, &quot;iqr&quot;, &quot;minimum&quot;, &quot;max&quot;, &quot;range&quot; 중 하나이어야 합니다 match.arg(arg = c(&quot;med&quot;, &quot;max&quot;), choices = c(&quot;mean&quot;, &quot;median&quot;, &quot;iqr&quot;, &quot;minimum&quot;, &quot;maximum&quot;, &quot;range&quot;), several.ok = FALSE) Error in match.arg(arg = c(&quot;med&quot;, &quot;max&quot;), choices = c(&quot;mean&quot;, &quot;median&quot;, : &#39;arg&#39;는 반드시 길이가 1이어야 합니다 # match.arg() 함수 응용 # 중심값 관련 통계량 계산 함수 # 평균(mean), 절삭평균(trimmed mean), 중앙값(median), 최빈수(mode) 계산 # pkg_list &lt;- rownames(installed.packages()) # 설치된 패키지 목록 # if (!(&quot;DescTools&quot; %in% pkg_list)) # install.packages(&quot;DescTools&quot;) # 최빈수를 구하기 위한 패키지 설치 center &lt;- function(x, type = c(&quot;mean&quot;, &quot;trimmed&quot;, &quot;median&quot;, &quot;mode&quot;), ... ) { # browser() trim = 0; na.rm = FALSE # dot 인수 초기값 type &lt;- match.arg(type) dots &lt;- list(...) for (arg in names(dots)) { if (arg == &quot;trim&quot;) trim &lt;- as.numeric(dots[arg]) if (arg == &quot;na.rm&quot;) na.rm &lt;- as.logical(dots[arg]) } switch(type, mean = mean(x, na.rm = na.rm), trimmed = mean(x, trim = trim, na.rm = na.rm), median = median(x, na.rm = na.rm), mode = DescTools::Mode(round(x, 1), na.rm = na.rm) # DescTools 패키지 내 Mode 함수를 # workspace에 불러오지 않고 사용 ) } set.seed(100) x &lt;- rchisq(100, df = 3) # 자유도가 3인 카이제곱분포에서 난수 추출 xna &lt;- x; xna[na_idx] &lt;- NA center(x, &quot;mean&quot;); center(x, &quot;me&quot;) [1] 2.929673 Error in match.arg(type): &#39;arg&#39;은 반드시 &quot;mean&quot;, &quot;trimmed&quot;, &quot;median&quot;, &quot;mode&quot; 중 하나이어야 합니다 [1] 2.929673 center(x, &quot;trimmed&quot;, trim = 0.1) [1] 2.565866 center(x, &quot;median&quot;) [1] 2.45614 center(x, &quot;mode&quot;) [1] 1.7 attr(,&quot;freq&quot;) [1] 6 center(xna, &quot;median&quot;) [1] NA center(xna, &quot;median&quot;, na.rm = TRUE) [1] 2.423723 switch() 함수는 ifelse() 함수의 확장 버전으로 \\(n\\) 개의 조건에 대한 분기 가능 함수 제어 관련 주요 함수 return(): 계산된 결과를 반환하는 함수로 함수의 흐름에서 return()이 나타나면 결과값을 반환하고 함수 종료 강제 종료가 필요한 경우 응용 가능 # (1) 객체 반환 set.seed(100) x &lt;- rnorm(100, mean = 24, sd = 2.2) value_return1 &lt;- function(x) { tot &lt;- sum(x) n &lt;- length(x) result &lt;- list(size = n, total = tot, average = mean(x), stdev = sd(x)) return(result) } value_return1(x) $size [1] 100 $total [1] 2400.641 $average [1] 24.00641 $stdev [1] 2.245563 desc &lt;- value_return1(x) desc$stdev [1] 2.245563 value_return2 &lt;- function(x) { return(sum(x)/length(x)) } value_return2(x) [1] 24.00641 # (2) 강제 종료 시 활용 value_return3 &lt;- function(x) { if (anyNA(x)) return return(sum(x)/length(x)) } xna &lt;- x; xna[na_idx] &lt;- NA value_return3(xna) [1] NA value_return3(x) [1] 24.00641 stop(): 예외처리 함수의 일종으로 특정 조건일 경우 (오류) 메세지를 출력하고 함수 종료 인수로 문자열을 가짐 # (1) stop() 함수 사용 # 복소수 값을 실수와 허수로 분할 split_complex &lt;- function(z) { if(!is.complex(z)) stop(&quot;입력값이 복소수가 아닙니다&quot;) re &lt;- Re(z) im &lt;- Im(z) return(list(real = re, imaginary = im)) } split_complex(pi) Error in split_complex(pi): 입력값이 복소수가 아닙니다 split_complex(23 + 7i) $real [1] 23 $imaginary [1] 7 2.5.4 함수의 적용 범위(scoping rule) Scoping rule: 변수 또는 객체가 어디에서 사용 가능한지를 결정하는 규칙 매개변수(parameter): 함수를 적용할 때 사용되는 변수로 인수로부터 발생함 함수의 인수 리스트에서 인수값이 매개변수로 할당 지역변수(local variable): 함수의 몸체 부분에서 정의된 변수들을 지칭하며 함수의 종료와 동시에 재사용 불가 전역변수(global variable): 함수의 외부(workspace)에서 정의된 변수로 함수 내부에서 값을 할당하지 않더라도 사용 가능 # (1) 매개변수, 지역변수, 전역변수 구분 x &lt;- 10 # 전역변수 y &lt;- 5 # 전역변수 scope1 &lt;- function(x) { y &lt;- x^2 print(x) # 매개변수 print(y) # 지역변수 } x; y # 전역변수가 출력 [1] 10 [1] 5 scope1(x = 10) [1] 10 [1] 100 작업공간에서 x와 y는 각각 10, 5 값이 할당 작업공간 상에서 x y 값은 변하지 않음 지역변수 y의 사용 범위는 함수 몸체이기 때문에 함수 밖에 있는 y는 값이 변하지 않음 x &lt;- 10 # 전역변수 y &lt;- 5 # 전역변수 rm(z) scope2 &lt;- function(x) { y &lt;- x^2 print(x) # 매개변수 print(y) # 지역변수 print(z) } scope2(x = 5) [1] 5 [1] 25 Error in print(z): 객체 &#39;z&#39;를 찾을 수 없습니다 z &lt;- 13 # 전역변수로 z 할당 scope2(x = 5) [1] 5 [1] 25 [1] 13 함수 외부와 내부 모두에서 z가 정의되지 않았기 때문에 에러 출력 작업공간 상에 z를 정의한 경우 함수 내부에서 workspace에서 정의한 z를 그대로 사용 \\(\\rightarrow\\) 함수 외부와 내부 자유로이 사용 가능한 변수를 자유변수(free variable)이라고 지칭함. 지역변수의 사용 범위는 함수 몸체 안이지만 그 범위를 밖으로 확장할 수 있음 \\(\\rightarrow\\) &lt;&lt;- 또는 -&gt;&gt; 사용 # 지경변수의 확장 예제 x &lt;- 1; y &lt;- 2; z &lt;- 3; k &lt;- 10 scope3 &lt;- function(x) { y &lt;&lt;- x + 10 y * 3 -&gt;&gt; z print(x) # 매개변수 print(y) # 지역변수 print(z) # 지역변수 print(k) # 자유변수 } x;y;z;k [1] 1 [1] 2 [1] 3 [1] 10 scope3(x = 2) [1] 2 [1] 12 [1] 36 [1] 10 x;y;z;k [1] 1 [1] 12 [1] 36 [1] 10 하나의 함수 내부에 또 다른 함수 생성 가능 mean_manual2 &lt;- function(x) { tot &lt;- sum(x) size &lt;- function(x) { return(length(x)) } return(tot/size(x)) } mean_manual2(1:10) [1] 5.5 2.5.5 재귀 호출 함수(recursive call function) 함수 자신을 다시 호출하는 함수로 직관적으로 이해하기 쉽고 간결함 재귀함수 작성 시 재귀호출을 탈출하는 조건을 명확히 하는 것이 관건 예제1: 계승(factorial) 계산하기 \\[ n! = \\begin{cases} n \\times (n - 1)!, &amp; n=1, \\cdots \\\\ 1, &amp; n = 0 \\end{cases} \\] \\(f(n) = n!\\) 이라고 하면 \\(f(n)\\)은 아래와 같이 나타낼 수 있음. \\[ n! = \\begin{cases} n \\times f(n-1), &amp; n=1, \\cdots \\\\ 1, &amp; n = 0 \\end{cases} \\] 위 식을 이용해 \\(3!\\)을 구하는 과정: - \\(f(3) = 3\\times f(2) = 3\\times 2 \\times f(1) = 3 \\times 2\\times 1\\times f(0) = 3\\times 2\\times 1\\times 1\\times = 6\\) f(3) = 3*f(2) f(2) = 2 * f(1) f(1) = 1 위 과정을 함수로 구현 factorial_manual &lt;- function(n) { if (n == 0) return(1) return(n * factorial_manual(n-1)) } # test factorial_manual(3) [1] 6 factorial_manual(10) [1] 3628800 # R 내장함수로 검증 factorial(10) [1] 3628800 예제: 하노이 탑(tower of Hanoi) “인도 베나레스에 있는 한 사원에는 세상의 중심을 나타내는 큰 돔이 있고 그 안에 세 개의 다이아몬드 바늘이 동판 위에 세워져 있습니다. 바늘의 높이는 1 큐빗이고 굵기는 벌의 몸통만 합니다. 바늘 가운데 하나에는 신이 64개의 순금 원판을 끼워 놓았습니다. 가장 큰 원판이 바닥에 놓여 있고, 나머지 원판들이 점점 작아지며 꼭대기까지 쌓아 있습니다. 이것은 신성한 브라흐마의 탑입니다. 브라흐마의 지시에 따라 승려들은 모든 원판을 다른 바늘로 옮기기 위해 밤낮 없이 차례로 제단에 올라 규칙에 따라 원판을 하나씩 옮깁니다. 이 일이 끝날 때, 탑은 무너지고 세상은 종말을 맞이하게 됩니다.” [Wikipedia] 문제: 3개의 기둥 A, B, C가 있고, 기둥 A에 \\(N\\) 개의 원판이 크기 순서대로 쌓여져 있을 때(제일 밑에 원판이 가장 큼), 모든 원판을 기둥 C로 옮기기 조건 한 번에 하나의 원판만 옮길 수 있음 큰 원판이 작은 원판 위에 있으면 안됨 Figure 2.11: 하노이 탑 문제 Solution 원판의 크기가 제일 작은 것 부터 큰 것 까지 각각 1, 2, 3 번을 부여 했을 때 1 번 원판을 봉 A에서 C로 옮김 (A \\(\\rightarrow\\) C) 2 번 원판을 봉 A에서 B로 옮김 (A \\(\\rightarrow\\) B) 1 번 원판을 봉 C에서 B로 옮김 (C \\(\\rightarrow\\) B) 3 번 원판을 봉 A에서 C로 옮김 (A \\(\\rightarrow\\) C) 1 번 원판을 봉 B에서 A로 옮김 (B \\(\\rightarrow\\) A) 2 번 원판을 봉 B에서 C로 옮김 (B \\(\\rightarrow\\) C) 1 번 원판을 봉 A에서 C로 옮김 (A \\(\\rightarrow\\) C) 원판이 3개인 경우 총 7번의 이동이 필요 \\(\\rightarrow\\) \\(n\\)개의 원판이 있을 경우 \\(2^n - 1\\) 번의 이동이 필요 Figure 2.12: 하노이 탑 문제 알고리즘 구현 move_hanoi &lt;- function(n, from, to, via) { if (n == 1) { print(sprintf(&quot;%d 번 원판을 %s 에서 %s 로 이동&quot;, 1, from, to)) } else { move_hanoi(n - 1, from, via, to) print(sprintf(&quot;%d 번 원판을 %s 에서 %s 로 이동&quot;, n, from, to)) move_hanoi(n - 1, via, to, from) } } move_hanoi(3, &quot;A&quot;, &quot;C&quot;, &quot;B&quot;) [1] &quot;1 번 원판을 A 에서 C 로 이동&quot; [1] &quot;2 번 원판을 A 에서 B 로 이동&quot; [1] &quot;1 번 원판을 C 에서 B 로 이동&quot; [1] &quot;3 번 원판을 A 에서 C 로 이동&quot; [1] &quot;1 번 원판을 B 에서 A 로 이동&quot; [1] &quot;2 번 원판을 B 에서 C 로 이동&quot; [1] &quot;1 번 원판을 A 에서 C 로 이동&quot; move_hanoi(4, &quot;A&quot;, &quot;C&quot;, &quot;B&quot;) [1] &quot;1 번 원판을 A 에서 B 로 이동&quot; [1] &quot;2 번 원판을 A 에서 C 로 이동&quot; [1] &quot;1 번 원판을 B 에서 C 로 이동&quot; [1] &quot;3 번 원판을 A 에서 B 로 이동&quot; [1] &quot;1 번 원판을 C 에서 A 로 이동&quot; [1] &quot;2 번 원판을 C 에서 B 로 이동&quot; [1] &quot;1 번 원판을 A 에서 B 로 이동&quot; [1] &quot;4 번 원판을 A 에서 C 로 이동&quot; [1] &quot;1 번 원판을 B 에서 C 로 이동&quot; [1] &quot;2 번 원판을 B 에서 A 로 이동&quot; [1] &quot;1 번 원판을 C 에서 A 로 이동&quot; [1] &quot;3 번 원판을 B 에서 C 로 이동&quot; [1] &quot;1 번 원판을 A 에서 B 로 이동&quot; [1] &quot;2 번 원판을 A 에서 C 로 이동&quot; [1] &quot;1 번 원판을 B 에서 C 로 이동&quot; 숙제2: 하노이 탑 문제의 어느 부분을 재귀함수로 나타낼 수 있는지를 명확히 기술하고, 위 함수의 실행 원리를 설명 또는 도식화 하시오. 제출일: 2020년 11월 6일 금요일 23:59분 까지 제출방법: R markdown으로 작성한 문서와 Rmd 파일을 ’학번-이름.zip’으로 압축 후 제출 "],
["Simulation.html", "3 시뮬레이션", " 3 시뮬레이션 Sketch 시뮬레이션이 뭐지? 통계학에서 시뮬레이션이 왜 필요할까? 중요한 기초통계 이론을 눈으로 확인할 수 있을까? "],
["시뮬레이션모의실험의-의미.html", "3.1 시뮬레이션(모의실험)의 의미", " 3.1 시뮬레이션(모의실험)의 의미 알반적 의미 현실세계에서는 시간 및 비용 등의 문제로 실현하기 어렵거나 불가능한 시스템을 모형을 통해 실제 시스템을 모사함으로써 현상에 대한 문제를 이해하고자 하는 목적으로 고안한 일련의 방법 시뮬레이션의 활용 사례 군사 모의실험 비행 모의실험 선거 모의실험 민방위 훈련 … 통계적 모의실험(statistical or stochastic simulation) 통계학의 표본이론과 확률론에 근간을 두고 난수(random number)와 임의표본(random sample)을 이용해 어떤 결과나 문제의 해를 근사해 실제 이론으로 도출한 해와 비교함. 이러한 형태의 모의실험 방법을 몬테칼로 시뮬레이션(Monte Carlo simulation)이라고 함. 통계적 모의실험에 Monte carlo 라는 명칭이 붙게된 계기는 2차 세계대전 당시 미국의 원자폭탄 개발계획인 Manhattan 프로젝트에서 중성자의 특성을 연구하기 위한 모의실험의 명칭에 모나코의 유명한 도박 도시 Monte Carlo 이름을 붙힌 것에서 유래함. 통계적 모형은 결국 수학적으로 데이터가 어떻게 생성되었는가를 의미함. “모형을 시뮬레이션 한다” = 단계적으로 “데이터 처럼 보이는 것”을 생성하기 위해 모형을 적용 통계적 시뮬레이션 결과는 동일한 초기값에서 시작하더라도 동일한 결과를 보장하지 않음 예시: \\(X_1 \\sim \\mathcal{N}(3, 2^2)\\), \\(X_2 \\sim \\mathcal{N}(5, 3^2)\\) 이고, \\(X \\perp \\!\\!\\! \\perp Y\\) 일때 \\(X_3 = X_1 + 2X_2\\) 의 분포는? \\(X3 \\sim \\mathcal{N}(3 + 2\\times5, 2^2 + 4\\times 3^2) = \\mathcal{N}(13, 40)\\) set.seed(10000) x1 &lt;- rnorm(10000, 3, 2) x2 &lt;- rnorm(10000, 5, 3) x3 &lt;- x1 + 2*x2 mean(x3); var(x3) [1] 13.0817 [1] 39.87758 통계적 모의실험의 특징 특정 분포를 따르는 확률변수의 관찰값이 필요 반복적으로 수많은 난수를 생성해야 하기 때문에 컴퓨터의 사용이 필수적 기본적으로 통계학의 가장 기본적 개념인 대수의 법칙(law of the large number)을 활용 통계적 모의실험을 하는 방법 통계적(확률) 모형은 보통 한 변수(\\(X\\))가 주어졌을 때 다른 변수(\\(Y\\))에 대한 조건부 분포임. 대표적인 예: 단순선형회귀모형(simple linear regression model) \\[ \\begin{eqnarray} X &amp; \\sim &amp; \\mathcal{N}(\\mu_x, \\sigma_1^2) \\\\ Y|X &amp; \\sim &amp; \\mathcal{N}(\\beta_0 + \\beta_1X, \\sigma_2^2) \\end{eqnarray} \\] - 위 식에서 우변에 주어진 확률변수를 생성하는 방법을 알고 있다면 위 회귀모형에 대한 시뮬레이션 가능 \\(\\rightarrow\\) 모든 종류의 확률 모형에 대한 시뮬레이션의 일반적 전략임(통계 프로그래밍 언어 기말고사 마지막 문제 상기!!) 통계적 모의실험(시뮬레이션) = 확률변수의 생성문제 "],
["통계-시뮬레이션에-활용되는-수학-함수-및-분포-함수.html", "3.2 통계 시뮬레이션에 활용되는 수학 함수 및 분포 함수", " 3.2 통계 시뮬레이션에 활용되는 수학 함수 및 분포 함수 3.2.1 수학함수 R은 광범위한 수학 함수를 내장하고 있고 다음 열거한 함수 목록은 그 일부임 exp(): 지수(e)를 밑으로 하는 지수 함수 log(): 자연 로그 함수 log10(): 10을 밑으로 하는 로그 sqrt(): 제곱근 abs(): 절대값 sin(), cos(), tan() … : 삼각함수 min(), max(): 벡터 내 최솟값과 최댓값 반환 which.min(), which.max(): 벡터 내 최댓값과 최솟값에 대한 인덱스 반환 sum(), prod(): 벡터 원소들의 합과 곱 결과 반환 cumsum(), cumprod(): 백터 원소들의 누적합과 누적곱 round(), floor(), ceiling(): 수치형 값의 반올림, 내림, 올림 factorial(): 팩토리얼 함수 \\(n!\\) choose(): 조합 함수 (\\(_n C_r = \\frac{n!}{r!(n-r)!}\\)) 확장예제1: 확률계산 \\(P_i\\): \\(n\\) 개의 독립적인 사건이 있고 \\(i\\) 번째 사건이 발생할 확률 \\(n = 3\\) 일 때, 각 사건의 이름을 각각 A, B, C 라고 할 때 이 중 사건 하나가 발생할 확률 P(사건 하나가 발생할 확률) = P(A가 일어나고 B와 C가 일어나지 않을 확률) + P(A가 일어나지 않고 B가 일어나고 C가 일어나지 않을 확률) + P(A, B가 일어나지 않고 C만 일어날 확률) 여기서 P(A가 일어나고 B와 C가 일어나지 않을 확률) = \\(P_A(1-P_B)(1-P_C)\\) \\(\\rightarrow\\) 나머지도 마찬가지임 일반화 하면 \\[ \\sum_{i=1}^{n} P_i(1-P_1)(1-P_2)\\cdots (1-P_{i-1})(1-P_{i+1})\\cdots (1-P_{n}) \\] 구현 함수 # 벡터 p에서 p_i 계산 함수 probability_i &lt;- function(p) { notp &lt;- 1 - p tot &lt;- 0 for (i in 1:length(p)) tot &lt;- tot + p[i] * prod(notp[-i]) return(tot) } # test set.seed(3) p &lt;- runif(3, 0, 1) # 0-1 사이 값 3개를 균일분포로부터 추출 probability_i(p) [1] 0.4947463 확장예제2: 누적합, 누적곱 # cumsum, cumprod 함수 사용 예시 x &lt;- c(2, 4, 1, 3, 7, 8) cumsum(x); cumprod(x) [1] 2 6 7 10 17 25 [1] 2 8 8 24 168 1344 확장예제3: 최솟값, 최댓값 # which.min, which.max 사용 예시 set.seed(100) x &lt;- sample(1:100, 100) idx_min &lt;- which.min(x) x[idx_min] [1] 1 idx_max &lt;- which.max(x) x[idx_max] [1] 100 # min(), max(), pmin(), pmax() 비교 set.seed(5) x &lt;- runif(5, 2, 4) y &lt;- runif(5, 2, 4) z &lt;- cbind(x, y) min(z); max(z) # z의 전체 값 중 최솟값과 최댓값 반환 [1] 2.2093 [1] 3.913 pmin(z); pmax(z) # 아무 값을 반환하지 않음 x y [1,] 2.400429 3.402115 [2,] 3.370437 3.055920 [3,] 3.833752 3.615870 [4,] 2.568799 3.913000 [5,] 2.209300 2.220906 x y [1,] 2.400429 3.402115 [2,] 3.370437 3.055920 [3,] 3.833752 3.615870 [4,] 2.568799 3.913000 [5,] 2.209300 2.220906 # 두 열을 비교해 각 행에서 최솟값, 최댓값을 반환 pmin(z[, 1], z[, 2]) [1] 2.400429 3.055920 3.615870 2.568799 2.209300 pmax(z[, 1], z[, 2]) [1] 3.402115 3.370437 3.833752 3.913000 2.220906 확장예제4: 미분/적분 문자의 미분 및 수치 적분 가능 # 도함수 구하기 ## D() 함수 사용 dx &lt;- D(expression(exp(x^2)), &quot;x&quot;) # exp(x^2)을 x에 대해서 1차 미분한 도함수 set.seed(3) x &lt;- runif(3, 1, 2) eval(dx) # 위 입력한 x에 대한 도함수 값 출력 [1] 9.141245 94.842390 18.856751 ## deriv() 함수 사용 grad &lt;- D(expression(x*sin(x)), &quot;x&quot;) # 도함수를 R의 function으로 바로 반환 가능 dx2 &lt;- deriv(expression(x*sin(x)), &quot;x&quot;, function.arg = TRUE) dx2(x) [1] 1.074580 1.757109 1.361092 attr(,&quot;gradient&quot;) x [1,] 1.3778035 [2,] 0.5482219 [3,] 1.2386966 # 수치 적분 ## integrate() 함수 사용 ## 주어진 함수의 적분식을 구한 후, 입력 구간에 대한 적분값 계산 integrate(f = function(x) x^2, lower = 0, upper = 1) 0.3333333 with absolute error &lt; 3.7e-15 확장예제 응용: Newton-Raphson method 임의의 함수 \\(f(x)\\)가 주어졌을 때 \\(f(x) = 0\\) (\\(f(x)\\)의 해)를 만족하는 \\(x\\)를 반복적인 수치계산을 통해 찾는 방법 Newton-Raphson (N-R) 방법 적용 시 \\(f(x)\\)의 만족 조건 \\(x\\)의 특정 범위 내에서 \\(f(x) = 0\\)를 만족하는 유일한 실수값 존재 \\(f(x)\\)는 미분 가능한 함수 Newton-Raphson 알고리즘 예시 N-R 알고리즘(스케치) step 1: 초기치 \\(x_{old}\\)를 설정 step 2: \\(x_{old}\\)에서 \\(f(x_{old})\\) 값 계산 step 3: \\(x_{old}\\)에서 접선의 기울기(미분계수) \\(f&#39;(x_{old})\\) 계산 step 4: \\(f&#39;(x_{old})\\)의 접선이 \\(x\\)축과 만나는 점을 새로운 값 \\(x_{new}\\)로 업데이트 \\[ x_{new} = x_{old} - \\frac{f(x_{old})}{f&#39;(x_{old})} \\] step 5: 일정 조건을 만족할 때 까지 step 1 ~ step 4 반복 step 4에서 초기값 \\(x_0\\)이 주어졌을 때 \\(f(x_0)\\)의 접선은 \\(f&#39;(x_0)\\) 이고 \\((x_0, f(x_0))\\)를 통과하므로 접선의 식은 아래와 같음 \\[ f(x) = f&#39;(x_0)(x - x_0) + f(x_0) \\] \\(f(x) = 0\\) 일때 \\(x\\)의 값은 \\[ x = x_0 -\\frac{f(x_0)}{f&#39;(x_0)} \\] - 따라서 다음 단계에서 해의 근사치 \\(x_{1} = x_0 - f(x_0)/f&#39;(x_0)\\) 이고, 이를 조금 더 일반화 하면, \\[ x_{n+1} = x_n - \\frac{f(x_n)}{f&#39;(x_n)} \\] 위 식은 테일러 전개(Taylor expansion)를 통해 도출 가능(한 번 생각해 볼 것!!) N-R 알고리즘의 특징 현재 \\(x_{old}\\) 또는 \\(x_{n}\\)이 0을 만족할 경우, 더 이상 다음 단계로 가지 않음. 현재 함수값이 0에서 멀리 떨어져 있을수록 다음 스텝이 커지고, 미분계수의 절대값이 클수록 다음 스텝이 작아짐 미분계수의 절대값이 크다 \\(\\rightarrow\\) \\(x_n\\)을 조금만 움직여도 함수값이 크게 변한다는 의미 따라서 미분계수의 값을 다음 스텝에 반영해야 함. 다음 \\(x_{new}\\)의 방향은 \\(f(x_{old})/f&#39;(x_{old})\\) 부호와 반대방향으로 결정 수렴속도가 빠르지만 초기값에 따라 알고리즘의 성능이 달라짐 \\(f&#39;(x)\\)를 반복적으로 계산해야 하고, 경우에 따라 \\(f&#39;(x) = 0\\)이면 반복식 계산이 불가 반복 종료 조건 처음 설정한 최대 반복 횟수를 넘었을 때 더 이상 \\(x\\)의 값이 움직이지 않는다고 판단되었을 경우 함수의 값이 충분히 0에 가까워 졌을 경우 N-R 알고리즘 구현 알고리즘에 입력되어야 할 변수 초기값과 해를 찾을 범위 지정 \\(\\rightarrow\\) 만약 초기값이 해당 범위를 벗어난 값이 입력되었다면 함수 종료 함수 반복횟수 0과 충분히 가까운 상수(종료 시 필요) \\(\\rightarrow\\) tol 함수 내부 또는 함수 외부에서 1차 미분 함수가 요구 함수 인수로 입력 vs. 함수 내부에서 도함수 계산? 도함수 계산 시 위 예제에서 사용한 R 내장 함수 사용 vs. 미분식 사용? \\[ \\lim_{d \\rightarrow 0} \\frac{f(x + d) - f(x)}{d} \\] 반복 종료조건에 도달할 때 까지 반복이 필요 \\(\\rightarrow\\) while 문 사용 반복 조건: 반복이 최대 반복수보다 작고 \\(|f(x_{new})|\\) 값이 tol 값보다 클 때 까지 newton_raphson &lt;- function(FUN, # 함수 x0 = 1, # 초기값 max_iters = 5000, # 최대 반복 횟수 tol = 1.0e-9, range = c(-Inf, Inf), ...) { iters &lt;- 1; grads &lt;- deriv(as.expression(body(FUN)), &quot;x&quot;, function.arg = TRUE) # grads 반환값 중 &quot;gradient&quot; 값 = f&#39;(x0) gap &lt;- x0 - FUN(x0)/attr(grads(x0), &quot;gradient&quot;) while(iters &lt; max_iters &amp; abs(gap) &gt; tol) { # x_new 계산 x_new &lt;- x0 - FUN(x0)/attr(grads(x0), &quot;gradient&quot;) gap &lt;- FUN(x_new) # x_new 가 범위를 벗어난 경우 처리 if (x_new &lt;= range[1]) x_new &lt;- range[1] if (x_new &gt;= range[2]) x_new &lt;- range[2] iters &lt;- iters + 1 x0 &lt;- x_new # 초기값 업데이트 } if (x_new == range[1] | x_new == range[2]) warning(&quot;마지막 점이 x 범위의 경계선 상에 있습니다.&quot;) if (iters &gt; max_iters) warning(&quot;최대 반복 때 까지 해를 찾지 못했습니다.&quot;) cat(&quot;x 가&quot;, x_new, &quot;일 때 함수값:&quot;, FUN(x_new), &quot;\\n&quot;) return(list(solution = x_new, iteration = iters)) } ## test: 위 동영상과 동일한 해를 갖는지 확인 f &lt;- function(x) 5 * x^3 - 7 * x^2 - 40 * x + 100 newton_raphson(FUN = f, x0 = 1, range = c(-10, 10)) -&gt; sols x 가 -3.151719 일 때 함수값: -3.547029e-11 Quiz: newton_raphson() 함수에서 1차 미분 도함수를 구하는 스크립트를 아래 일반 미분공식으로 변환한 함수 newton_raphson_gen()를 작성하고, 해당 함수가 정상적으로 작동하는지 확인하시오. \\[ \\lim_{d \\rightarrow 0} \\frac{f(x + d) - f(x)}{d} \\] 문제 제출이 필수는 아니지만 제출 시 가산점이 있음. 제출기간: 2020년 11월 6일 금요일 제출방법: 작성 스크립트를 학번-이름.R로 저장 후 E-mail로 제출 3.2.2 통계 분포 함수 R은 현존하는 대부분의 통계 확률 분포 함수를 제공하고 접두사 + 분포이름 형태의 함수명을 갖고 있으며, 보통 다음과 같은 접두사를 통해 분포 함수 생성 d: 밀도(density)의 약어로 확률 밀도함수(probability density function, pdf) 또는 이산형 분포의 확률 질량 함수(probability mass function, pmf) q: 분위수(quantile)의 약어로 상위 %에 해당하는 \\(x\\) 값을 반환 p: 누적분포함수(cumulative density function, cdf) r: 특정 분포로부터 난수(확률변수) 생성 예: dnorm(), qnorm(), pnorm(), rnorm() 은 정규분포 관련 함수임 Table 3.1: 일반적인 R 통계 분포함수(일부 제시) Distribution Density/Mass function R pdf R cdf R quantile RV generation Parameter 균일분포 \\(\\frac{1}{b -a},~\\mathrm{for}~x \\in [a, b]\\) dunif punif qunif runif min (a), max (b) 지수분포 \\(\\lambda \\exp{(-\\lambda x)}\\) dexp pexp qexp rexp rate (\\(\\lambda\\)) 정규분포 \\(\\frac{1}{\\sqrt{2\\pi}\\sigma}\\exp \\left\\{-\\frac{(x - \\mu)^2}{2\\sigma^2} \\right \\}\\) dnorm pnorm qnorm rnorm mean (\\(\\mu\\)), sd (\\(\\sigma\\)) \\(\\chi^2\\) 분포 \\(\\frac{1}{\\Gamma(\\nu/2)2^{\\nu/2}}x^{(\\nu/2) - 1}e^{(-x/2)}\\) dchisq pchisq qchisq rchisq df (\\(\\nu\\)) \\(t\\) 분포 \\(\\frac{\\Gamma(\\frac{\\nu + 1}{2})}{\\Gamma{(\\frac{\\nu}{2}})}\\frac{1}{\\sqrt{\\nu\\pi}}\\frac{1}{(1 + x^2/\\nu)^{(\\nu + 1)/2}}\\) dt pt qt rt df (\\(\\nu\\)) 이항분포 \\({n \\choose x} p^x (1 - p)^{n - x}\\) dbinom pbinom qbinom rbinom size (\\(n\\)), prob (\\(p\\)) 포아송 분포 \\(\\frac{e^{-\\lambda}\\lambda^x}{x!}\\) dpois ppois qpois rpois lambda (\\(\\lambda\\)) 예제: 확률 분포 함수 ## 카이제곱분포 x &lt;- seq(0, 30, by = 0.1) y &lt;- dchisq(x, df = 3) # 자유도가 3인 카이제곱분포 밀도 함수 plot(x, y, type = &quot;l&quot;, bty = &quot;n&quot;, xlab = &quot;&quot;, ylab = &quot;&quot;, main = expression(paste(&quot;PDF of &quot;, ~chi^2, &quot; distribution&quot;)), lwd = 2, cex.main = 2) # P(5 &lt; V &lt; 10) pchisq(10, df = 3) - pchisq(5, df = 3) [1] 0.153231 ## 그림에 표현 idx &lt;- x &gt;= 5 &amp; x &lt;= 10 polygon(c(5, x[idx], 10), c(0, y[idx], 0), col = &quot;blue&quot;, border = &quot;blue&quot;) abline(h = 0, col = &quot;darkgray&quot;) text(x = 10, y = 0.05, cex = 2, bquote(P({5 &lt;= V} &lt;= 10 ) == .(sprintf(&quot;%.3f&quot;, pchisq(10, df = 3) - pchisq(5, df = 3)))), adj = 0) # 분위수 qchisq(pchisq(10, df = 3), df = 3) [1] 10 # 난수 생성 v &lt;- rchisq(1000, df = 3) mean(v) # 카이제곱분포의 평균은 이론적으로 자유도 값과 같음 [1] 2.994 난수 생성의 방법 난수(random number): 어떤 방법으로도 예측될 수 없는 일련의 수열(숫자) 통계적 의미로 난수는 특정 범위(보통 0에서 1 사이)의 균일분포(uniform distribution)에서 추출된 표본들의 관찰값으로, 임의의 확률분포(예: 정규분포, 지수분포 등)를 따르는 확률변수와는 구별됨. 보통 확률 변수는 균일분포를 따르는 확률변수로부터 적절한 변환을 통해 얻을 수 있음. 난수를 발생하려면 어떤 알고리즘이 필요하고 알고리즘은 일정한 규칙에 의해 구현되기 때문에 컴퓨터로 발생한 난수는 엄밀한 의미에서 난수가 아님. 이를 구별하기 위해 보통 컴퓨터로 생성한 난수를 유사난수(pseudo-random number)라 칭함 난수 생성을 위한 알고리즘으로 합동법(congruential method), 역변환법(inversion method) 등이 널리 사용됨 통계 시뮬레이션에서는 특히 변수변환방법(transformation)을 통해 확률변수 생성 \\(Z \\sim \\mathcal{N}(0, 1)\\)일 때 \\(\\sigma Z + \\mu \\sim \\mathcal{N}(\\mu, \\sigma^2)\\) \\(Z^2 \\sim \\chi^2(1)\\) Figure 3.1: 확률분포의 관계도(http://www.math.wm.edu/~leemis/chart/UDR/UDR.html) "],
["확률과-확률변수.html", "3.3 확률과 확률변수", " 3.3 확률과 확률변수 필수 개념 확률(probability) 확률변수(random variable) 기댓값(expectation) 확률(probability): 어떤 사건을 \\(E\\) 라고 명명할 때, \\(E\\)가 발생할 확률은 만약 무작위적 과정을 매우 많이 반복 했을 때 사건 \\(E\\)가 발생한 비율을 의미함 예1: 한화 이글스가 플레이오프에서 승리 후 리그 1위 팀과 한국 시리즈에서 경기를 할 확률? 예2: 동전/주사위 던지기 확률변수(random variable): 우연한 사건의 결과에 값을 핟당 예: 카지노 게임의 배당금 기댓값(expectation): 사건이 벌어졌을 때의 이득과 그 사건이 벌어질 확률을 곱한 것을 전체 사건에 대해 합한 값 확률변수의 기댓값은 평균으로 수렴 확률변수의 기댓값은 무작위 과정을 여러 번 반복했을 때 장기적인 측면에서 평균적으로 얻어질 것으로 기대되는 값 "],
["몬테칼로-시뮬레이션.html", "3.4 몬테칼로 시뮬레이션", " 3.4 몬테칼로 시뮬레이션 본 절에서 사용한 동영상 및 모의실험 코드는 Yihui Xie와 Lijia Yu가 배포한 animation 패키지의 내용을 기반으로 재구성함. 우리가 알고 있는 확률과 기댓값의 정의는 모두 반복 횟수에 제한없이 무한대로 확률실험(무작위 과정)을 반복 했을 때의 상황을 설정한 것임 즉 컴퓨터를 통해 수학적 확률 또는 기댓값을 정확히 계산할 수 없어도 무작위 실험을 매우 많이 반복해 특정 사건이 일어날 확률이나 기댓값 추정이 가능 \\(\\rightarrow\\) 몬테칼로 시뮬레이션의 기본 idea 3.4.1 동전 던지기 실제 정상적인 동전을 던졌을 때 앞/뒷면이 나올 확률이 1/2 일까? 정상적인 동전 던지기 실험 구현 sample() 함수를 통해 매우 간단히 구현 가능 함수 적용 시 가장 중요한 부분은 복원 추출을 한다는 점임 매번 시행이 독립시행이고 매회 시행 시 앞면과 뒷면이 나올 확률이 같도록 유지해야 함 # 동전 실험 coin_flip &lt;- function(faces, ntry = 100) { record &lt;- sample(faces, size = ntry, replace = TRUE) prob1 &lt;- sum(record == faces[1])/ntry prob2 &lt;- 1 - prob1 p &lt;- list(prob1, prob2) for (i in 1:length(faces)) cat(paste0(&quot;Proprotion &quot;, faces[i], &quot;:&quot;), p[[i]], &quot;\\n&quot;) } coin &lt;- c(&quot;H&quot;, &quot;T&quot;) set.seed(1000) coin_flip(coin, ntry = 10) # 10회 Proprotion H: 0.5 Proprotion T: 0.5 coin_flip(coin, ntry = 20) # 20회 Proprotion H: 0.4 Proprotion T: 0.6 coin_flip(coin, ntry = 100) # 100회 Proprotion H: 0.53 Proprotion T: 0.47 coin_flip(coin, ntry = 1000) # 1000회 Proprotion H: 0.516 Proprotion T: 0.484 coin_flip(coin, ntry = 10000) # 10000회 Proprotion H: 0.4988 Proprotion T: 0.5012 coin_flip(coin, ntry = 100000) # 100000회 Proprotion H: 0.49925 Proprotion T: 0.50075 3.4.2 기댓값 추정 정상적인 동전 두 번을 던졌을 때, 모두 뒷면이 나온 경우 1000 원을 잃음 둘 중 하나가 앞면이 나온 경우 비김 모두 앞면이 나온 경우 2000 원을 가짐 동전을 던져서 내가 딴 돈의 금액을 \\(X\\) 라고 하면 \\(X\\)는 -1000, 0, 2000 의 값을 갖는 확률변수이고 다음과 같은 표본공간을 가짐 \\[ S = \\{HH,~HT,~TH,~TT \\} \\] 위의 사건들은 다음과 같이 처음 정한 금액에 대응됨. HH \\(\\rightarrow\\) \\(X = 2000\\) HT \\(\\rightarrow\\) \\(X = 0\\) TH \\(\\rightarrow\\) \\(X = 0\\) TT \\(\\rightarrow\\) \\(X = -1000\\) 따라서, 각 금액에 대응한 확률은 x -1000 0 2000 p 1/4 2/4 1/4 게임에서 내가 얻을 금액에 대한 기댓값 \\[ E(X) = -0.25 \\times 1000 + 0 \\times 0.5 + 2000 \\times 0.25 = 250 \\] 구현 동전 던지기 시뮬레이션 코드에서 사용한 sample() 함수 사용 금액과 각 금액에 대응하는 확률값, 시행 횟수를 함수의 인수로 입력 simple_game &lt;- function(x, p, ntry = 10) { record &lt;- sample(x, size = ntry, replace = TRUE, prob = p) expect &lt;- mean(record) cat(&quot;당신이 이 게임을 무한히 반복한다면 평균적으로 &quot;, expect, &quot;원을 가져갈 것입니다.&quot;, &quot;\\n&quot;) } x &lt;- c(-1000, 0, 2000) p &lt;- c(1/4, 2/4, 1/4) set.seed(2371) simple_game(x = x, p = p, ntry = 10) # 10회 실행 당신이 이 게임을 무한히 반복한다면 평균적으로 900 원을 가져갈 것입니다. simple_game(x = x, p = p, ntry = 50) # 50회 실행 당신이 이 게임을 무한히 반복한다면 평균적으로 40 원을 가져갈 것입니다. simple_game(x = x, p = p, ntry = 100) # 100회 실행 당신이 이 게임을 무한히 반복한다면 평균적으로 170 원을 가져갈 것입니다. simple_game(x = x, p = p, ntry = 1000) # 1000회 실행 당신이 이 게임을 무한히 반복한다면 평균적으로 234 원을 가져갈 것입니다. simple_game(x = x, p = p, ntry = 10000) # 10000회 실행 당신이 이 게임을 무한히 반복한다면 평균적으로 241.2 원을 가져갈 것입니다. simple_game(x = x, p = p, ntry = 100000) # 100000회 실행 당신이 이 게임을 무한히 반복한다면 평균적으로 247.64 원을 가져갈 것입니다. sum(x*p) # 실제값 [1] 250 확률 및 기대값 추정 모두 시행횟수가 증가할 수록 실제 이론적 값에 근사하는 것을 눈으로 확인 가능함. 즉, 통계학의 근간이 되는 대수의 법칙(law of large number) 에 따른 자연스러운 결과임. 3.4.3 몬테칼로 적분법(sample-mean Monte-carlo integration) 컴퓨터를 이용해 적분값 계산 시, 적분하고자 하는 적절한 차수의 도함수가 존재하는 경우 일반적으로 수치적분법(직사각형, 사다리꼴, simpson 적분법 등)을 사용할 수 있으나, 도함수가 존재하지 않을 경우 또는 다중 적분을 해야하는 경우 수치적분법 적용이 어려움. 몬테칼로 적분법은 복잡한 적분식에 대한 해를 구하기(추정하기) 위해 고안되었으며 매우 간단하게 적분식의 해를 찾을 수 있는 장점이 있음. 대략적 원리는 다음과 같음. 함수의 적분값을 하나의 모수로 보고 임의표본추출을 통해 해당 모수를 추정 \\[ E[f(x)] = \\int f(x) p(x) dx \\approx \\frac{1}{N}\\sum_{i=1}^{N}f(x_i) \\] 적중법(Hit or miss) \\(f(x) = 2 + \\cos(x + \\sin(\\arctan(x) + 3)\\) 일 때, \\(a = 1\\) 에서 \\(b = 3\\) 아래 면적은 다음과 같음 \\[ I = \\int_{a = 1}^{b = 3} f(x)~dx \\] x &lt;- seq(0, pi, length = 500) y &lt;- 2 + cos(x + sin(atan(x)) + 3) plot(x, y, type = &quot;n&quot;, ylim = c(0, 4), xlim = c(0, 3.5)) idx &lt;- x &gt;= 1 &amp; x &lt;= 3 polygon(c(1, x[idx], 3), c(0, y[idx], 0), col = &quot;darkgray&quot;, border = &quot;darkgray&quot;) lines(x, y, lwd = 1.5) rect(1, 0, 3, 4, lty = 1) abline(h = 4, lty = 2) text(3, 0.1, &quot;Hit&quot;, cex = 2.5, adj = 1, pos = 2) text(1, 3.9, &quot;Miss&quot;, cex = 2.5, adj = 0) text(2.2, 2.8, &quot;f(x)&quot;, cex = 2.5) 위 그림에서 \\(x\\) 축과 평행한 \\(y = c\\)의 선을 그었을 때 \\(a\\), \\(b\\) 구간 상에 사각형 면적은 \\(c(b-a)\\) 임. 사각형에서 \\(I\\)가 차지하는 비율을 \\(p\\) 라고 할 때, \\(I = c(b - a)p\\) 임. 위 사각형 안에 랜덤하게 N개의 점을 x-y 좌표 상에 찍었을 때, \\(f(x)\\) 아래 놓인 점의 개수를 \\(X\\)라고 하면 \\(X\\)은 모수가 \\(N\\), \\(p\\)인 이앙분포를 따름. 따라서 \\(\\hat{p} = X/N\\)이고 \\(f(x)\\) 아래 면적 \\(I\\)의 추정값은 아래와 같음. \\[ \\hat{I} = c(b - a)\\frac{X}{N} \\] 구현: \\(\\pi\\) 값 계산 Idea: 원의 면적은 \\(\\pi r^2\\)이므로 반지름이 1인 경우 \\(\\pi\\)랑 동일 \\(\\rightarrow\\) \\(x^2 + y^2 = 1\\)인 원을 고려 1사분면에 해당하는 영역에서 랜덤하게 점을 찍은 후 4분원의 면적을 추정한 다음 4를 곱하면 \\(\\pi\\) 값 추정 가능 hit_pi &lt;- function(ntry) { X &lt;- 0 for (i in 1:ntry) { xy &lt;- runif(2, 0, 1)^2 if (sum(xy) &lt; 1) X &lt;- X + 1 } cat(&quot;Estimated pi: &quot;, sprintf(&quot;%.6f&quot;, 4 * X/ntry, &quot;\\n&quot;)) } set.seed(314) hit_pi(100) # 100 Estimated pi: 3.000000 hit_pi(1000) # 1,000 Estimated pi: 3.184000 hit_pi(10000) # 10,000 Estimated pi: 3.148000 hit_pi(100000) # 100,000 Estimated pi: 3.140080 hit_pi(1000000) # 1,000,000 Estimated pi: 3.137764 system.time(hit_pi(5000000)) # 5,000,000 Estimated pi: 3.141950 사용자 시스템 elapsed 10.310 0.000 10.318 pi [1] 3.141593 표본평균을 활용한 몬테칼로 적분 적중법의 비효율성 개선 적분을 어떤 확률변수의 기댓값으로 표현하여 적분값을 추정 확률변수 \\(X \\sim \\mathrm{Uniform(a, b)}\\) 일 때, \\[ E[f(x)] = \\int_a^{b} f(x)p(x)~dx = \\frac{1}{b - a}\\int_a^b f(x)~dx \\] - 적분값은 \\[ \\begin{aligned} I &amp;= \\int_a^b f(x)~d(x) = (b-a)E[f(x)] \\\\ E[f(x)] &amp;= \\frac{1}{N}\\sum_{i = 1}^N f(x_i),~~ x_i \\stackrel{iid}{\\sim} \\mathrm{Uniform}(a, b) \\end{aligned} \\] 구현: \\(\\pi\\) 계산시간 비교 mean_pi &lt;- function(ntry) { x &lt;- runif(ntry, -1, 1) I = 4*mean(sqrt(1 - x^2)) cat(&quot;Estimated pi: &quot;, sprintf(&quot;%.6f&quot;, I), &quot;\\n&quot;) } set.seed(314) mean_pi(100) # 100 Estimated pi: 3.251687 mean_pi(1000) # 1,000 Estimated pi: 3.155947 mean_pi(10000) # 10,000 Estimated pi: 3.140608 mean_pi(100000) # 100,000 Estimated pi: 3.143188 mean_pi(1000000) # 1,000,000 Estimated pi: 3.140865 system.time(mean_pi(5000000)) # 5,000,000 Estimated pi: 3.141221 사용자 시스템 elapsed 0.160 0.015 0.175 3.4.4 Buffon의 바늘 실험 간격이 \\(d\\)인 평행선들이 그려져 있는 책상 위에 길이가 \\(l\\) 인 바늘을 던졌을 때, 이 바늘이 책상 위에 그려진 선에 걸쳐질 확률 원문: 떨어진 거리가 같은 평행선들이 그어진 마룻바닥에 바늘을 떨어뜨렸다. 바늘이 금에 닿을 확률은 얼마인가? Georges-Louis Leclerc, Comte de Buffon (1777) 조건 바늘의 길이는 선 사이 간격보다 작다(\\(l &lt; d\\)) Figure 3.2: Buffon의 바늘실험: 바늘이 선에 걸쳐진 경우 Figure 3.3: Buffon의 바늘실험: 바늘이 선에 걸쳐지지 않은 경우 \\(m\\): 바늘의 중앙점 \\(a\\): 두 평행선 중 \\(m\\)과 가까운 평행선에서 \\(m\\) 까지의 직선거리 \\(\\theta\\): 바늘과 평행선이 이루는 각도 Fact \\(d &gt; l\\) 조건 하에서 \\(a\\)는 가장 가까운 선과의 직선거리이기 때문에 \\(d/2\\)보다 클 수 없음 \\(\\rightarrow\\) \\(0 \\leq a \\leq d/2\\) \\(\\rightarrow\\) \\(a \\sim \\mathrm{Uniform}(0, d/2)\\) 선을 벗어난 바늘 끝을 지나는 가상의 평행선과 \\(m\\) 사이의 수직 거리는 \\(l/2\\sin \\theta\\) 바늘이 선에 걸치는 경우는 \\(l/2\\sin \\theta\\) 가 \\(a\\) 보다 긴 경우임 \\(\\rightarrow\\) \\(0 \\leq a \\leq l/2\\sin \\theta\\) \\(\\rightarrow\\) \\(\\theta \\sim \\mathrm{Uniform}(0, \\pi)\\) \\(\\therefore\\) 바늘이 선에 걸쳐질 확률은 \\[ P(바늘이~걸쳐질 ~확률) = P\\left (0 \\leq a \\leq \\frac{l}{2} \\sin \\theta \\right ) \\] 두 확률변수의 결합분포를 구한 후 결합밀도함수에 대한 적분값(확률)을 구하는 문제!! 수학적 표현 \\(a\\) 에 대한 확률분포 \\[ a \\sim \\mathrm{Uniform}(0, d/2) = \\begin{cases} \\frac{2}{d}, &amp; 0 \\leq a \\leq d/2 \\\\ 0, &amp; \\mathrm{otherwise} \\end{cases} \\] \\(\\theta\\) 에 대한 확률분포 \\[ \\theta \\sim \\mathrm{Uniform}(0, \\pi) = \\begin{cases} \\frac{1}{\\pi}, &amp; 0 \\leq \\theta \\leq \\pi \\\\ 0, &amp; \\mathrm{otherwise} \\end{cases} \\] 두 확률변수가 독립이기 때문에 \\(a\\)와 \\(\\theta\\)의 결합분포는 아래와 같음 \\[ f(a, \\theta) = \\begin{cases} \\frac{2}{d\\pi}, &amp; 0 \\leq a \\leq d/2;~ 0 \\leq \\theta \\leq \\pi \\\\ 0, &amp; \\mathrm{otherwise} \\end{cases} \\] 따라서 바늘이 평행선에 걸쳐질 확률은 \\[ \\begin{align} P\\left (0 \\leq a \\leq \\frac{l}{2} \\sin \\theta \\right ) &amp;= \\int_{\\theta = 0}^{\\pi}\\int_{a = 0}^{(l/2)\\sin \\theta} \\frac{2}{d\\pi} \\,da\\,d\\theta\\\\ &amp;= \\int_{\\theta = 0}^\\pi \\frac{l\\sin\\theta}{d\\pi}\\,d\\theta \\\\ &amp;= \\frac{l\\cos\\theta}{d\\pi} \\Big|_{0}^\\pi = \\frac{2l}{d\\pi} \\end{align} \\] 위 식을 이용해 모의실험을 통해 \\(\\pi\\) 값 추정이 가능. \\[ \\hat{\\pi} = \\frac{2l}{d\\hat{P}} \\] 실제 모의실험 시 확률 계산 방법 바늘의 중점에서 가장 가까운 평행선 까지 수평 거리는 \\(d/2\\) 안에 있기 때문에 표본공간(\\(S\\))은 다음과 같이 정의할 수 있음. \\[ S = \\{(a, \\theta)|0 \\leq a \\leq \\frac{d}{2}, ~ 0 \\leq \\theta \\leq \\pi \\} \\] 표본공간 \\(S\\)에서 \\(\\frac{l}{2} \\sin \\theta\\)의 함수 아래 면적(\\(A\\))이 결국 바늘이 평행선 상에 걸칠 확률임. 따라서 \\[ P\\left (0 \\leq a \\leq \\frac{l}{2} \\sin \\theta \\right ) = \\frac{\\mathrm{A}의~넓이}{\\mathrm{S}의~넓이} = \\frac{\\int_0^{\\pi} 0.5l\\sin{\\theta}~d\\theta}{0.5d\\pi} = \\frac{2l}{d\\pi} \\] 기하학적 표현 # l = 1, d = 2 l &lt;- 1; d &lt;- 2 x &lt;- seq(0, pi, by = 0.01) y &lt;- 0.5 * l * sin(x) plot(1, xlim = c(0, pi), ylim = c(0, d/2), type = &quot;n&quot;, xlab = expression(theta), ylab = &quot;d/2&quot;, cex.lab = 1.5) polygon(x, y, col = &quot;yellow&quot;, border = &quot;yellow&quot;) lines(x = x, y = y, lty = 1, lwd = 2) rect(0, 0, pi, 1, lty = 2, lwd = 1.5) text(x = 1.5, y = 0.6, expression(paste(f, &quot;(&quot;, theta, &quot;)&quot; == frac(l, 2) * sin * theta)), adj = 0, cex = 2) text(x = 0.05, y = 0.95, &quot;S&quot;, adj = c(0,1), cex = 2) text(x = pi/2, y = 0.2, &quot;A&quot;, adj = 0, cex = 2) Figure 3.4: Buffon 바늘 실험의 표본 공간과 확률 영역 Implementation 실제 바늘이 던져지는 상황 시각화 Buffon의 바늘실험(30회 실행), 그림은 buffon_needle_draw.R 함수 참고 buffon_needle_draw &lt;- function(nmax = 20, l = 0.8, # 바늘의 길이 d = 1, # 두 평생선 간 간격 col = c(&quot;lightgray&quot;, &quot;red&quot;), plot = TRUE, return.value = FALSE) { # 반복 초기화 j &lt;- 1; n &lt;- 0 # x &lt;- y &lt;- x0 &lt;- y0 &lt;- theta &lt;- a &lt;- rep(NA, ani.options(&quot;nmax&quot;)) x &lt;- y &lt;- x0 &lt;- y0 &lt;- theta &lt;- a &lt;- rep(NA, nmax) while (j &lt;= length(x)) { theta[j] &lt;- runif(1, 0, pi) a[j] &lt;- runif(1, 0, d/2) y[j] &lt;- sample(c(0.5 * d + a[j], 1.5 * d - a[j]), 1) x[j] &lt;- runif(1, 0, l) # 바늘이 떨어졌을 때 수평선과 이루는 각도 반영 x0[j] &lt;- 0.5 * l * cos(theta[j]) y0[j] &lt;- 0.5 * l * sin(theta[j]) j &lt;- j + 1 if (plot) { dev.hold() plot(1, xlim = c(-0.5*l, 1.5*l), ylim = c(0, 2*d), type = &quot;n&quot;, xlab = &quot;&quot;, ylab = &quot;&quot;, axes = FALSE) axis(1, c(0, l), c(&quot;&quot;, &quot;&quot;), tcl = -1) axis(1, 0.5 * l, &quot;L&quot;, font = 3, tcl = 0, cex.axis = 1.5, mgp = c(0, 0.5, 0)) axis(2, c(0.5, 1.5) * d, c(&quot;&quot;, &quot;&quot;), tcl = -1) axis(2, d, &quot;D&quot;, font = 3, tcl = 0, cex.axis = 1.5, mgp = c(0, 0.5, 0)) box() bd &lt;- par(&quot;usr&quot;) # 실제 device plot 영역 상 x-y 좌표 시작 끝 점 정보 반환 rect(bd[1], 0.5 * d, bd[2], 1.5 * d, col = col[1]) abline(h = c(0.5 * d, 1.5 * d), lwd = 2) # 그림 1: 부폰의 바늘 실험: 바늘과 평행선 # 실제 바늘이 평행선 안에 떨어지는 모습 모사 segments(x - x0, y - y0, x + x0, y + y0, col = col[2]) dev.flush() # Sys.sleep(1) } } if(return.value) { result &lt;- list(nmax =nmax, l = l, d = d, a = a, theta = theta) return(result) } } # buffon_needle_draw(nmax = 20, l = 0.8, d = 1, plot = TRUE, return.value = FALSE) set.seed(5000) # 바늘의 길이가 15이고 평행선 간격이 20일 때 바늘이 평행선에 걸칠 확률 param &lt;- buffon_needle_draw(nmax = 5000, l = 15, d = 20, plot = FALSE, return.value = TRUE) \\(P(A)\\) 계산: 표본공간 및 바늘을 던졌을 때 표본공간 안에 바늘이 들어와 있는지 확인 \\(\\rightarrow\\) 바늘이 금에 걸쳐질 확률 계산 step 0: 바늘의 길이(\\(l\\))과 수평선 사이 거리(\\(d\\)) 설정 step 1: \\(a ~ \\mathrm{Uniform}(0, d/2)\\)에서 난수 한개 발생 step 2: \\(\\theta ~ \\mathrm{Uniform}(0, \\pi)\\)에서 난수 한개 발생 step 3: 바늘이 선에 걸치는 경우(\\(a \\leq 0.5l\\sin{\\theta}\\)) 카운트한 후 확률 계산 buffon_prob &lt;- function(param, plot = TRUE, ndraw = 20) { # browser() l &lt;- param$l d &lt;- param$d a &lt;- param$a theta &lt;- param$theta ntry &lt;- length(a) A &lt;- a &lt;= 0.5 * l * sin(theta) phati &lt;- cumsum(A)/(1:ntry) phat &lt;- sum(A)/ntry # 시뮬레이션 추정 확률 ptrue &lt;- 2*l/(pi*d) # 이론적 확률 idx &lt;- NULL if (plot) { for (i in 1:ndraw) { dev.hold() x = seq(0, pi, by = 0.01) plot(x, 0.5 * l * sin(x), type = &quot;l&quot;, ylim = c(0, 0.5 * d), bty = &quot;l&quot;, xlab = &quot;&quot;, ylab = &quot;&quot;, col = &quot;black&quot;) # rect(0, 0, pi, d/2, lty = 2, lwd = 1.5) text(pi/2, 0.4 * l, expression(y == frac(L, 2) * sin(theta)), cex = 1.5) idx = c(idx, as.numeric(a[i] &gt; 0.5 * l * sin(theta[i])) + 1) points(theta[1:i], a[1:i], col = c(&quot;red&quot;, &quot;blue&quot;)[idx]) phatii &lt;- format(phati[i], nsmall = 6, digits = 6) legend(&quot;topright&quot;, legend = substitute(hat(P) == phatii, list(phatii = phatii)), bty = &quot;n&quot;, cex = 1.3) dev.flush() # Sys.sleep(0.05) } } cat(&quot;True Probability:&quot;, sprintf(&quot;%.3f&quot;, ptrue), &quot;\\n&quot;) cat(&quot;Estimated Probability:&quot;, sprintf(&quot;%.3f (total %d dropping)&quot;, phat, ndraw), &quot;\\n&quot;) } buffon_prob(param, plot = FALSE, ndraw = 5000) True Probability: 0.477 Estimated Probability: 0.478 (total 5000 dropping) Buffon의 바늘실험(500 회 실행): 표본공간 상 바늘을 던졌을 때 사건 A 집계 과정 추정한 \\(\\hat{\\pi}\\) 값이 횟수가 증가할수록 실제 \\(\\pi\\) 값에 수렴하는지 확인 buffon_pi_estimate() buffon_pi_estimate &lt;- function(param, plot = TRUE, ndraw = 20) { # browser() l &lt;- param$l d &lt;- param$d a &lt;- param$a theta &lt;- param$theta ntry &lt;- length(a) A &lt;- a &lt;= 0.5 * l * sin(theta) csum_A &lt;- cumsum(A) phat &lt;- csum_A/(1:ntry) # i 번째 시행 때 까지 바늘이 선에 걸쳐질 확률 pihat &lt;- (2 * l)/(d * phat) # pi 계산 if (plot) { for (i in 1:ndraw) { dev.hold() plot(pihat[1:i], ylim = c((1 - 0.5) * pi, (1 + 0.5) * pi), xlim = c(0, ndraw), xlab = paste(&quot;바늘 던진 횟수:&quot;, i), ylab = expression(hat(pi)), type = &quot;l&quot;, col = &quot;black&quot;, cex.lab = 1.5) abline(h = pi, lty = 2, col = &quot;red&quot;) # phati &lt;- sprintf(&quot;%.6f&quot;, pihat[i]) pihati &lt;- format(pihat[i], nsmall = 7, digits = 7) legend(&quot;topright&quot;, legend = substitute(hat(pi) == pihati, list(pihati = pihati)), bty = &quot;n&quot;, cex = 1.3) dev.flush() # Sys.sleep(0.05) } } cat(&quot;Estimated pi: &quot;, sprintf(&quot;%.6f (%d dropping)&quot;, pihat[ndraw], ndraw)) } buffon_pi_estimate(param, plot = FALSE, ndraw = 5000) Estimated pi: 3.139389 (5000 dropping) Buffon의 바늘실험(500 회 실행): PI 추정 과정 "],
["시뮬레이션과-통계학.html", "3.5 시뮬레이션과 통계학", " 3.5 시뮬레이션과 통계학 통계학에서 다루는 많은 이론들은 모의실험을 통해 그 이론의 의미를 더욱 명확하게 확인 가능하다. 특히 본 절에서는 데이터 분석 실무에서 꼭 알아두어야 할 중요 개념에 대해 간단히 review를 하고, 중심극한정리(central limit theorem, CLT), 신뢰구간(confidence interval), p-value 등에 대한 모의실험을 통해 이해를 증진 혈압강하제 임상시험 DBP.txt: 통계패키지활용 Github 저장소에서 데이터 확인 가능 1960년대 중반 미국에서 실시한 고혈압 치료제 유효성 확인을 위한 임상시험 결과 데이터 총 40명의 고혈압 환자를 대상으로 임상시험을 실시했으며, 랜덤하게 환자를 고혈압 치료제 투여군(A)과 위약군(B)에 균등하게 배정 기처지(baseline, DBP1) 측정 이후 월 단위로 4 번 이완기 혈압(diastolic blood pressure, DBP)을 측정(DBP2 ~ DBP5) 유효성 평가는 기저치 대비 투약 4 개월 후 DBP의 변화(감소)량(d = DBP5 - DBP1)이 두 군간 차이를 보이는지… 데이터 요약 # 데이터 불러오기 DBP &lt;- read_delim(&quot;data/DBP.txt&quot;, delim = &quot;\\t&quot;) Parsed with column specification: cols( Subject = col_double(), TRT = col_character(), DBP1 = col_double(), DBP2 = col_double(), DBP3 = col_double(), DBP4 = col_double(), DBP5 = col_double(), Age = col_double(), Sex = col_character() ) # 변화량 변수 추기 DBP &lt;- DBP %&gt;% mutate(DIFF = DBP5 - DBP1) # 각 투약군 별 변화량 측정값 DBP$DIFF[DBP$TRT == &quot;A&quot;] [1] -9 -15 -21 -14 -11 -15 -19 -18 -11 -18 -16 -14 -15 -19 -13 -14 -15 -17 -14 [20] -16 DBP$DIFF[DBP$TRT == &quot;B&quot;] [1] -1 -6 -5 1 -7 -4 -4 -6 -6 -7 -2 -8 -6 -5 -6 -8 -7 -4 -2 -3 # 요약 통계량 DBP %&gt;% group_by(TRT) %&gt;% summarise(N = n(), Mean = mean(DIFF, na.rm = TRUE), SD = sd(DIFF, na.rm = TRUE), Min = min(DIFF, na.rm = TRUE), Max = max(DIFF, na.rm = TRUE), Median = median(DIFF, na.rm = TRUE), Q1 = quantile(DIFF, probs = 0.25), Q3 = quantile(DIFF, probs = 0.75)) %&gt;% kbl %&gt;% kable_paper `summarise()` ungrouping output (override with `.groups` argument) TRT N Mean SD Min Max Median Q1 Q3 A 20 -15.2 2.966479 -21 -9 -15.0 -17.25 -14.00 B 20 -4.8 2.419221 -8 1 -5.5 -6.25 -3.75 데이터 시각화 # 변화량 데이터의 분포 확인(치료약에 대해서) ## ggplot 사용 # require(tidyverse) require(ggpubr) DBP %&gt;% ggplot() + aes(x = DIFF, fill = TRT) + geom_density(color = &quot;white&quot;, alpha = 0.2) + scale_x_continuous(limits = c(-25, 5)) + geom_histogram(aes(y = ..density..), color = &quot;white&quot;, binwidth = 1.8, alpha = 0.4) + scale_fill_manual(values = c(&quot;red&quot;, &quot;blue&quot;)) + theme_minimal() -&gt; p1 DBP %&gt;% ggplot() + aes(x = TRT, y = DIFF, fill = TRT) + geom_boxplot(alpha = 0.4) + scale_fill_manual(values = c(&quot;red&quot;, &quot;blue&quot;)) + theme_minimal() -&gt; p2 # 두 개 플롯을 한 화면에 표시하기 위한 함수 ggarrange(p1, p2, ncol = 1, common.legend = TRUE) 위 데이터로부터 어떤 결론을 도출할 수 있을까? 혈압치료제 A는 4 개월 복용 후 DBP를 감소시키는가? 위약 B를 4 개월 복용 후에도 DBP를 감소 시키는가? 치료약 A는 위약 B보다 효과가 있는가? 위약 대비 치료약 A의 효과는 어느 정도인가? 다른 고혈압 환자가 치료제 A를 복용하면 어떤 효과가 있을까? require(tidymodels) # Question 1-2: 일표본 t 검정 DBP %&gt;% mutate_if(is.character, factor) %&gt;% group_by(TRT) %&gt;% nest %&gt;% # group 변수 별로 데이터 나누기 # split한 데이터셋 각각에 일표본 t-검정 실시 mutate(t_test_result = map(data, ~ t.test(.x$DIFF))) %&gt;% # ttest 결과로부터 통계량 추출 후 tibble로 변환 mutate(result = map(t_test_result, ~ tidy(.x))) %&gt;% select(TRT, result) %&gt;% unnest(cols = result) %&gt;% mutate_at(vars(statistic, conf.low, conf.high), format, digits = 3) %&gt;% mutate(p.value = format(p.value, digits = 2)) %&gt;% select(-method, -alternative) %&gt;% set_names(c(&quot;Treatment&quot;, &quot;$\\\\hat{\\\\delta}$&quot;, &quot;t-value&quot;, &quot;p-value&quot;, &quot;df&quot;, &quot;LCL (95%)&quot;, &quot;UCL (95%)&quot;)) %&gt;% kbl(escape = FALSE) %&gt;% kable_paper Treatment \\(\\hat{\\delta}\\) t-value p-value df LCL (95%) UCL (95%) A -15.2 -22.9 2.6e-15 19 -16.6 -13.8 B -4.8 -8.87 3.5e-08 19 -5.93 -3.67 # Question 3-4: 독립 이표본 t 검정 t.test(DIFF ~ TRT, data = DBP, var.equal = TRUE) Two Sample t-test data: DIFF by TRT t = -12.15, df = 38, p-value = 1.169e-14 alternative hypothesis: true difference in means is not equal to 0 95 percent confidence interval: -12.132758 -8.667242 sample estimates: mean in group A mean in group B -15.2 -4.8 중요 용어 모집단(population): 조사/실험/연구 등에서 관심의 대상이 되는 모든 개체의 관측값, 사건, 항목, 측정단위의 집합 \\(\\rightarrow\\) 획득한 데이터가 랜덤하게 표집되었다고 가정하는 분포 또는 집단 대한민국 20대 남녀을 대상으로 측정한 관찰값(예: 키, 몸무게, 설문지, 혈액검사, ECG, EEG 등) 모수(parameter): 모집단의 특성 또는 분포를 정의하는 알려지지 않은 상수(수식 표현 시 일반적으로 greek 문자로 표시) 이항분포(binomial distribution): 성공 또는 실패 중 하나가 결과로 나오는 실험을 \\(n\\) 번 시행했을 때 성공이 나올 확률 \\(\\theta\\) 정규분포(normal distribution): 평균 \\(\\mu\\), 표준편차 \\(\\sigma\\) 가설검정(hypothesis testing): 표본으로부터 얻은 정보를 토대로 모집단에 대한 특정 가설을 받아들이거나(accept) 혹은 기각(reject)을 위한 통계적 절차 귀무가설(null hypothesis): 모수에 대한 기존의 사실 또는 디폴트 값 두 측정 변수 간 연관성이 존재하지 않음/ 두 집단 간 평균의 차이가 없음 … \\(H_0: \\mu_X = \\mu_Y\\), \\(\\rho_{XY} = 0\\), … 대립가설(alternative hypothesis): 모수에 대해 귀무가설과 대립해 증명하고 싶은 사실 또는 연구자가 입증하고 싶어하는 가설 \\(H_1: \\mu_X \\neq \\mu_Y\\), \\(\\rho_{XY} \\neq 0\\) 1종 오류(type I error): 사실인 귀무가설을 기각할 사건(오류) 2종 오류(type II error): 대립가설이 사실인데 이를 기각한 사건 = 귀무가설이 거짓인데 귀무가설을 기각하지 않은 사건 P 값(p-value): 귀무가설이 참일 때 실제 데이터가 보여준 정도로 특이한 값이 관측될 확률 \\(\\rightarrow\\) 귀무가설 하에서 실제 데이터로부터 얻은 통계량이 관찰된 것과 같거나 그 이상의 극단적 결과를 얻을 확률 \\(\\rightarrow\\) 귀무가설이 참이라는 검정 통계량을 바탕으로 귀무가설을 기각했을 때 실제로 제 1종 오류를 범할 최대 확률 p-value = 0.5: 귀무가설 하에서 주어진 데이터로부터 얻은 통계량보다 크거나 작은 값들이 두 번에 한 번 꼴로 관찰 \\(\\rightarrow\\) 귀무가설을 기각하기에 충분한 근거가 아님 p-value = 0.0001: 귀무가설 하에서 데이터로부터 획득한 통계량만큼의 값을 관찰할 확률이 매우 낮음 \\(\\rightarrow\\) 귀무가설 기각하기에 충분한 근거 표본(sample): 통계적 처리를 위해 임의의 모집단으로부터 관찰된 일부 관찰값 또는 측정값의 집합 용어 연결(DBP 예제) 모집단: 미국 또는 지구 상 존재하는 모든 고혈압 환자 모수: 고혈압 환자에 치료약(A)와 위약(B)을 투여 했을 때, 기저치 대비 4개월 후 DBP 변화량의 평균 표본: 랜덤하게 표집된 전체 40명의 고혈압 환자(각 투여군 당 20 명씩 무작위로 배정된 고혈압 환자) 통계량: 각 투여군 별 기저치 대비 4개월 후 DBP 변화(감소)량의 평균 귀무가설: 치료약 A와 위약 B를 투여 했을 때 두 집단 간 DBP 변화(감소)량은 차이가 없다. 대립가설: 치료약 A를 투여 했을 때 DBP의 기저치 대비 변화(감소)량은 위약군에 비해 크다(같지 않다). 1종 오류: 실제 치료약 A와 위약 B의 DBP 변화량이 차이가 없음에도 불구하고 차이가 있다고 결론내릴 오류 2종 오류: 실제 치료약 A와 위약 B의 DBP 변화량이 차이가 있는데 이를 감지하지 못해 차이가 없다고 결론내릴 오류 P 값: 실제 두 투약군 간 차이가 없을 때 데이터가 보여준 두 군간 평균 변화량이 관찰된 값 이상의 극단적 결과를 얻을 확률 표본분포 통계학의 가장 중요한 개념: 우리가 현재 관측한 데이터는 특정 모수를 갖는 모집단에서 관측될 수 있는 여러 가능한 데이터 중 하나임. 예를 들어 DBP 예제처럼 또 다른 40명을 추출해 동일한 임상시험을 진행한다고 하면 DBP 변화량은 현재 데이터와 동일한 관찰값을 가지진 않을 것임. 즉, 표본을 추출할 때 마다 표본 간 그리고 표본 내 자연스러운 변동이 존재할 것임. 빈도론적 관점에서 통계학은 모집단으로부터 각기 다른 표본(일종의 평행우주)을 무수히 많이 추출 했다고 보고 이를 일반화 하는데서 모든 추론이 시작됨. 통계량(statistics): 모수를 추정하기 위해 표본(데이터)로부터 계산된 값(일반적으로 알파벳으로 표시) 표본평균 \\(\\bar{X}\\), 표본분산 \\(s^2\\) 통계량은 확률변수(random variable) 표본푼포(sampling distribution): 통계량의 분포. 즉, 여러 평행우주(표본)으로부터 도출한 각기 다른 값을 갖는 통계량이 이루는 분포 실제 관찰한 데이터 외에 “평행우주”로 지칭되는 나머지 표본은 관측되지 않은 값 \\(\\rightarrow\\) 시뮬레이션을 통해 가상의 평행우주를 생성 가능함 Figure 2.8: 모집단, 표본, 통계량, 표본분포 관계 DBP 예제에서 독립 이표본 t-검정을 시뮬레이션을 통해 확인 # 1. 현재 획득한 표본으로부터 필요한 통계량 계산 n1 &lt;- n2 &lt;- 20 n &lt;- n1 + n2 # 전체 표본 수 mu_real &lt;- tapply(DBP$DIFF, DBP$TRT, mean) sigma_real &lt;- tapply(DBP$DIFF, DBP$TRT, sd) delta_real &lt;- -diff(mu_real) sp &lt;- sqrt(mean(sigma_real^2)) tval &lt;- delta_real/(sp * sqrt(1/n1 + 1/n2)) set.seed(38317) # 귀무가설이 참(mu_a = mu_b)이라는 가정 하에서 # DBP 변화량의 두 군 간 차이에 대해 10,000개의 표본(평행우주) 생성 # 단, 분산(표준편차)은 현재 획득한 표본으로부터 구한 # 합동표준편차(분산)과 동일하다고 가정 # 표본 개수는 40개로 동일 B &lt;- 10000 delta_star &lt;- replicate(B, rnorm(n, 0, sp)) md_star &lt;- apply(delta_star, 2, mean) sd_star &lt;- apply(delta_star, 2, sd) t_star &lt;- md_star/(sd_star * sqrt(1/n1 + 1/n2)) par(mfrow = c(2, 2)) hist(md_star, nclass = 100, main = expression(Histogram~of~bar(delta)), xlim = c(-11, 2)) abline(v = delta_real, col = &quot;red&quot;) hist(sd_star, nclass = 100, main = expression(Histogram~of~s[p])) abline(v = sp, col = &quot;red&quot;) hist(t_star, nclass = 100, main = expression(Histogram~of~t[0]), xlim = c(-12.5, 3)) abline(v = tval, col = &quot;red&quot;) qqnorm(t_star); qqline(t_star) # p-value 계산: 귀무가설 하에 관찰한 통계량만큼 큰(작은) 값이 발생할 확률 length(which(t_star &lt; tval))/B [1] 0 중심극한정리 표본평균이 갖는 확률분포에 대한 정리 모집단의 분포와 관계 없이 표본의 크기(수)가 무한하게 크다면 표본평균의 분포는 정규분포에 근사 평균이 \\(\\mu\\) 이고, 분산이 \\(\\sigma^2\\) 인 임의의 모집단에서 추출한 표본 \\(X_{1}, X_2, \\ldots, X_n\\) 의 평균 \\(\\bar{X}\\) 의 분포는 \\(n\\rightarrow\\infty\\) 일 때(충분히 클 때), 근사적으로 평균이 \\(\\mu\\) 이고 분산이 \\(\\sigma^2 /n\\)인 정규분포를 따르고, \\(Z=\\sqrt{N}(\\bar X - \\mu)/\\sigma\\) 의 분포는 표준정규분포 \\(N(0, 1)\\)에 근사함. 통계적 추론의 핵심인 가설검정의 이론적 토대 마련 경험적으로 \\(n \\geq 30\\) 이면 표본평균 \\(\\bar X\\)는 정규분포를 따름 만약 표본의 크기가 무한하게 크다면( \\(n\\rightarrow\\infty\\) ), 표본평균의 분산은 0에 가까워 질 것이기 때문에 \\(\\bar X\\) 를 모평균 \\(\\mu\\)로 간주할 수 있음 # CLT 시각화를 위한 일반 함수 clt_test &lt;- function(rep = 300, # 반복 수 n = 50, mtrue = NULL, strue = NULL, FUN = rbinom, plot = TRUE, sim.out = FALSE, ...) { # browser() dots &lt;- list(...) x &lt;- matrix(nrow = n, ncol = rep) for (i in 1:n) { x[i, ] &lt;- apply(matrix(drop( mapply(FUN, i*rep, MoreArgs = dots)), i, rep), 2, mean) } if (is.null(mtrue)) mtrue = NA if (is.null(strue)) strue = NA mf &lt;- match.call() FUN.name &lt;- as.character(mf$FUN) title_name &lt;- switch(FUN.name, rbinom = &quot;Binomial distribution&quot;, rpois = &quot;Poisson distribution&quot;, runif = &quot;Uniform distribution&quot;, rexp = &quot;Exponential distribution&quot;, rnorm = &quot;Normal distribution&quot;, rchisq = expression(chi^2 ~ distribution), rt = &quot;t distribution&quot;) xlim &lt;- quantile(x, c(0.005, 0.995)) # norm_line_x &lt;- seq(xlim[1], xlim[2], length = 300) if (plot) { for (i in 1:n) { dev.hold() hist(x[i, ], freq = FALSE, main = title_name, xlab = substitute(italic(bar(X)[N == i]), list(i = i)), xlim = xlim) lines(density(x[i, ]), col = &quot;red&quot;) if (!is.na(mtrue) &amp;&amp; !is.na(strue)) { curve(dnorm(x, mtrue, strue/sqrt(i)), col = &quot;blue&quot;, lty = 2, add = TRUE) legend(&quot;bottomright&quot;, legend = bquote(mu == .(sprintf(&quot;%.3f&quot;, mtrue)) ~ sigma/sqrt(n) == .(sprintf(&quot;%.3f&quot;, strue/sqrt(i)))), bty = &quot;n&quot;, cex = 1.5) } legend(&quot;topright&quot;, legend = bquote(bar(bar(x)) == .(sprintf(&quot;%.3f&quot;, mean(x[i,]))) ~ hat(sigma)[bar(x)] == .(sprintf(&quot;%.3f&quot;, sd(x[i,])))), bty = &quot;n&quot;, cex = 1.5) dev.flush() # Sys.sleep(0.01) } } if (sim.out) return(x) } # binomial distribution # p &lt;- 0.25; size = 1 # clt_test(rep = 500, n = 50, # FUN = rbinom, mtrue = size * p, # strue = sqrt(size * p * (1 - p)), size = size, prob = p * size) # # clt_test(rep = 300, n = 30, FUN = rchisq, mtrue = 5, strue = sqrt(2*5), df = 5) 이항분포 베르누이 시행(Bernoulli trial): 성공 또는 실패로 결과가 나오는 시행 또는 시험 베르누이 시행을 \\(n\\) 번 반복 했을 때, 성공이 나타난 횟수를 확률변수 \\(X\\) \\(\\rightarrow\\) 이항확률변수(binomial random variable) \\(n\\) 번 베르누이 시행을 할 때, 각각의 시행은 서로 영향을 주지 않음 \\(\\rightarrow\\) 독립 성공 확률이 \\(\\theta\\) 이고, 실패확률이 \\(1-\\theta\\) 일 때, 베르누이 시행을 독립적으로 \\(n\\) 번 시행했을 때 성공횟수에 대한 확률분포 \\(\\rightarrow\\) 이항분포 이항분포의 확률질량함수 \\[P(X = x) = f(x; n, \\theta) = {n \\choose x} \\theta^x (1-\\theta)^{n-x}\\] 이항분포의 평균과 분산 \\[\\mu_X = n\\theta,~\\sigma^2_X = n\\theta(1-\\theta)\\] CLT에 따른 표본 평균의 정규근사 \\[ \\bar{X}_N \\stackrel{d}{\\rightarrow} \\mathcal{N}(\\mu, \\frac{\\sigma^2_X}{N}) = \\mathcal{N}(n\\theta, \\frac{n\\theta(1-\\theta)}{N}) \\] 예제 확률 변수 \\(X \\sim \\mathrm{binom}(n = 1, \\theta = 0.25)\\) 일때 표본분포의 CLT에 따른 표본 평균(300개의 평행우주로부터 표본 50개 추출) 의 정규 근사 과정 clt_test(rep = 300, n = 50, FUN = rbinom, mtrue = size * p, strue = sqrt(size * p * (1 - p)), size = size, prob = p) \\(\\theta = 0.25\\), \\(n = 1\\)인 이항분포의 표본평균 정규근사 포아송 분포 단위 시간 안에 어떤 사건이 몇 번 발생할 것인지를 표현한 이산확률분포로 정해진 시간 안에 어떤 사건이 일어날 횟수의 기댓값을 \\(\\lambda\\) 라고 할 때, 사건이 \\(n\\) 번 발생할 확률 확률질량함수 \\[ P(X =x; \\lambda) = \\frac{\\lambda^{x}e^{-\\lambda}}{x!} \\] 포아송 분포의 평균과 분산 \\[ \\mu_X = \\sigma^2_X = \\lambda \\] CLT에 따른 표본 평균의 정규근사 \\[ \\bar{X}_N \\stackrel{d}{\\rightarrow} \\mathcal{N}(\\mu, \\frac{\\sigma^2_X}{N}) = \\mathcal{N}(\\lambda, \\frac{\\lambda}{N}) \\] 예제 확률 변수 \\(X \\sim \\mathrm{pois}(\\lambda = 3)\\) 일때 표본분포의 CLT에 따른 표본 평균(300개의 평행우주로부터 표본 50개 추출) 의 정규 근사 과정 l &lt;- 3 clt_test(rep = 300, n = 50, FUN = rpois, mtrue = l, strue = sqrt(l), lambda = l) \\(\\lambda = 3\\)인 포아송 분포의 표본평균 정규근사 연속 균일 분포 확률밀도함수 \\[ f(X = x; a, b) = \\begin{cases} \\frac{1}{b - a}, &amp; ~ -\\infty &lt; a &lt; b &lt; \\infty \\\\ 0, &amp; \\mathrm{otherwise} \\end{cases} \\] 균일분포의 평균과 분산 \\[\\mu_X = \\frac{1}{2}(a + b), ~ \\sigma^2_X = \\frac{1}{12}(b - a)^2\\] CLT에 따른 표본 평균의 정규근사 \\[ \\bar{X}_N \\stackrel{d}{\\rightarrow} \\mathcal{N}(\\mu, \\frac{\\sigma^2_X}{N}) = \\mathcal{N}(\\frac{1}{2}(a +b), \\frac{(b - a)^2}{12N}) \\] 예제 확률 변수 \\(X \\sim U(0, 1)\\) 일때 표본분포의 CLT에 따른 표본 평균(300개의 평행우주로부터 표본 50개 추출) 의 정규 근사 과정 a = 0; b = 1 clt_test(rep = 300, n = 50, FUN = runif, mtrue = 0.5 * (a + b), strue = sqrt((b - a)^2/12), min = a, max = b) \\(X \\sim U(a = 0, b = 1)\\) 의 표본평균 정규근사 \\(\\chi^2\\) 분포 확률밀도함수 \\[ \\frac{1}{2^{\\nu/2}\\Gamma(\\nu/2)}x^{(\\nu/2) - 1}e^{-x/2}, ~ x \\in (0, +\\infty),~\\nu \\in \\mathbb{N} \\] \\(\\chi^2\\) 분포의 평균과 분산 \\[\\mu_X = \\nu, ~ \\sigma^2 = 2\\nu\\] CLT에 따른 표본 평균의 정규근사 \\[ \\bar{X}_N \\stackrel{d}{\\rightarrow} \\mathcal{N}(\\mu, \\frac{\\sigma^2_X}{N}) = \\mathcal{N}(\\nu, \\frac{2\\nu}{N}) \\] 예제 확률 변수 \\(X \\sim \\chi^2(\\nu = 3)\\) 일때 표본분포의 CLT에 따른 표본 평균(300개의 평행우주로부터 표본 50개 추출) 의 정규 근사 과정 nu = 3 clt_test(rep = 300, n = 50, FUN = rchisq, mtrue = nu, strue = sqrt(2*nu), df = nu) \\(X \\sim \\chi^2(\\nu = 3)\\) 의 표본평균 정규근사 신뢰구간의 정확한 의미 모평균 \\(\\mu\\)에 대한 \\((1 - \\alpha) \\%\\) 신뢰구간의 일반적 형태(모분산을 알고 있다고 가정한 경우) \\[ \\hat{\\mu} \\pm \\Phi^{-1}(\\alpha /2)\\frac{\\sigma}{\\sqrt{n}} \\] 신뢰구간: 같은 모형(분포)에서 반복적으로 표본을 추출해서 얻은 통계량에 대한 신뢰구간을 구했을 때 신뢰구간이 참 모수값을 포함할 확률이 \\((1 - \\alpha) %\\)가 되도록 만들어진 구간 주어진 확률\\((1 - \\alpha) \\%\\) (신뢰계수)에 대해 표본분포의 통계량이 모집단 모수에 포함되는 구간 모든 가능한 모수에 대한 표본 추정치의 신뢰구간 중 95 %가 모수를 포함 “모수가 신뢰구간에 포함될 확률”이라는 해석은 정확한 해석이 아님. 예제: sleep 데이터 10명의 대상자가 수면제 1과 수면제 2를 복용 시 수면시간 증가량 데이터 군 별 기술통계량 요약 # 독립 이표본 t 검정에서 두 군간 평균 차이에 대한 95% 신뢰구간 sleep %&gt;% group_by(group) %&gt;% summarise(N = n(), Mean = mean(extra), SD = sd(extra)) -&gt; desc_sleep `summarise()` ungrouping output (override with `.groups` argument) desc_sleep %&gt;% kbl() %&gt;% kable_paper group N Mean SD 1 10 0.75 1.789010 2 10 2.33 2.002249 독립 이표본 t-검정 mean_diff &lt;- -diff(desc_sleep$Mean); mean_diff [1] -1.58 sp &lt;- sqrt(mean(desc_sleep$SD^2)) tval &lt;- mean_diff/(sp * sqrt(sum(1/desc_sleep$N))); tval [1] -1.860813 # df = n1 + n2 - 2 = 10 + 10 - 2 = 18 p.value &lt;- 2*(1 - pt(tval, df = 18)); p.value [1] 1.920813 해당 데이터가 주어졌을 때 두 군간 평균 차이에 대한 95 % 신뢰구간 alpha &lt;- 0.05 lcl &lt;- mean_diff - qt(1 - alpha/2, 18) * sqrt(sum((desc_sleep$SD^2)/10)) ucl &lt;- mean_diff + qt(1 - alpha/2, 18) * sqrt(sum((desc_sleep$SD^2)/10)) lcl; ucl [1] -3.363874 [1] 0.203874 # check t.test(extra ~ group, data = sleep, var.equal = TRUE) Two Sample t-test data: extra by group t = -1.8608, df = 18, p-value = 0.07919 alternative hypothesis: true difference in means is not equal to 0 95 percent confidence interval: -3.363874 0.203874 sample estimates: mean in group 1 mean in group 2 0.75 2.33 실제 \\(X_1 \\sim \\mathcal{N}(1.0, 1.79^2)\\), \\(X_2 \\sim \\mathcal{N}(3.0, 2.0^2)\\) 이라고 가정하고, 현재 획득한 표본 수 만큼 해당 분포로 부터 추출(\\(n_1 = 10, n_2 = 10\\)) 후, 두 군 간 평균 차이에 대한 95 % 신뢰구간을 구하는 작업을 100 번 반복 N &lt;- 100 n1 &lt;- n2 &lt;- 10 m_true &lt;- -2 # mu_x1 - mu_x2 mu_contain_count = 0 plot(c(1, N), c(-8, 2), type = &quot;n&quot;, ylab = &quot;95 % CI&quot;, xlab = &quot;Replicates&quot;) abline(h = m_true, col = &quot;red&quot;, lty = 2) set.seed(1313) for (i in 1:N) { x1 &lt;- rnorm(n1, 1, 1.79) x2 &lt;- rnorm(n2, 3, 2.0) md &lt;- mean(x1) - mean(x2) lcl &lt;- md - qt(1 - alpha/2, n1 + n2 - 2) * sqrt((sd(x1)^2 + sd(x2)^2)/10) ucl &lt;- md + qt(1 - alpha/2, n1 + n2 - 2) * sqrt((sd(x1)^2 + sd(x2)^2)/10) contain_mu &lt;- lcl &lt;= m_true &amp; m_true &lt;= ucl if(contain_mu) mu_contain_count &lt;- mu_contain_count + 1 segments(i, lcl, i, ucl, col = as.numeric(!contain_mu) + 1) } legend(&quot;bottomright&quot;, legend = sprintf(&quot;# of not containing true mu: %d&quot;, N - mu_contain_count), bty = &quot;n&quot;) 위 sleep 데이터의 결과가 모집단의 특성을 충분히 반영했다고 가정하고, 독립 이표본 t 검정에서 귀무가설이 참일 때 두 집단 간 평균 차이에 대한 95 % 신뢰구간이 0을 포함하는 빈도 m_true &lt;- 0 # mu_x1 - mu_x2 mu_contain_count = 0 plot(c(1, N), c(-6, 3), type = &quot;n&quot;, ylab = &quot;95 % CI&quot;, xlab = &quot;Replicates&quot;) abline(h = m_true, col = &quot;red&quot;, lty = 2) set.seed(1313) for (i in 1:N) { x1 &lt;- rnorm(n1, 0.75, 1.79) x2 &lt;- rnorm(n2, 2.33, 2.0) md &lt;- mean(x1) - mean(x2) lcl &lt;- md - qt(1 - alpha/2, n1 + n2 - 2) * sqrt((sd(x1)^2 + sd(x2)^2)/10) ucl &lt;- md + qt(1 - alpha/2, n1 + n2 - 2) * sqrt((sd(x1)^2 + sd(x2)^2)/10) contain_mu &lt;- lcl &lt;= m_true &amp; m_true &lt;= ucl if(contain_mu) mu_contain_count &lt;- mu_contain_count + 1 segments(i, lcl, i, ucl, col = as.numeric(!contain_mu) + 1) } legend(&quot;bottomright&quot;, legend = sprintf(&quot;# of not containing true mu: %d&quot;, N - mu_contain_count), bty = &quot;n&quot;) 3.5.0.1 P 값에 대한 이해 Simulation setting 1: 귀무가설이 참인 경우 \\(X \\sim \\mathcal{N}(\\mu_{X}, \\sigma^{2}_{X})\\), \\(Y \\sim \\mathcal{N}(\\mu_{Y}, \\sigma^{2}_{Y})\\) 일 때, \\(\\mu_{X}=\\mu_{Y}=100\\) 이고 \\(\\sigma_{X}=\\sigma_{Y}=20\\) \\(X\\)와 \\(Y\\)의 분포로부터 \\(n_X = n_Y = 30\\) 개를 추출한 데이터로 독립 이표본 t-검정 후 p-value 값 획득 10,000 번 반복 nsim &lt;- 10000 p &lt;- numeric(nsim) set.seed(19780904) for (i in 1:nsim) { x &lt;- rnorm(n = 30, mean = 100, sd = 20) y &lt;- rnorm(n = 30, mean = 100, sd = 20) p[i] &lt;- t.test(x, y)$p.value } hist(p, main = &quot;Histogram of p-values under the null hypothesis&quot;, xlab = &quot;Observed p-value&quot;, col = &quot;#87DAFA&quot;) \\(X\\)와 \\(Y\\)의 분포가 동일함에도 불구하고 관찰한 p-value의 4.8 % 가 0.05보다 작게 나타남. Simulation setting 2: 대립가설이 참인 경우 \\(\\mu_{X} = 100\\), \\(\\mu_{Y} = 96\\), \\(\\sigma_{X}=\\sigma_{Y}=20\\) 실제효과크기: \\(\\eta = 0.2\\) 첫 번째 모의실험과 동일한 크기로 진행 set.seed(19780904) for (i in 1:nsim) { x &lt;- rnorm(n = 30, mean = 100, sd = 20) y &lt;- rnorm(n = 30, mean = 96, sd = 20) p[i] &lt;- t.test(x, y)$p.value } hist(p, main = &quot;Histogram of p-values under the alternative hypothesis with ES = 0.2&quot;, xlab = &quot;Observed p-value&quot;, col = &quot;#87DAFA&quot;) \\(p&lt;0.05\\)인 비율: 11.8 % Simulation setting 3: 대립가설이 참, 표본 크기를 증가시킨 경우 \\(\\mu_{X} = 100\\), \\(\\mu_{Y} = 96\\), \\(\\sigma_{X}=\\sigma_{Y}=20\\) \\(X\\)와 \\(Y\\)의 분포로부터 \\(n_X = n_Y = 100\\) 개를 추출한 데이터로 독립 이표본 t-검정 후 p-value 값 획득 set.seed(19780904) for (i in 1:nsim) { x &lt;- rnorm(n = 100, mean = 100, sd = 20) y &lt;- rnorm(n = 100, mean = 96, sd = 20) p[i] &lt;- t.test(x, y)$p.value } hist(p, main = &quot;Histogram of p-values under the alternative hypothesis with 100 samples per group&quot;, xlab = &quot;Observed p-value&quot;, col = &quot;#87DAFA&quot;) \\(p&lt;0.05\\)인 비율: 28.3 % Simulation setting 4: 대립가설이 참, 효과크기가 1.0인 경우 \\(\\mu_{X} = 100\\), \\(\\mu_{Y} = 84\\), \\(\\sigma_{X}=\\sigma_{Y}=20\\) \\(X\\)와 \\(Y\\)의 분포로부터 \\(n_X = n_Y = 30\\) 개를 추출한 데이터로 독립 이표본 t-검정 후 p-value 값 획득 set.seed(19780904) for (i in 1:nsim) { x &lt;- rnorm(n = 30, mean = 100, sd = 20) y &lt;- rnorm(n = 30, mean = 80, sd = 20) p[i] &lt;- t.test(x, y)$p.value } hist(p, main = &quot;Histogram of p-values under the alternative hypothesis: n = 30, eta = 1.0&quot;, xlab = &quot;Observed p-value&quot;, col = &quot;#87DAFA&quot;) \\(p&lt;0.05\\)인 비율: 96.8 % p-value와 “통계적 유의성”에 대한 미국 통계학회 성명 P-value는 가정한 통계 모형이 데이터와 호환되지 않음을 나타낸다(P-values can indicate how incompatible the data are with a specified statistical model) P-value는 연구 가설이 참인 확률이나 데이터가 랜덤하게 생성된 확률을 측정하지 않는다(P-values do not measure the probability that the studied hypothesis is true, or the probability that the data were produced by random chance alone) 과학적 연구 결론 도출이나 비지니스 및 정책 결정 과정에서 p-value가 어떤 경계값(임계점)보다 크거나 작다는 것에 근거해서는 안된다(Scientific conclusions and business or policy decisions should not be based only on whether a p-value passes a specific threshold) 제대로된 추론을 위해서는 연구과정 전반에 대한 보고서와 투명성이 필요하다(Proper inference requires full reporting and transparency) P-value나 통계적 유의성은 효과의 크기나 결과의 중요성을 나타내지 않는다(A p-value, or statistical significance, does not measure the size of an effect or the importance of a result) P-value 자체만으로는 모형이나 가설에 대한 증거가 될 수 없다(By itself, a p-value does not provide a good measure of evidence regarding a model or hypothesis) "],
["homework-3.html", "3.6 Homework 3", " 3.6 Homework 3 설명변수 \\(x_i\\)와 \\(y_i\\), \\(i = 1, 2, \\ldots, n\\) 가 주여졌을 때 다음과 같은 반응변수 \\(y_i\\)에 대한 설명변수 \\(x_i\\)의 단순선형회귀모형(simple linear regression)을 고려해보자. \\[ y_{i} = 5 + -2.5 x_i + \\epsilon_i, ~~ \\epsilon_i \\sim \\mathcal{N}(0, 9), ~~ x_i \\sim \\mathcal{U}(0, 10) \\] 위 모형 \\(y_{i} = 5 + -2.5 x_i + \\epsilon_i, ~~ \\epsilon_i\\)를 행렬과 벡터 형태로 나타내기 위한 행렬 및 벡터를 정의하고, 정의한 행렬/벡터로 위 모형을 표시하시오. \\(y_i\\)가 정규분포를 따른다고 가정할 때, 설명변수 \\(x_i\\)가 주어졌을 때 반응변수 \\(y_i\\)는 어떤 분포를 따르는지 행렬과 벡터로 표시하시오. 주어진 모형으로부터 \\(y_i\\)를 생성하고(\\(i=1,\\ldots, 30\\)), 생성한 \\(x_i\\)와 \\(y_i\\)의 산점도를 그리시오. 단, seed 번호는 20201111로 고정하시오. 수업시간에 학습한 미분 가능한 특정 방정식의 해를 구하는 Newton-Raphson (N-R) 방법을 응용해 문제 1에서 생성한 y와 x로부터 회귀식(x의 기울기와 절편) 추정이 가능하다. 단순회귀모형 및 다중회귀모형에서 회귀계수 추정의 기본 아이디어는 오차 제곱의 힙 \\(\\sum\\epsilon_i = \\boldsymbol{\\mathbf{\\epsilon}}^T\\boldsymbol{\\mathbf{\\epsilon}}\\) 를 최소화하는 \\(\\beta_0\\)와 \\(\\beta_1\\) 또는 \\(\\boldsymbol{\\mathbf{\\beta}}_{p\\times 1}\\)을 찾는 것이고, 이 문제를 아래와 같이 나타낼 수 있다. \\[ \\arg \\min \\left\\{ (\\mathbf{y}_{n \\times 1} - \\mathbf{X}_{n \\times p}\\boldsymbol{\\mathbf{\\beta}}_{p \\times 1})^T (\\mathbf{y}_{n \\times 1} - \\mathbf{X}_{n \\times p}\\boldsymbol{\\mathbf{\\beta}_{p \\times 1}}) \\right \\} \\] 위 식에서 \\(\\mathcal{L}(\\boldsymbol{\\mathbf{\\beta}}) = (\\mathbf{y}_{n \\times 1} - \\mathbf{X}_{n \\times p}\\boldsymbol{\\mathbf{\\beta}}_{p \\times 1})^T (\\mathbf{y}_{n \\times 1} - \\mathbf{X}_{n \\times p}\\boldsymbol{\\mathbf{\\beta}}_{p \\times 1})\\) 라고 하면, \\(\\partial \\mathcal{L}(\\boldsymbol{\\mathbf{\\beta}})/\\partial \\boldsymbol{\\mathbf{\\beta}} = 0\\) 를 만족하는 \\(\\boldsymbol{\\mathbf{\\beta}}\\) 일 때 \\(\\mathcal{L}(\\boldsymbol{\\mathbf{\\beta}})\\)가 최솟값을 갖는다. 따라서 학습한 N-R 알고리즘의 핵심단계는 개념적으로 아래와 같이 변형할 수 있다. \\[ \\beta_{new} := \\beta_{old} - \\frac{L(\\beta)&#39;}{L(\\beta)&#39;&#39;} \\] 위 식을 행렬 형태로 일반화 하면, \\[ \\boldsymbol{\\mathbf{\\beta}}_{new} = \\boldsymbol{\\mathbf{\\beta}}_{old} - [\\mathbf{H}(\\boldsymbol{\\mathbf{\\beta}}_{old})]^{-1} \\nabla \\mathcal{L} (\\boldsymbol{\\mathbf{\\beta}}_{old}) \\] 이고, 여기서 \\(\\nabla \\mathcal{L} (\\boldsymbol{\\mathbf{\\beta}})\\) 는 1차 도함수(gradient)라고 하고, \\(\\mathbf{H}(\\boldsymbol{\\mathbf{\\beta}}) = \\nabla^2 \\mathcal{L}(\\boldsymbol{\\mathbf{\\beta}})\\)는 2차 도함수을 일반화한 Hessian 행렬이라고 한다. \\(\\nabla \\mathcal{L}(\\boldsymbol{\\mathbf{\\beta}})\\)와 \\(\\nabla^2 \\mathcal{L}(\\boldsymbol{\\mathbf{\\beta}})\\)은 아래와 같다. \\[\\begin{aligned} \\nabla \\mathcal{L}(\\boldsymbol{\\mathbf{\\beta}}) &amp;= \\frac{\\partial \\mathcal{L}(\\boldsymbol{\\mathbf{\\beta}})}{\\partial \\boldsymbol{\\mathbf{\\beta}}} = \\mathbf{X}^T\\mathbf{X}\\boldsymbol{\\mathbf{\\beta}} - \\mathbf{X}^T\\mathbf{y} \\\\ \\nabla^2 \\mathcal{L}(\\boldsymbol{\\mathbf{\\beta}}) &amp;= \\frac{\\partial^2 \\mathcal{L}(\\boldsymbol{\\mathbf{\\beta}})}{\\partial \\boldsymbol{\\mathbf{\\beta}}^2} = \\mathbf{X}^T\\mathbf{X} \\end{aligned} \\] 목적함수 \\(\\mathcal{L}(\\boldsymbol{\\mathbf{\\beta}})\\)를 계산하기 위한 obj_fun()을 구현하기 위해 필요한 필수 인수(argument)를 정의하고 함수를 작성하시오. \\(\\nabla \\mathcal{L}(\\boldsymbol{\\mathbf{\\beta}})\\)를 도출하기 위한 grad_fun()을 구현하기 위해 필요한 필수 인수(argument)를 정의하고 함수를 작성하시오. Hessian 행렬 \\(\\nabla^2 \\mathcal{L}(\\boldsymbol{\\mathbf{\\beta}})\\)을 도출하기 위한 hess_fun() 함수를 구현하기 위해 필요한 필수 인수(argument)를 정의하고 함수를 작성하시오. b ~ c 에서 구현한 함수를 사용해 N-R 방법으로 선형회귀모형의 회귀계수 추정을 위한 nr_linreg() 함수를 구현하기 위해 필요한 필수 인수(argument)를 정의하고 함수를 작성하시오. 문제 1에서 생성한 x와 y에 대해 lm(y ~ x)으로 구한 회귀계수와 nr_linreg(x, y)로 추정한 회귀계수를 비교 하시오. 스타 크래프트의 테란 종족의 유닛 고스트는 스스로를 숨길 수 있고(클로킹), 공격력(10 ~ 11)을 갖고 있다. 게임 특성 상 언덕 위에 있는 상대를 언덕 아래에서 공격할 때 50%의 확률로 빗나간다. 고스트가 비밀 정찰 중 언덕 위에서 저그 진지를 순찰 중인 히드라리스크를 발견했다. 언덕 아래에서 고스트가 히드라를 공격했을 때, 평균적으로 몇 번의 공격을 해야 히드라리스크를 잡을 수 있는지 모의실험(반복횟수: 10,000회)을 통해 확인하시오. (단, 히드라리스크의 체력은 80이고, 히드라리스크는 오버로드의 부재로 고스트를 볼 수 없고, 고스트는 테란의 스캔 능력을 통해 언덕 위를 확인할 수 있다고 가정) 제출기한: 2020년 12월 4일 금요일 제출방식: R markdown으로 과제 답안 작성 후 생성한 html 문서 및 Rmd 파일을 학번-이름.zip으로 압축 후 사이버 캠퍼스에 업로드 R markdown 작성 요령 수식이 필요한 경우 수업 시간에 학습한 수식 입력 방법을 통해 작성(그림 첨부 시 감점) R 스크립트 작성 시 매 행마다 주석으로 행의 의미를 기술할 것. "],
["basic-stat-analysis.html", "4 R을 활용한 기초통계 분석", " 4 R을 활용한 기초통계 분석 Sketch Q-Q plot \\(\\rightarrow\\) 데이터가 특정 분포를 따르는가? paired t test, independent two sample t test \\(\\rightarrow\\) 연속형 반응변수 vs. 범주가 2개인 범주형 변수 Oneway ANOVA test \\(\\rightarrow\\) 연속형 반응변수 vs. 범주가 2개 이상인 범주형 변수 \\(\\chi^2\\) &amp; Fisher’s exact test \\(\\rightarrow\\) 두 범주형 변수 간 연관성(독립성) 검정 Correlation between two continuous variables \\(\\rightarrow\\) Pearson’s correlation coefficient "],
["qqplot.html", "4.1 Q-Q plot", " 4.1 Q-Q plot Q-Q plot = Quantile(분위수)-Quantile(분위수) plot 4.1.1 분위수(Quantile) 정의 확률분포를 동등한 확률 구간으로 나누기 위해 설정한 구분점(cutpoint) 특정 확률분포의 누적분포함수의 역함수 주어진 표본의 관찰값을 오름차순으로 나열했을 때 전체 표본(데이터)을 특정 개수의 그룹으로 나눌 때 기준이 되는 값 \\(q\\) 분위수는 \\(q-1\\) 개의 분위수 값을 갖음 예시 2-quantile: 오름차순으로 정렬한 데이터를 50:50으로 나누기 위한 값 \\(\\rightarrow\\) 중앙값(median) 3-quantiles (tertiles): 오름차순으로 정렬한 데이터를 3 등분 하기 위한 값 \\(\\rightarrow\\) 33.3 %, 66.6 % 4-quantiles (quartiles): 오름차순 정렬 데이터를 4등분 하기 위한 값 \\(\\rightarrow\\) 25 % (Q1), 50 % (중앙값), 75 % (Q3) 사분위수 범위(interquartile range, IQR): Q3 - Q1 10-quantiles (deciles): 오름차순 정렬 데이터를 10 등분 \\(\\rightarrow\\) 10 %, 20 %, 30 %, …, 90 % 100-quantiles (percentiles): 오름차순 정렬 데이터를 10 등분 \\(\\rightarrow\\) 1 %, 2 %, …, 99 % 일반적으로 \\(k^{\\mathrm{th}}\\) \\(q\\) 분위수는 누적확률분포에서 \\(k/q\\)의 값을 갖는 데이터를 의미 (표본)분위수의 계산 R에서 표본 분위수는 quantile() 함수룰 통해 구할 수 있으먀, 크게 불연속 변수(discontinuous variable)와 연속 변수(continuous variable)에 따라 방법이 조금씩 달라짐. 불연속변수인 경우 데이터 중에서 분위수 값을 정의하는 반면 연속변수인 경우 보간(interpolation)을 사용해 분위수 값을 정함. R은 총 9 가지의 분위수 계산 방법을 제공하며, 방법 1 ~ 3은 불연속 변수, 방법 4 ~ 9 는 연속 변수를 대상으로 함. 표본 분위수는 순서통계량(order statistics)5의 가중평균으로 정의하며 임의의 표본이 주어졌을 때 \\(p \\times 100\\) % 분위수 계산 식6은 아래와 같음(연속 변수에 대해) \\[ Q(p) = (1 - \\gamma) x_{(k)} + \\gamma x_{(k+1)} \\] 이고, 여기서 \\((k - 0.5)/n \\leq p &lt; (k - 0.5 +1)/n\\), \\(x_{(k)}\\)는 \\(k\\) 번째 순서통계량, \\(n\\)은 표본크기, \\(\\gamma = np + m - k\\), \\(k\\)는 \\(np + m\\)을 넘지 않는 최대 정수이고 \\(m = 1/2\\) 임. 예시 # 분위수 계산 함수 my_quantile &lt;- function(x, probs) { idx &lt;- NULL o &lt;- order(x); n &lt;- length(x) xord &lt;- x[o] k &lt;- 1:n gamma &lt;- n * probs + 0.5 - floor(n * probs + 0.5) pk &lt;- (k - 0.5)/n for (pj in probs) { idx &lt;- c(idx, which.max(pk[pk &lt;= pj])) } res &lt;- (1 - gamma) * xord[idx] + gamma * xord[idx + 1] names(res) &lt;- sprintf(&quot;%.1f %%&quot;, round(probs * 100)) return(res) } set.seed(10) x &lt;- rnorm(373) my_quantile(x, probs = c(0.05, 0.95)) 5.0 % 95.0 % -1.601323 1.492466 # 확인 quantile(x, probs = c(0.05, 0.95), type = 5) 5% 95% -1.601323 1.492466 Quantile-Quantile plot (Q-Q plot) 두 변수 \\(X\\)의 분위수와 \\(Y\\)의 분위수를 산점도 형태로 그린 도표로 두 변수의 분포를 비교하기 위한 용도로 사용되는 도표 예시 \\(X\\): 충남대학교 정보통계학과 남학생의 키 \\(Y\\): 충남대학교 자연과학대학 남학생의 몸무게 # 개념 set.seed(1234) x &lt;- rnorm(50, 172, 15) y &lt;- rnorm(500, 65, 20) xq &lt;- quantile(x, probs = seq(0, 1, by = 0.05)) yq &lt;- quantile(y, probs = seq(0, 1, by = 0.05)) plot(xq, yq, xlab = &quot;height&quot;, ylab = &quot;weight&quot;) 일반적으로 측정 또는 표집한 연속형 변수가 이론적인 특정 분포와 얼마나 유사한지를 확인하기 위해 사용하며, 특히 데이터의 정규성 검정에 많이 활용됨. 즉 표본으로 얻은 분포가 정규분포를 따르는지(유사한지)를 알아보기 위해 활용 보통 x 축은 theoretical quantile (이론적 분위수)로 하고 y 축은 표본 분위수(empirical/sample quantile)로 설정 R에서 Q-Q plot은 qqnorm(), qqplot() 등의 함수를 사용해 간단히 그릴 수 있으나 해당 함수를 사용하지 않고 직접 그리는 방법에 대해 알아봄. # 위 예제에서 생성한 충남대학교 여학생 몸무게의 Q-Q plot # 정규분포와 비교 yord &lt;- y[order(y)] # 데이터 정렬 n &lt;- length(yord) k &lt;- 1:n pk &lt;- (k - 0.5)/n # theoretical quantile tq &lt;- qnorm(pk, 0, 1) # 표준정규분포의 분위수 # empirical quantile eq &lt;- drop(scale(yord)) # z 변환 par(mfrow = c(1, 2)) plot(x = tq, y = eq, type = &quot;n&quot;, xlim = c(-3.5, 3.5), ylim = c(-3.5, 3.5), xlab = &quot;Theoretical Quantile&quot;, ylab = &quot;Empirical Quantile&quot;, main = &quot;Normal Q-Q plot (manual)&quot;) points(tq, eq, pch=16, cex = 1, col = &quot;darkgray&quot;) points(tq, eq, pch=21, cex = 1, col = &quot;black&quot;, lwd = 1) abline(a = 0, b = 1) # qqnorm() 함수 결과와 비교 qqnorm(eq, xlim = c(-3.5, 3.5), ylim = c(-3.5, 3.5)) qqline(eq) 데이터의 정규성을 확인하기 위한 검정 방법으로 대표적으로 Kolmogrov-Smirnov test, Shapiro-Wilk test, Anderson-Darling test, Cramer-von Mises test 등이 일반적으로 많이 사용되지만, 표본의 크기가 커질 경우 검정력이 높아지기 때문에 귀무가설인 “데이터가 정규분포를 따른다”를 기각할 확률이 높아짐. 그렇기 때문에 정규성 검정과 동시에 Q-Q plot을 통한 데이터의 분포 확인이 필요함. Q-Q plot의 형태 정규분포를 기준으로 Q-Q plot의 형태를 통해 표본자료의 데이터 분포 유추가 가능. 예를 들어 표본 분위수를 \\(Q_E\\), 표준정규분포의 분위수를 \\(Q_T\\)라고 할 때 \\(Q_E &lt; Q_T\\): 이론적 분위수보다 표본 분위수가 작다 \\(\\rightarrow\\) 직선을 기준으로 오른쪽에 점 위치 \\(Q_E &gt; Q_T\\): 이론적 분위수보다 표본 분위수가 크다 \\(\\rightarrow\\) 직선을 기준으로 왼쪽에 점 위치 대칭이지만 표본데이터의 분포 꼬리가 표준정규분포에 비해 얇은 경우 # X ~ U(-2, 2) set.seed(100) x &lt;- runif(10000, -2, 2) par(mfrow = c(1, 2)) qqnorm(scale(x), pch = 16, cex = 1, col = &quot;darkgray&quot;) qqline(scale(x)) plot(density(scale(x)), xlim = c(-3, 3), ylim = c(0, 0.4), lwd = 1.5, col = &quot;red&quot;, main = &quot;Light tailed distribution: X ~ U(-2, 2)&quot;) z &lt;- seq(-3, 3, by = 0.01) lines(z, dnorm(z), lwd = 1.5, col = &quot;black&quot;) legend(&quot;topright&quot;, legend = c(&quot;Theoretical N(0, 1)&quot;, &quot;Estimated density of the sample&quot;), lty = 1, lwd = 1.5, bty = &quot;n&quot;, col = c(&quot;black&quot;, &quot;red&quot;)) 대칭이지만 표본데이터의 분포 꼬리가 표준정규분포에 비해 두꺼운 경우 # 자유도가 8인 t 분포 set.seed(100) x &lt;- rt(10000, df = 8) par(mfrow = c(1, 2)) qqnorm(scale(x), pch = 16, cex = 1, col = &quot;darkgray&quot;) qqline(scale(x)) plot(density(scale(x)), xlim = c(-6, 6), ylim = c(0, 0.5), lwd = 1.5, col = &quot;red&quot;, main = &quot;Heavy tailed distribution: X ~ t(df = 3)&quot;) z &lt;- seq(-6, 6, by = 0.01) lines(z, dnorm(z), lwd = 1.5, col = &quot;black&quot;) legend(&quot;topright&quot;, legend = c(&quot;Theoretical N(0, 1)&quot;, &quot;Estimated density of the sample&quot;), lty = 1, lwd = 1.5, bty = &quot;n&quot;, col = c(&quot;black&quot;, &quot;red&quot;)) 표본데이터가 표준정규분포에 비해 오른쪽으로 치우쳐진 경우(skewed to the right) # exp(lambda = 3) set.seed(100) x &lt;- rexp(10000, rate = 3) par(mfrow = c(1, 2)) qqnorm(scale(x), pch = 16, cex = 1, col = &quot;darkgray&quot;) qqline(scale(x)) plot(density(scale(x)), xlim = c(-3, 6), ylim = c(0, 0.8), lwd = 1.5, col = &quot;red&quot;, main = &quot;Skewed to the right: X ~ exp(lambda = 3)&quot;) z &lt;- seq(-3, 6, by = 0.01) lines(z, dnorm(z), lwd = 1.5, col = &quot;black&quot;) legend(&quot;topright&quot;, legend = c(&quot;Theoretical N(0, 1)&quot;, &quot;Estimated density of the sample&quot;), lty = 1, lwd = 1.5, bty = &quot;n&quot;, col = c(&quot;black&quot;, &quot;red&quot;)) 표본데이터가 표준정규분포에 비해 왼쪽으로 치우쳐진 경우(skewed to the left) # X ~ beta(4, 1) set.seed(100) x &lt;- rbeta(10000, shape1 = 4, shape2 = 1) par(mfrow = c(1, 2)) qqnorm(scale(x), pch = 16, cex = 1, col = &quot;darkgray&quot;) qqline(scale(x)) plot(density(scale(x)), xlim = c(-5, 4), ylim = c(0, 0.6), lwd = 1.5, col = &quot;red&quot;, main = &quot;Skewed to the left: X ~ beta(4, 1)&quot;) z &lt;- seq(-4, 4, by = 0.01) lines(z, dnorm(z), lwd = 1.5, col = &quot;black&quot;) legend(&quot;topright&quot;, legend = c(&quot;Theoretical N(0, 1)&quot;, &quot;Estimated density of the sample&quot;), lty = 1, lwd = 1.5, bty = &quot;n&quot;, col = c(&quot;black&quot;, &quot;red&quot;)) qqnorm()은 이론적인 표준정규분포와 표본 데이터의 분포를 비교하기 위한 함수이고, 다른 분포(\\(\\chi^2\\) 분포, \\(t\\) 분포 등)와 비교하기 위헤서는 qqplot(x = theoretical, y = empirical)를 사용해 Q-Q plot 생성 가능 # 카이제곱분포의 Q-Q plot set.seed(100) y &lt;- rchisq(500, df = 3) x &lt;- qchisq(ppoints(500), # 500 quantiles 생성 df = 3) qqplot(x, y, main = expression(&quot;Q-Q plot for&quot; ~~ {chi^2}[nu == 3])) qqline(y, distribution = function(p) qchisq(p, df = 3), col = &quot;red&quot;) Application 실제 데이터로부터 정규성 확인을 위헤 Q-Q plot 생성 ggpubr 패키지에서 제공하는 ggqqplot() 함수를 통해 Q-Q plot 생성 ggpubr: 논문이나 출판을 위해 high-quality 도표를 생성하기 위한 목적으로 “ggplot based Publication Ready plots”의 약어를 이름으로 갖는 패키지 R에서 제공하는 iris 데이터셋 활용 tidyverse 세계에서 데이터 전처리 및 Q-Q plot 출력 # 각 붓꽃 종과 측정 변수에 따른 Q-Q plot 생성 # install.packages(&quot;ggpubr&quot;) # require(tidyverse) # require(ggpubr) iris_tb &lt;- as_tibble(iris) iris_tb %&gt;% rownames_to_column %&gt;% # 데이터프레임 행이름을 변수로 변환 pivot_longer(cols = matches(&quot;Sepal|Petal&quot;), names_to = &quot;Measures&quot;) %&gt;% # long-format으로 변환 group_by(Species, Measures) %&gt;% mutate(zvalue = drop(scale(value))) %&gt;% # 정규성 확인을 위해 각 변수의 종별 표준화 ungroup %&gt;% ggpubr::ggqqplot(x = &quot;zvalue&quot;, color = &quot;Species&quot;, facet.by = c(&quot;Species&quot;, &quot;Measures&quot;), palette = c(&quot;#00AFBB&quot;, &quot;#E7B800&quot;, &quot;#FC4E07&quot;), ggtheme = ggpubr::theme_pubclean(base_size = 15)) 그래프 생성 시 원하는 색에 대한 코드를 쉽게 추출하고 싶다면 colourpicker 패키지를 설치해 보자. 순서통계량은 확률변수 \\(X\\)를 \\(n\\) 개 관찰을 했을 때 \\(X\\)를 크기 순으로 배열한\n통계량으로 \\(X_{(1)} &lt; X_{(2)} &lt; \\cdots &lt;X_{(n)}\\) 로 나타냄(순서통계량은 서로 독립이 아님)↩︎ R quantile(x, probs, type = 5)와 동일↩︎ "],
["group-comp.html", "4.2 연속형 변수의 비교", " 4.2 연속형 변수의 비교 기초 통계학 또는 타 과목에서 학습한 독립 이표본 \\(t\\) 검정이나 일원배치분산분석은 모두 선형모형의 특별한 케이스임. 두 방법 모두 연속형 변수를 반응변수로 놓고 범주형 변수를 예측변수로 설정한 회귀모형으로 간주할 수 있음. 독립 이표본 \\(t\\) 검정 \\[ y_i = \\beta_0 + \\beta_1 x_i + \\epsilon_i, ~~ \\epsilon_i \\sim \\mathcal{N}(0, \\sigma^2), ~~ x_i = \\{0, 1\\} \\] 일원배치분산분석(수준 \\(k = 3\\), 각 수준 별 반복 \\(n = 2\\)) \\[ \\mathbf{y}_{6 \\times 1} = \\mathbf{X}_{6\\times 4}\\boldsymbol{\\mathbf{\\beta}}_{4\\times 1} + \\boldsymbol{\\mathbf{\\epsilon}}_{6\\times 1} \\] \\[\\mathbf{y}_{6 \\times 1} = \\begin{bmatrix} y_{11} \\\\ y_{21} \\\\ y_{31} \\\\ y_{41} \\\\ y_{51} \\\\ y_{61} \\end{bmatrix}, ~~ \\mathbf{X}_{6\\times 4} = \\begin{bmatrix} 1 &amp; 1 &amp; 0 &amp; 0 \\\\ 1 &amp; 1 &amp; 0 &amp; 0 \\\\ 1 &amp; 0 &amp; 1 &amp; 0 \\\\ 1 &amp; 0 &amp; 1 &amp; 0 \\\\ 1 &amp; 0 &amp; 0 &amp; 1 \\\\ 1 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix}, ~~ \\boldsymbol{\\mathbf{\\beta}}_{4\\times 1} = \\begin{bmatrix} \\beta_0 \\\\ \\beta_1 \\\\ \\beta_2 \\\\ \\beta_3 \\\\ \\end{bmatrix}, ~~ \\boldsymbol{\\mathbf{\\epsilon}}_{6\\times 1} \\begin{bmatrix} \\epsilon_{11} \\\\ \\epsilon_{21} \\\\ \\epsilon_{31} \\\\ \\epsilon_{41} \\\\ \\epsilon_{51} \\\\ \\epsilon_{61} \\end{bmatrix} \\] 일반적으로 우리가 분석을 위한 데이터는 두 가지 방법을 통해 획득 관찰(observation): 반응변수(\\(Y\\)) 및 예측변수(\\(X\\)) 모두 관찰을 통해 획득 예: 표본조사(sample survey), 코호트 연구(cohort study), 단면연구(cross-sectional study) 등 실험(experiment): 예측변수를 실험자가 결정하고 실험을 통해 반응변수를 관찰 실험을 진행하는 사람이 제어하는 예측변수를 요인(factor) 요인의 가능한 값을 수준(level) 요인의 수준에 따라 관찰하고자 하는 대상을 무작위로 할당 예: 무작위 임상시험, 실험설계 4.2.1 대응 표본 t 검정(paired samples t test) 대응 표본(paired sample) 동일한 대상자에 대해 쌍으로 이루어진 데이터 새 교습방법에 대한 적용 전·후 수학 점수 실험용 쥐에 실험약 투여 전·후 대사량 다이어트 약 복용 전·후 체중 데이터 형태: \\(X \\sim \\mathcal{N}(\\mu_X, \\sigma^2_X)\\)이고 \\(Y \\sim \\mathcal{N}(\\mu_Y, \\sigma^2_Y)\\) \\[\\begin{align} x_1, x_2, \\ldots, x_n &amp; &amp; \\mathrm{before~treatment} \\\\ y_1, y_2, \\ldots, y_n &amp; &amp; \\mathrm{after~treatment} \\\\ \\end{align} \\] 여기서 \\(x_i\\)와 \\(y_i\\)는 서로 독립이 아님 \\(\\rightarrow\\) 전·후 차이를 계산한 새로운 변수 \\(d_i = y_i - x_i\\)를 생성 후 \\(D = \\{d_1, \\ldots, d_n\\}\\)에 대한 일표본 \\(t\\) 검정을 실시(\\(D \\sim \\mathcal{N}(\\mu_D, \\sigma_D^2)\\)) \\[ \\mu_D = \\mu_Y - \\mu_X, ~~\\sigma^2_D = \\sigma^2_X + \\sigma^2_Y - 2\\rho_{XY}\\sigma_X\\sigma_Y \\] 여기서 \\(\\rho_{XY}\\)는 \\(X\\)와 \\(Y\\)의 (피어슨) 상관계수임. 검정을 위한 귀무가설과 대립가설은 아래와 같음 \\[ H_0: \\mu_D = 0~~~\\mathrm{vs.}~~~H_1:\\mu_D \\neq 0 \\] 검정통계량 \\[ t_0 = \\frac{\\hat{\\mu}_D - 0}{\\hat{\\sigma}/\\sqrt{n}} \\sim t_{(\\nu = n-1)} \\] 혈압강하제 임상시험 데이터(DBP.txt)에서 시험약 복용 전(DBP1) 대비 복용 1개월 후(DBP2) 이완기 혈압(diastolic blood pressure)의 차이 검정 DBP &lt;- read_delim(&quot;data/DBP.txt&quot;, delim = &quot;\\t&quot;) Parsed with column specification: cols( Subject = col_double(), TRT = col_character(), DBP1 = col_double(), DBP2 = col_double(), DBP3 = col_double(), DBP4 = col_double(), DBP5 = col_double(), Age = col_double(), Sex = col_character() ) DBP &lt;- DBP %&gt;% mutate(D1 = DBP2 - DBP1) treatment &lt;- DBP %&gt;% filter(TRT == &quot;A&quot;) D1 &lt;- treatment$D1 mD1 &lt;- mean(D1) sD1 &lt;- sd(D1) ### check # mb &lt;- mean(treatment$DBP1); ma &lt;- mean(treatment$DBP2) # sD1_check &lt;- with(treatment, # sqrt(var(DBP1) + var(DBP2) - # 2*cor(DBP1, DBP2)*sd(DBP1)*sd(DBP2))) # mD1; ma - mb # sD1; sD1_check tstat &lt;- mD1/(sD1/sqrt(length(D1))) p.val &lt;- 2*(pt(tstat, df = length(D1) - 1)) ## t.test() check tstat; t.test(D1)$statistic [1] -7.493656 t -7.493656 p.val; t.test(D1)$p.value [1] 4.364575e-07 [1] 4.364575e-07 R에서 대응표본(일표본) 및 독립 이표본 \\(t\\) 검정을 하기 위한 함수는 t.test()이고 아래와 같은 인수를 가짐 x: 검정을 할 데이터 y: 독립 이표본 검정 수행 시 두 번째 데이터 독립 이표본 t 검정 시 수식 형태 y ~ x로 표현 가능하며, 이 때 입력 데이터는 데이터 프레임 형태임 alternative: 대립가설 형태(양측 또는 단측: “two.sided”, “greater”, “less”) var.equal: 논리값을 가지며 독립 이표본 t 검정 시 두 집단의 분산에 대한 가정(FALSE = 이분산, TRUE=등분산) conf.level: 신뢰수준(default 값은 0.95) R은 다양한 가설검정 관련 함수를 제공하는데 검정 결과는 htest라는 클래스 개체에 저장함. htest 객체는 다음과 같은 출력결과를 가짐(검정함수에 따라 달라질 수 있음) statistic: 검정 통계량 parametmer: 검정통계량 계산에 사용된 자유도(degree of freedom) p.value: P 값 conf.int: 신뢰구간 estimate: 추정 평균 또는 평균 차이 (t 검정인 경우) 4.2.2 독립 이표본 t 검정(independent two-sample t-test) 서로 독립인 두 모집단의 평균을 비교하기 위한 가장 기본적인 통계적 가설검정 방법으로 반응 변수 \\(y_{ij}\\)는 \\[ y_{ij} \\sim \\mathcal{N}(\\mu_i, \\sigma^2_i = \\sigma^2) \\] 이고, \\(i = 1, 2\\), \\(j = 1, \\ldots, n_i\\), \\(n_i\\)는 \\(i\\) 번째 집단의 표본 크기임. 위 모형은 다음과 같은 가정을 내포함. 두 집단의 관찰값은 정규분포를 따르며, 각 집단 간 평균은 서로 다름. 각 관찰값은 서로 독립 두 집단의 분산은 동일: \\(\\sigma^2_1 = \\sigma^2_2 = \\sigma^2\\) 두 집단 간 평균 차이 검정에 대한 귀무가설과 대립가설은 아래와 같이 설정 \\[ H_0: \\mu_1 = \\mu_2~~~\\mathrm{vs.}~~~H_1: \\mu_1 \\neq \\mu_2 \\] 위 가설검정을 위한 검정 통계량 \\[ t_0 = \\frac{\\hat{\\mu}_1 - \\hat{\\mu}_2 - 0}{s_p\\sqrt{\\frac{1}{n_1} + \\frac{1}{n_2}}} \\sim t_{\\nu = n_1 + n_2 -2} \\] 여기서 \\(\\hat{\\mu}_{1} = \\sum_{j=1}^{n_1} y_{1j}/n_1\\), \\(\\hat{\\mu}_{2} = \\sum_{j=1}^{n_2} y_{2j}/n_2\\), 집단 1과 집단 2의 표본합동분산(sample pooled-variance)는 아래와 같음 \\[ \\sigma_p^2 = \\frac{(n_1 - 1)\\hat{\\sigma_1}^2 + (n_2 -1)\\hat{\\sigma}_2^2}{n_1 + n_2 - 2}, ~~~ \\hat{\\sigma}_i^2 = \\frac{\\sum_{j=1}^{n_i} (y_{ij} - \\hat{\\mu}_i)^2}{n_i - 1} \\] 예시: 월경통 데이터 20대 월경통 환자와 대조군 간 요골동맥(손목) 맥파의 차이를 탐색하기 위한 임상연구에서 수집한 데이터의 일부이고, 해당 데이터는 통계패키지활용 Github 저장소에서 다운로드 가능 # 독립 이표본 t-검정 함수 만들어 보기 indep_t_test &lt;- function(y = y, group = group, conf.level = 0.95, na.rm = TRUE) { if (!is.numeric(y)) stop(&quot;y는 수치형 벡터만 가능합니다&quot;) if (length(unique(group)) != 2) stop(&quot;수준의 수가 2가 아닙니다&quot;) if (!is.factor(group)) group &lt;- factor(group) nvec &lt;- tapply(y, group, FUN = function(x) sum(!is.na(x))) mvec &lt;- tapply(y, group, mean, na.rm = TRUE) # 집단별 평균 vvec &lt;- tapply(y, group, var, na.rm = TRUE) # 집단별 분산 degf &lt;- sum(nvec) - 2 # 자유도 mean_diff &lt;- mvec[1] - mvec[2] # 평균 차이 pool_var &lt;- sum((nvec - 1) * vvec)/(sum(nvec) - 2) # 합동분산 std_err &lt;- sqrt(sum(pool_var * (1/nvec))) t_stat &lt;- mean_diff/std_err pvalue &lt;- 2*(1 - pt(abs(t_stat), df = sum(nvec) - 2)) # 양측검정 ucl &lt;- mean_diff + qt(1 - (1 - conf.level)/2, df = degf) * std_err lcl &lt;- mean_diff - qt(1 - (1 - conf.level)/2, df = degf) * std_err out &lt;- list( statistic = t_stat, parameter = degf, p.value = pvalue, conf.int = c(ucl, lcl), estimate = mean_diff, stderr = std_err ) return(out) } # 데이터 불러오기 dysmenorrhea &lt;- read_rds(&quot;data/dysmenorrhea.rds&quot;) head(dysmenorrhea) %&gt;% kbl() %&gt;% kable_paper() %&gt;% scroll_box(width = &quot;100%&quot;, height = &quot;200px&quot;) id pidyn age height weight bmi sysbp diabp pulse temp mmpscr pdi 1 Dysmenorrhea 26 170.2 55.3 19.09000 116 80 71 36.9 7.000000 6.633891 2 Control 26 156.0 48.7 20.01151 83 53 53 36.6 2.185714 8.602493 3 Dysmenorrhea 19 168.0 53.2 18.84921 120 75 72 36.6 5.000000 8.643624 4 Dysmenorrhea 23 153.0 44.5 19.00978 100 79 67 36.8 6.685714 9.321545 5 Dysmenorrhea 24 168.3 57.0 20.12364 105 77 78 36.1 5.885714 10.290806 6 Dysmenorrhea 27 159.1 53.4 21.09604 97 64 61 36.6 6.757143 8.282563 PDI(맥의 깊이)의 두 집단(월경통 vs. 대조군) 간 평균 차이 검정 \\(\\rightarrow\\) 독립 이표본 t-검정 # indep_t_test(), t.test(..., var.equal=TRUE), lm() 함수 비교 y &lt;- dysmenorrhea$pdi grp &lt;- dysmenorrhea$pidyn indep_t_test(y = y, group = grp) $statistic Control 2.68792 $parameter [1] 45 $p.value Control 0.01004294 $conf.int Control Control 1.9523625 0.2797803 $estimate Control 1.116071 $stderr [1] 0.4152176 # t.test() 함수 사용: 수식표현 t.test(pdi ~ pidyn, data = dysmenorrhea, var.equal = TRUE) Two Sample t-test data: pdi by pidyn t = 2.6879, df = 45, p-value = 0.01004 alternative hypothesis: true difference in means is not equal to 0 95 percent confidence interval: 0.2797803 1.9523625 sample estimates: mean in group Control mean in group Dysmenorrhea 10.414276 9.298205 # t.test(y[grp == &quot;Control&quot;], y[grp == &quot;Dysmenorrhea&quot;], var.equal = TRUE) ## 위 결과와 동일 # lm() 함수 사용 m1 &lt;- lm(y ~ grp) summary(m1) Call: lm(formula = y ~ grp) Residuals: Min 1Q Median 3Q Max -3.3332 -0.8051 -0.1235 1.0716 2.2801 Coefficients: Estimate Std. Error t value Pr(&gt;|t|) (Intercept) 10.4143 0.2905 35.854 &lt;2e-16 *** grpDysmenorrhea -1.1161 0.4152 -2.688 0.01 * --- Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Residual standard error: 1.423 on 45 degrees of freedom Multiple R-squared: 0.1383,\tAdjusted R-squared: 0.1192 F-statistic: 7.225 on 1 and 45 DF, p-value: 0.01004 m2 &lt;- lm(pdi ~ pidyn, data = dysmenorrhea) # m1과 동일 boxplot(y ~ grp, col = c(&quot;darkgray&quot;, &quot;orange&quot;)) 4.2.3 일원배치 분산분석(oneway analysis of variance) 두 모집단의 평균을 비교하는 경우 \\(t\\) 검정 사용 3 개 이상 집단의 평균비교: 3개 집단 중 두 집단씩 짝을 지어 \\(t\\) 검정을 실시하는 방법 \\(\\rightarrow\\) 총 3번(\\(_3\\mathrm{C}_2 = 6\\))의 \\(t\\) 검정 실시 위 기술 방법의 문제점 모든 통계적 가설검정은 1종 오류(type I error)를 포함하고 있음. 유의수준이 0.05인 경우(\\(\\alpha = 0.05\\)), 통계적 검정 시 귀무가설을 지지할 확률은 95 %임. 만약 3 번의 \\(t\\) 검정을 수행했을 때, 모든 검정 시 귀무가설을 지지할 확률 = \\((1 - 0.05)^3 = 0.8574\\) 즉 귀무가설이 참일 때 3 번의 검정 중 하나라도 차이를 보일 확률(대립가설을 지지할 확률) = 1 - 0.8754 = 0.1426 \\(\\rightarrow\\) 처음 설정한 유의수준보다 커짐 일원배치 분산분석의 개념 다음과 같이 확률변수가 주어졌을 때, 가정 각 집단의 관찰값은 정규분포를 따른다 각 집단의 분산은 동일하다 오차항은 서로 독립이며, 평균이 0이고 분산이 \\(\\sigma^2\\)인 정규분포를 따른다. \\[ \\begin{cases} Y_{11}, \\cdots, Y_{1n_1} &amp; \\stackrel{iid}{\\sim} &amp; \\mathcal{N}(\\mu_1, \\sigma^2) \\\\ Y_{21}, \\cdots, Y_{2n_2} &amp; \\stackrel{iid}{\\sim} &amp; \\mathcal{N}(\\mu_2, \\sigma^2) \\\\ &amp; \\vdots &amp; \\leftarrow \\mathrm{independent} \\\\ Y_{i1}, \\cdots, Y_{in_i} &amp; \\stackrel{iid}{\\sim} &amp; \\mathcal{N}(\\mu_i, \\sigma^2) \\\\ \\end{cases}, ~~~ i \\geq 2 \\] 아래와 같은 선형모형을 고려해보자. \\[ y_{ij} = \\mu + \\alpha_i + \\epsilon_{ij}, ~~~ \\epsilon_{ij} \\stackrel{iid}{\\sim} \\mathcal{N}(0, \\sigma^2) \\] 여기서 \\(i = 1, \\ldots, g\\)로 집단의 개수(요인의 수준 수)를 나타내며 \\(j = 1, \\ldots, n_i\\)로 집단(수준) \\(i\\)의 관측수(표본 크기)를 나타내고, \\(\\alpha_i\\)는 요인의 효과를 나타내고 아래와 같은 제약조건을 가짐. \\[ \\sum_{i=1}^{g}\\alpha_i = \\sum_{i=1}^{g}(\\mu_i - \\mu) = 0 \\] Figure 4.1: 효과 \\(\\alpha\\)에 대한 이해 위 모형에 대한 통계적 가설 \\[ H_0: \\mu_1 = \\mu_2 = \\cdots =\\mu_g~~~\\mathrm{vs.}~~~H_1: \\mathrm{not}~H_0~(\\mathrm{not~all}~\\mu_i~\\mathrm{are ~ equal}) \\] \\(H_0\\)가 참일 때 \\(\\mu_1 = \\mu_2 = \\cdots =\\mu_g = \\mu\\) 이므로, 위 통계적 가설을 \\(\\alpha_i\\)에 대해 다시 표현하면 \\[ H_0: \\alpha_1 = \\alpha_2 = \\cdots =\\alpha_g = 0~~~\\mathrm{vs.}~~~H_1: \\mathrm{not}~H_0~(\\mathrm{not~all}~\\alpha_i~\\mathrm{are ~ equal~ to~ 0}) \\] 이러한 검정을 일원배치 분산분석(oneway analysis of variance, oneway ANOVA)라고 함. ANOVA는 요인의 수준에 기인한 변동(집단 간 변동, between group)과 각 개인 간 변동(집단 내 변동, within group)을 비교 즉, 각 집단의 평균이 전체평균(grand mean)으로부터 얼마나 멀리 떨어졌는지와 집단 내 변동을 비교해 각 집단의 평균이 동일한지를 검정 평균의 동질성을 확인하기 위해 평균의 변동성을 사용했기 때문에 분산분석이라는 이름을 가짐 분산분석의 변동분해 과정 분산분석을 위해 필요한 기본 통계량 각 집단의 평균 \\[ \\hat{\\mu}_i = \\bar{y}_{i.} = \\frac{1}{n_i} \\sum_{j = 1}^{n_i} y_{ij} \\] 전체 평균 \\[ \\hat{\\mu} = \\bar{y}_{..} = \\frac{1}{N}\\sum_{i = 1}^{g} \\sum_{j = 1}^{n_i} y_{ij}, ~~ N=\\sum_{i=1}^{g} n_i \\] 각 집단의 표본 분산 \\[ \\hat{\\sigma}^2_i = s_i^2 = \\frac{1}{n_i - 1} \\sum_{i = 1}^{n_i} (y_{ij} - \\bar{y}_{i.})^2 \\] 위 통계량을 이용해 처음 고려한 선형 모형을 표현해 보면, \\[ y_{ij} = \\bar{y}_{..} + (\\bar{y}_{i.} - \\bar{y}_{..}) + (y_{ij} - \\bar{y}_{i.}) \\] 귀무가설이 사실인 경우(\\(\\alpha_i = 0\\)), \\(y_{ij} = \\mu + \\epsilon_{ij}\\) 일 것이고 \\(\\hat{\\alpha}_i = \\bar{y}_{i.} - \\bar{y}_{..}\\)의 값은 0에 가깝게 나타날 것임 위의 식을 다시 표현하면 \\[ y_{ij} - \\bar{y}_{..} = (\\bar{y}_{i.} - \\bar{y}_{..}) + (y_{ij} - \\bar{y}_{i.}) \\] 이고, \\(y_{ij} - \\bar{y}_{..}\\): 각 관찰값에서 전체 평균을 뺀 값 \\(\\rightarrow\\) 전체 평균으로부터의 편차 \\(\\rightarrow\\) 전체 편차(total deviation) \\(\\bar{y}_{i.} - \\bar{y}_{..}\\): 각 집단 평균에서 전체 평균을 뺀 값 \\(\\rightarrow\\) 집단(처리효과) 편차(between group deviation) \\(y_{ij} - \\bar{y}_{i.}\\): 각 관찰값에서 해당 관찰값에 대응한 집단 평균을 뺀 값 \\(\\rightarrow\\) 집단내 편차(within group deviation) 즉 총 변동(편차)은 집단 간 변동(편차)과 집단 내 변동(편차)으로 분해 가능하고 제곱합으로 표현 SST: total sum of squares (전체 편차 제곱합) \\[ SST = \\sum_{i=1}^{g} \\sum_{j=1}^{n_i} (y_{ij} - \\bar{y}_{..})^2 \\] SSB: between group sum of squares (집단 간 편차 제곱합) \\[ SSB = \\sum_{i=1}^{g} \\sum_{j=1}^{n_i} (\\bar{y}_{i.} - \\bar{y}_{..})^2 = \\sum_{i=1}^{g} n_i (\\bar{y}_{i.} - \\bar{y}_{..})^2 \\] SSW: within group sum of squares (집단 내 편차 제곱합) \\[ SSW = \\sum_{i=1}^{g} \\sum_{j=1}^{n_i} (y_{ij} - \\bar{y}_{i.})^2 = \\sum_{i=1}^{g} n_i s_i^2 \\] 최종적으로 아래와 같은 표현이 가능함 \\[ \\sum_{i=1}^{g} \\sum_{j=1}^{n_i} (y_{ij} - \\bar{y}_{..})^2 ~(=SST) = \\sum_{i=1}^{g} n_i (\\bar{y}_{i.} - \\bar{y}_{..})^2~(=SSB) + \\sum_{i=1}^{g} n_i s_i^2~(=SSW)\\\\ \\] 분산분석의 검정 원리 요인의 효과가 크다 \\(\\rightarrow\\) 집단 간 변동이 커짐 \\(\\rightarrow\\) \\(SSB\\)가 커짐 \\(\\rightarrow\\) 집단 간 평균 차이가 존재 요인의 효과가 없다 \\(\\rightarrow\\) 집단 간 변동이 작음 \\(\\rightarrow\\) \\(SSB\\)가 작음 \\(\\rightarrow\\) 집단 간 평균 차이가 없음 총변동(\\(SST\\)) 중 집단 간 변동(\\(SSB\\))이 커지게 되면 \\(SSW\\)는 작아지고 귀무가설을 기각할 가능성이 높아짐 \\(SSW\\)와 \\(SSB\\)의 비율을 검정 통계량으로 사용 \\(\\rightarrow\\) 제곱합의 비율 \\(\\rightarrow\\) 분산의 비율 \\(\\rightarrow\\) \\(F\\) 검정 실제 분산분석은 제곱합을 대응하는 자유도로 나눈 평균제곱합을 기반으로 검정 실시 각 제곱합의 자유도 \\(SST\\): 총관측수 - 전체평균 = \\(\\sum_{i=1}^{g} n_i - 1 = N - 1\\) \\(SSB\\): 전체 수준(집단)의 수 - 전체 평균 = \\(g - 1\\) \\(SSW\\): 각 집단마다 제곱합 계신 기준이 다름. 즉 첫 번째 집단의 첫 번째 관찰값 \\(y_{11}\\) 의 편차 계산 시 \\(\\bar{y}_{1.}\\) 만 사용 \\((n_1 - 1) + (n_2 - 1) + \\cdots + (n_g -1) = \\sum_{i = 1}^{g}n_i - g = N - g\\) 검정에 기초가 되는 평균제곱 \\(MSB = SSB/(g - 1)\\): 집단(요인 수준) 평균들의 분산 \\(MSW = SSE/(N - g)\\): 평균제곱오차(mean square error: MSW) \\(\\rightarrow\\) \\(\\sigma^2\\)의 불편 추정량 \\(H_0\\) 하에서 \\(SSB/\\sigma^2 \\sim \\chi^2_{\\nu = g - 1}\\), \\(SSW/\\sigma^2 \\sim \\chi^2_{\\nu = N-g}\\) 이므로, 두 평균 변동의 비율은 \\[ F_0 = \\frac{(SSB/\\sigma^2)/(g - 1)}{(SSW/\\sigma^2)/(N-g)} = \\frac{MSB}{MSW} \\sim F_{\\nu_1 = g - 1, \\nu_2 = N - g} \\] 분산분석 표(ANOVA table) Source Sum of Squares Degrees of Freedom Mean Square \\(F\\) Between SSB \\(g - 1\\) SSB / DFB MSB / MSW Within SSW \\(N - g\\) SSW / DFW Total SST \\(N - 1\\) 예제1: 분산분석 원리를 시뮬레이션을 통해 확인 (집단의 수 \\(g = 3\\), 각 집단 내 표본크기 \\(n_1=n_2=n_3=20\\)) # 함수 생성 plot_anova_sim &lt;- function(n = 20, #각 집단의 관찰값 개수 g = 3, mvec = c(0, 0, 0), sigma = 1, cols = c(&quot;dodgerblue&quot;, &quot;darkorange&quot;, &quot;black&quot;)) { y &lt;- rnorm(n * g, mean = mvec, sd = sigma) # 주어진 인수로부터 관찰값 생성 group &lt;- factor(rep(LETTERS[1:g], n)) # 요인의 수준(집단) 생성 # 이론적 분포 도표 생성 xmin &lt;- min(mvec) - 3 * sigma # 이론적 분포의 최솟값: 도표 생성 시 사용 xmax &lt;- max(mvec) + 3 * sigma # 이론적 분포의 최댓값: 도표 생성 시 사용 dx &lt;- seq(xmin, xmax, length = 500) # 정규분포 밀도함수 x축 범위 plot(0, main = &quot;Truth&quot;, xlim = c(xmin, xmax), ylim = c(0, 0.4), type = &quot;n&quot;, xlab = &quot;observation&quot;, ylab = &quot;density&quot;) for (i in 1:g) { lines(dx, dnorm(dx, mean = mvec[i], sd = sigma), col = cols[i], lty = i, lwd = 2) rug(y[group == levels(group)[i]], col = cols[i], ticksize = 0.1, lty = i, lwd = 1.5) } boxplot(y ~ group, xlab = &quot;group&quot;, main = &quot;Observed Data&quot;, medcol = &quot;white&quot;, varwidth = FALSE) stripchart(y ~ group, vertical = TRUE, method = &quot;jitter&quot;, add = TRUE, pch = 20, cex = 2, col = cols) abline(h = mean(y), lwd = 3, lty = 1, col = &quot;darkgray&quot;) for (i in 1:g) { segments(x0 = i - round(1/g, 1), x1 = i + round(1/g, 1), y0 = mean(y[group == levels(group)[i]]), y1 = mean(y[group == levels(group)[i]]), lty = 2, col = cols[i], lwd = 2) } # 집단 별 평균선 표시 # 일원배치 분산분석 grand_mean_obs &lt;- mean(y) # 전체평균 group_mean_obs &lt;- tapply(y, group, mean) # 집단 평균 sst &lt;- sum((y - grand_mean_obs)^2) ssw &lt;- rep(NA, g) for (i in 1:g) { ssw[i] &lt;- sum((y[group == levels(group)[i]] - group_mean_obs[i])^2) } ssw &lt;- sum(ssw) ssb &lt;- sst - ssw msb &lt;- ssb/(g - 1) msw &lt;- ssw/(length(y) - g) Fval &lt;- msb/msw pval &lt;- 1 - pf(Fval, g - 1, length(y) - g) test_result &lt;- data.frame( Source = c(&quot;Between&quot;, &quot;Within&quot;, &quot;Total&quot;), SS = c(ssb, ssw, sst), degf = c(g - 1, length(y) - g, length(y) - 1), MS = c(msb, msw, NA), F.value = c(Fval, NA, NA), p.value = c(pval, NA, NA) ) out &lt;- list(y = y, group = group, result = test_result) return(out) } Case 1: 집단 간 평균 차이가 존재하지 않는 경우 (\\(\\mu_1 = \\mu_2 = \\mu_3 = 0, \\sigma^2 = 1\\)) par(mfrow = c(1, 2)) set.seed(123) out1 &lt;- plot_anova_sim(n = 20, g = 3, mvec = c(0, 0, 0), sigma = 1) out1$result %&gt;% kbl(caption = &quot;ANOVA table ($\\\\mu_1 = \\\\mu_2 = \\\\mu_3 = 0, \\\\sigma^2 = 1$)&quot;, escape = FALSE) %&gt;% # kableExtra 패키지 사용방법 참고 kable_paper() Table 4.1: ANOVA table (\\(\\mu_1 = \\mu_2 = \\mu_3 = 0, \\sigma^2 = 1\\)) Source SS degf MS F.value p.value Between 0.3568695 2 0.1784348 0.2095279 0.8115888 Within 48.5414289 57 0.8516040 NA NA Total 48.8982984 59 NA NA NA # check # anova(with(out1, lm(y ~ group))) Case 2: 집단 간 평균 차이가 뚜렷한 경우 (\\(\\mu_1 = -5, \\mu_2 = 0, \\mu_3 = 5, \\sigma^2 = 1\\)) par(mfrow = c(1, 2)) set.seed(123) out2 &lt;- plot_anova_sim(n = 20, g = 3, mvec = c(-5, 0, 5), sigma = 1) out2$result %&gt;% kbl(caption = &quot;ANOVA table ($\\\\mu_1 = -5, \\\\mu_2 = 0, \\\\mu_3 = 5, \\\\sigma^2 = 1$)&quot;, escape = FALSE) %&gt;% # kableExtra 패키지 사용방법 참고 kable_paper() Table 4.2: ANOVA table (\\(\\mu_1 = -5, \\mu_2 = 0, \\mu_3 = 5, \\sigma^2 = 1\\)) Source SS degf MS F.value p.value Between 1009.30665 2 504.653326 592.5915 0 Within 48.54143 57 0.851604 NA NA Total 1057.84808 59 NA NA NA Case 3-a: 집단 간 평균 차이가 존재 (\\(\\mu_1 = -1, \\mu_2 = 0, \\mu_3 = 1, \\sigma^2 = 1\\)) par(mfrow = c(1, 2)) set.seed(123) out3 &lt;- plot_anova_sim(n = 20, g = 3, mvec = c(-1, 0, 1), sigma = 1) out3$result %&gt;% kbl(caption = &quot;ANOVA table ($\\\\mu_1 = -1, \\\\mu_2 = 0, \\\\mu_3 = 1, \\\\sigma^2 = 1$)&quot;, escape = FALSE) %&gt;% # kableExtra 패키지 사용방법 참고 kable_paper() Table 4.3: ANOVA table (\\(\\mu_1 = -1, \\mu_2 = 0, \\mu_3 = 1, \\sigma^2 = 1\\)) Source SS degf MS F.value p.value Between 42.14683 2 21.073413 24.74555 0 Within 48.54143 57 0.851604 NA NA Total 90.68825 59 NA NA NA Case 3-b: 집단 간 평균 차이가 존재 (\\(\\mu_1 = -1, \\mu_2 = 0, \\mu_3 = 1, \\sigma^2 = 3\\)) par(mfrow = c(1, 2)) set.seed(123) out4 &lt;- plot_anova_sim(n = 20, g = 3, mvec = c(-1, 0, 1), sigma = 3) out4$result %&gt;% kbl(caption = &quot;ANOVA table ($\\\\mu_1 = -1, \\\\mu_2 = 0, \\\\mu_3 = 1, \\\\sigma^2 = 3$)&quot;, escape = FALSE) %&gt;% # kableExtra 패키지 사용방법 참고 kable_paper() Table 4.4: ANOVA table (\\(\\mu_1 = -1, \\mu_2 = 0, \\mu_3 = 1, \\sigma^2 = 3\\)) Source SS degf MS F.value p.value Between 48.5817 2 24.290848 3.169294 0.0495319 Within 436.8729 57 7.664436 NA NA Total 485.4546 59 NA NA NA 예제2: faraway 패키지 내 coagulation 데이터셋 24 마리 쥐를 무작위로 4 가지 종류의 먹이(A, B, C, D)를 주고 혈액 응고 시간 측정 # 데이터 테이블 생성 # install.packages(&quot;faraway&quot;) require(faraway) coagulation %&gt;% mutate(rowname = c(1:4, 1:6, 1:6, 1:8)) %&gt;% pivot_wider( names_from = &quot;diet&quot;, values_from = coag ) %&gt;% kbl %&gt;% kable_paper rowname A B C D 1 62 63 68 56 2 60 67 66 62 3 63 71 71 60 4 59 64 67 61 5 NA 65 68 63 6 NA 66 68 64 7 NA NA NA 63 8 NA NA NA 59 데이터 탐색 boxplot(coag ~ diet, data = coagulation) stripchart(coag ~ diet, data = coagulation, vertical = TRUE, method = &quot;jitter&quot;, add = TRUE, pch = 20, cex = 2) 일원배치 분산분석 # install.packages(&quot;car&quot;) require(car) require(tidymodels) # 등분산 검정: Fligner-Kileen&#39;s test fligner.test(coag ~ diet, data = coagulation) Fligner-Killeen test of homogeneity of variances data: coag by diet Fligner-Killeen:med chi-squared = 1.5559, df = 3, p-value = 0.6694 # 등분산 검정: Levene&#39;s test (SPSS) car::leveneTest(coag ~ diet, data = coagulation) # 정규성 검정: shapiro-wilk&#39;s test coagulation %&gt;% group_by(diet) %&gt;% nest %&gt;% mutate(normal_test = map(data, ~shapiro.test(.x$coag))) %&gt;% mutate(result = map(normal_test, ~ tidy(.x))) %&gt;% unnest(cols = result) %&gt;% select(diet, statistic:method) %&gt;% kbl() %&gt;% kable_paper() diet statistic p.value method A 0.9497060 0.7142802 Shapiro-Wilk normality test B 0.9223854 0.5227052 Shapiro-Wilk normality test C 0.8727857 0.2375366 Shapiro-Wilk normality test D 0.9317252 0.5319098 Shapiro-Wilk normality test # 일원배치 분산분석 mod &lt;- lm(coag ~ diet, data = coagulation) anova(mod) # 사후검정(post-hoc test): Tukey&#39;s honestly significant difference (HSD) plot(TukeyHSD(aov(mod), conf.level = 0.95)) # install.packages(&quot;emmeans&quot;) require(emmeans) em0 &lt;- emmeans(mod, ~ diet) pair_cont &lt;- contrast(em0, method = &quot;pairwise&quot;, adjust = &quot;tukey&quot;) # 대비검정 tidy(pair_cont) %&gt;% mutate_if(is.numeric, format, digits = 3) %&gt;% kbl %&gt;% kable_paper term contrast null.value estimate std.error df statistic adj.p.value diet A - B 0 -5.00e+00 1.53 20 -3.27e+00 0.018328 diet A - C 0 -7.00e+00 1.53 20 -4.58e+00 0.000958 diet A - D 0 1.58e-14 1.45 20 1.09e-14 1.000000 diet B - C 0 -2.00e+00 1.37 20 -1.46e+00 0.476601 diet B - D 0 5.00e+00 1.28 20 3.91e+00 0.004411 diet C - D 0 7.00e+00 1.28 20 5.48e+00 0.000127 분산분석 결과는 각 집단(처리) 중 어느 한 집단이라도 차이를 보이면 기각. 만약 분산분석 시 귀무가설(평균이 모두 같다)을 기각했을 경우 어떤 집단에서 평균의 차이를 보였는지 알아볼 필요가 있음. 사후검정 F 검정 결과 집단 간 평균이 다르다는 결론을 얻은 경우 어떤 집단의 평균이 다른 집단과 차이가 있는지를 알아보기 위한 검정 방법 가장 기본이 되는 원리는 type I error의 조절(t 검정 예 참조) Sheffe: 절차 간단, 표본 크기가 달라도 적용 가능 Bonferroni: 유의수준을 비교집단 수로 나눈 유의수준 사용 Tukey(honestly significant difference): 매우 보수적 Duncan: 다른 다중비교 방법에 비해 덜 보수적임 Bonferroni &gt; Tukey &gt; Duncan &gt; Sheffe "],
["ch4-application.html", "4.3 Application", " 4.3 Application R에서 통계적 모형 표현 방법 지금까지 별다른 설명 없이 ~가 들어간 수식표현을 특정함수(예: lm(), t.test(), 심지어 그래프 생성에 필요한 함수 등)의 인수로 사용함. R은 (통계적) 모형을 표현하기 위해 formula 표현을 사용 \\(\\rightarrow\\) 일반적으로 좌변 ~ 우변형태로 표시 보통은 특정 함수 내에서 호출되며 데이터에 포함되어 있는 변수를 평가하지 않고 해당 함수에서 해석할 수 있도록 변수값을 불러올 수 있음. formula는 “language” 객체의 일종이며 “formula” 클래스를 속성으로 갖는 평가되지 않은 표현식(unevaluated expression) typeof(quote(x + 10)) # 객체의 형태가 &quot;language&quot; [1] &quot;language&quot; class(quote(x + 10)) # 객체의 클래스가 &quot;call&quot; [1] &quot;call&quot; R에서 formula을 특정하는 ~의 의미는 “즉시 평가(evaluate)하지 않고 이 코드의 의미를 전달(캡쳐)” \\(\\rightarrow\\) 인용(quote) 연산자 볼 수 있는 이유임 # 수식 표현 a &lt;- y ~ x b &lt;- y ~ x + b c &lt;- ~ x + y + z typeof(c); class(c); attributes(c) [1] &quot;language&quot; [1] &quot;formula&quot; $class [1] &quot;formula&quot; $.Environment &lt;environment: R_GlobalEnv&gt; 가장 기본적인 formula 표현의 형태는 아래와 같음 반응변수(response variable) ~ 독립변수(independent variables) "],
["references.html", "References", " References "]
]
